<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>记一次 UnRaid U盘损坏修复的过程</title>
    <link href="/2023/12/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%20UnRaid%20U%E7%9B%98%E6%8D%9F%E5%9D%8F%E4%BF%AE%E5%A4%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82%E3%80%82%E3%80%82/"/>
    <url>/2023/12/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%20UnRaid%20U%E7%9B%98%E6%8D%9F%E5%9D%8F%E4%BF%AE%E5%A4%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82%E3%80%82%E3%80%82/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次-unRaid-U盘损坏修复的过程。。。"><a href="#记一次-unRaid-U盘损坏修复的过程。。。" class="headerlink" title="记一次 unRaid U盘损坏修复的过程。。。"></a>记一次 unRaid U盘损坏修复的过程。。。</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间 unRAID 系统提示 flash 写失败了，没当回事，以为只是偶发的一次写错误，应该问题不大。</p><p>过了几天之后，在整理磁盘空间的时候，突然发现备份目录下有大概十几个的 boot 目录备份包，然而这些备份的压缩包本不应该出现在这里，而且这些压缩包的大小也存在异常，这就意味着 unRAID 已经有超过10天备份失败了。</p><p>这里说一下我预设的定时备份任务：每天凌晨 3 点自动打包 &#x2F;boot 目录，然后通过 rclone 将阿里云盘挂载到本地，通过文件名中的时间戳判断并删除 7 天之前的备份文件，之后将新的备份文件上传到阿里云盘上。</p><p>出现了这样的问题，不想折腾都不行了。。。</p><h2 id="尝试修复过程"><a href="#尝试修复过程" class="headerlink" title="尝试修复过程"></a>尝试修复过程</h2><h3 id="尝试-1-——-手动打包"><a href="#尝试-1-——-手动打包" class="headerlink" title="尝试 1 —— 手动打包"></a>尝试 1 —— 手动打包</h3><p>因为之前周末电工师傅来换空开，直接拉闸断电了，怀疑会不会是这个导致了异常，于是尝试手动拷贝 &#x2F;boot 目录，并进行手动打包。</p><p>拷贝倒是成功了，flash 中的 &#x2F;boot 目录直接能拷贝到硬盘的共享目录中，但是打包同样失败了，提示文件损坏，而且文件名是乱码。。。</p><h3 id="尝试-2-——-删除-Nvidia-Drive-Plugin"><a href="#尝试-2-——-删除-Nvidia-Drive-Plugin" class="headerlink" title="尝试 2 —— 删除 Nvidia Drive Plugin"></a>尝试 2 —— 删除 Nvidia Drive Plugin</h3><p>上次重启后，英伟达驱动莫名其妙掉了，然后尝试重新下载也提示下载失败，然而本来也是闲置的功能，而且本着能不折腾就不折腾的主旨，也是放任没管。</p><p>猜测打包失败会不会和 Nvidia Drive Plugin 下载驱动失败导致的问题，ssh 进入后台后查看 &#x2F;boot&#x2F;config&#x2F;plugin 中这个插件的目录，确实发现了几个大小异常的驱动包，和几个乱码的文件。</p><p><code>rm ./* -rf</code> 回车一敲，以为此次修复完美谢幕。删除后确实打包成功了，但是尝试重启后，直接无法启动了！出现了一堆错误日志，并且 web gui 无法启动，设置了自动挂载的阵列也没有挂载，docker 无法和 docker.sock 通信。。。什么鬼啊！</p><h3 id="尝试-3-——-重新制作-U-盘"><a href="#尝试-3-——-重新制作-U-盘" class="headerlink" title="尝试 3 —— 重新制作 U 盘"></a>尝试 3 —— 重新制作 U 盘</h3><p>排查错误不如我直接重做 U 盘，又快又不用动脑子，结果上官网一看 6.10.3 的下载链接已经从官网上下架了。。。我特意存储的备份系统镜像也在 unRaid 的阵列中。。。</p><p>翻箱倒柜找，终于在回收站里找到了之前下载的官方进行包。下载写盘器、写 U 盘、拷贝config、插 U 盘、开机，一气呵成。我嘞个豆。。。怎么还全是 ERROR 啊！！！</p><h3 id="尝试-4-——-解决-ERROR"><a href="#尝试-4-——-解决-ERROR" class="headerlink" title="尝试 4 —— 解决 ERROR"></a>尝试 4 —— 解决 ERROR</h3><p>不得已，只能解决 ERROR 了。</p><p>还好 unRAID 提示的还算清楚，仔细一看，嗨，这不是 docker 容器配置的 xml 解析失败了么，提示有格式错误。打开 U盘 中的 xml 检查了一下，确实有几个文件内容中出现了随机乱码的情况，导致格式错误。</p><p>将之前阿里云网盘上正确备份的文件下载下来，检查无误后替换错误文件，重启，这下总算是正常启动了。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>虽然系统正常了，但是问题的根本原因其实并没有找到。</p><p>目前仍然不清楚导致 docker 容器配置 xml 文件内容出现随机乱码的原因，怀疑的方向有几个：一是每天读 flash 进行备份，增大了 flash 出错的风险可能，毕竟 flash 不像硬盘那样耐*；二是拉闸断电导致的异常，不过这个我也没敢尝试复现，真出问题了，代价不小；三是 Nvidia Drive Plugin 出错，导致备份时出错，异常情况下导致 xml 出错。</p><p>由于之前备份都失败了，所以并不能确定 xml 出错的时间。几个猜测的点都是比较难去重现的，只能说后续使用上尽量谨慎一些吧。</p><p>Nvidia 的驱动插件，本来也是闲置的，所以不考虑重新安装了，而且万一后续有虚拟机直通显卡的需求，还得卸载。</p><p>备份策略也做了一定的修改，由原来的直接 tar 命令压缩 &#x2F;boot 目录，修改为将 &#x2F;boot&#x2F;config 目录拷贝至硬盘后再进行压缩备份。备份间隔也从每天，修改为每周。当有较大更新时，则手动触发备份。</p><h2 id="折腾"><a href="#折腾" class="headerlink" title="折腾"></a>折腾</h2><p>中国有句古话，“来都来了”。</p><p>嘿嘿，来都来了，不折腾一下，那不得抓耳挠腮，浑身奇痒难耐啊。所以去老毛子的论坛翻了翻，正好有 6.12.6 的包和 hack 文件。于是乎直接下载，替换，完美启动（老脸一红）！</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>flash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git —— Issue 模板</title>
    <link href="/2023/12/27/Git%20%E2%80%94%E2%80%94%20Issue%20%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/12/27/Git%20%E2%80%94%E2%80%94%20Issue%20%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-——-Issue-模板"><a href="#Git-——-Issue-模板" class="headerlink" title="Git —— Issue 模板"></a>Git —— Issue 模板</h1><h2 id="1-什么是-Issue-模板"><a href="#1-什么是-Issue-模板" class="headerlink" title="1. 什么是 Issue 模板"></a>1. 什么是 Issue 模板</h2><p>Issue 模板是在创建 Issue 时，预先填写好的内容，可以是一些提示性的文字，也可以是一些表单，用户在创建 Issue 时，可以根据模板填写内容，这样可以让 Issue 的内容更加规范，也方便了 Issue 的管理。</p><h2 id="2-如何使用-Issue-模板"><a href="#2-如何使用-Issue-模板" class="headerlink" title="2. 如何使用 Issue 模板"></a>2. 如何使用 Issue 模板</h2><h3 id="2-1-创建-Issue-模板"><a href="#2-1-创建-Issue-模板" class="headerlink" title="2.1 创建 Issue 模板"></a>2.1 创建 Issue 模板</h3><p>在项目的根目录下创建一个名为 <code>.gitlab</code> 的文件夹，然后在 <code>.gitlab</code> 文件夹下创建一个名为 <code>issue_templates</code> 的文件夹，然后在 <code>issue_templates</code> 文件夹下创建一个名为 <code>bug_report.md</code> 的文件，这个文件就是 Issue 模板了。</p><h3 id="2-2-编写-Issue-模板"><a href="#2-2-编写-Issue-模板" class="headerlink" title="2.2 编写 Issue 模板"></a>2.2 编写 Issue 模板</h3><p>在 <code>bug_report.md</code> 文件中，可以写一些提示性的文字，也可以写一些表单，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: Bug report<br>about: Create a report to help us improve<br>title: &#x27;&#x27;<br>labels: &#x27;&#x27;<br>assignees: &#x27;&#x27;<br><br>---<br><span class="hljs-section"># 🐞 Bug Reporter</span><br><br><span class="hljs-section">## 📋 Pre-Check</span><br><br><span class="hljs-bullet">-</span> [<span class="hljs-string"> </span>] I have searched the [<span class="hljs-string">issues</span>](<span class="hljs-link">https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/sample-gitlab/-/issuess</span>) of this repository and believe that this is not a duplicate.<br><br><span class="hljs-section">## 🐛 Bug Summary</span><br><br><span class="hljs-quote">&gt; A clear and concise description of what the bug is.</span><br><br><br><span class="hljs-section">## 🐛 Bug Reproduce</span><br><br><span class="hljs-quote">&gt; Steps to reproduce the behavior:</span><br><br><span class="hljs-bullet">1.</span> Go to &#x27;...&#x27;<br><span class="hljs-bullet">2.</span> Click on &#x27;....&#x27;<br><span class="hljs-bullet">3.</span> Scroll down to &#x27;....&#x27;<br><span class="hljs-bullet">4.</span> See error<br><br><span class="hljs-section">## 🐛 Expected Behavior</span><br><br><span class="hljs-quote">&gt; A clear and concise description of what you expected to happen.</span><br><br><span class="hljs-section">## 🐛 Possible Solution</span><br><br><span class="hljs-quote">&gt; Describe the solution you thought of.</span><br><br><span class="hljs-section">## 🐛 Context</span><br><br><span class="hljs-quote">&gt; How has this issue affected you? What are you trying to accomplish? Providing context helps us come up with a solution that is most useful in the real world.</span><br><br><span class="hljs-section">## 🐛 Your Environment</span><br><br><span class="hljs-quote">&gt; Include as many relevant details about the environment you experienced the bug in.</span><br><br>|                  |             |<br>| ---------------- | ----------- |<br>| OS               | x86?        |<br>| Compiler         | gcc-4.8.5 ? |<br>| Lib Ver(s)       |             |<br>| Lib Url          |             |<br>| Other Dependency |             |<br><br><span class="hljs-section">## 🐛 Additional context</span><br><br><span class="hljs-quote">&gt; Add any other context about the problem here.</span><br><br><br></code></pre></td></tr></table></figure><h3 id="2-3-使用-Issue-模板"><a href="#2-3-使用-Issue-模板" class="headerlink" title="2.3 使用 Issue 模板"></a>2.3 使用 Issue 模板</h3><p>在项目的 Issues 页面，点击 New issue 按钮，就可以看到 Issue 模板了，用户在创建 Issue 时，可以根据模板填写内容，这样可以让 Issue 的内容更加规范，也方便了 Issue 的管理。</p><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><ul><li><a href="https://docs.github.com/en/free-pro-team@latest/github/building-a-strong-community/creating-issue-templates-for-your-repository">Creating issue templates for your repository</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git —— Commit Message 规范介绍</title>
    <link href="/2023/12/26/Git%20%E2%80%94%E2%80%94%20Commit%20Message%20%E8%A7%84%E8%8C%83%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/12/26/Git%20%E2%80%94%E2%80%94%20Commit%20Message%20%E8%A7%84%E8%8C%83%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-——-Commit-Message-规范介绍"><a href="#Git-——-Commit-Message-规范介绍" class="headerlink" title="Git —— Commit Message 规范介绍"></a>Git —— Commit Message 规范介绍</h1><h2 id="为什么要规范-Commit-Message"><a href="#为什么要规范-Commit-Message" class="headerlink" title="为什么要规范 Commit Message"></a>为什么要规范 Commit Message</h2><p>日常开发中，我们经常会使用到 Git 进行代码管理，而 Git 中最常用的命令就是 <code>git commit</code>，我们通过 commit 命令将修改后的代码提交到本地仓库，然后再通过 <code>git push</code> 命令将本地仓库的代码推送到远程仓库。</p><p>git 规定提交时必须要写提交信息，作为改动说明，保存在 commit 历史中，方便回溯。规范的 log 不仅有助于他人 review, 还可以有效的输出 CHANGELOG，甚至对于项目的研发质量都有很大的提升，尤其是一些长期持续迭代维护，且多版本长期并存的项目。</p><p>优秀的规范化 Commit Message 应该具备以下优点：</p><ol><li><p>清晰明了：commit message 应该清晰明了，说明本次提交的目的，具体做了什么操作。这样可以让团队成员更好地理解每次提交的内容。</p></li><li><p>便于追溯：规范的 commit message 可以帮助程序员对提交历史进行追溯，了解发生了什么情况。</p></li><li><p>提高研发效率：一旦约束了 commit message，意味着我们将慎重的进行每一次提交，不能再一股脑的把各种各样的改动都放在一个 git commit 里面，这样一来整个代码改动的历史也将更加清晰。</p></li><li><p>自动化工具的友好性：规范的 commit message 可以被自动化工具用于生成发布日志或自动化版本号管理。</p></li><li><p>降低代码维护成本：如果 commit message 写得不清楚，例如使用 “fix bug” 这样笼统的描述，可能会导致后续代码维护成本特别大，有时自己都不知道自己的 “fix bug” 修复的是什么问题</p></li></ol><p>因此，规范化的 commit message 对于团队协作和项目管理是非常重要的。</p><h2 id="Commit-Message-规范"><a href="#Commit-Message-规范" class="headerlink" title="Commit Message 规范"></a>Commit Message 规范</h2><p>在 Git 中 Commit Message 的规范又很多种，其中比较受欢迎的有以下这些：</p><ol><li><p>Angular 规范：这是目前使用最广的写法，比较合理和系统化，并且有配套工具可以辅助生成（VS CODE 插件：git-commit-plugin）。</p></li><li><p>Conventional Commits 规范：这是一个基于语义化版本 (semver) 和简单的消息格式的轻量级约定，一传达代码更改的意图。</p></li></ol><p>这里我们着重介绍一下 Angular 规范。</p><h3 id="Angular-规范"><a href="#Angular-规范" class="headerlink" title="Angular 规范"></a>Angular 规范</h3><p>Angular 规范是一种广泛应用于软件开发中的提交信息（commit message）规范，其目的在于提供一种统一、清晰的提交信息格式，以便于开发者和维护者理解代码的变动情况。</p><p>Angular 规范将提交信息分为三个部分：Header、Body 和 Footer。</p><ol><li><p><strong>Header</strong>：Header 是提交信息的头部，包含三个字段：type、scope 和 subject。</p><ul><li><strong>type</strong>：type 字段用于指明<mark>本次提交的类型</mark>，例如：feat（新功能）、fix（修补bug）、docs（文档）、style（格式）、refactor（重构）、perf（性能优化）、test（增加测试）、chore（构建过程或辅助工具的变动）等。</li><li><strong>scope</strong>：scope 字段用于指明<mark>本次提交影响的范围</mark>，例如：数据层、控制层、视图层等。这个字段是可选的。</li><li><strong>subject</strong>：subject 字段是对<mark>本次提交目的的简短描述</mark>，不超过50个字符。</li></ul></li><li><p><strong>Body</strong>：Body 是提交信息的主体部分，用于<mark>详细描述本次提交的内容和原因</mark>。这个部分是可选的。</p></li><li><p><strong>Footer</strong>：Footer 是提交信息的尾部，通常用于<mark>记录不兼容变动和关闭 Issue</mark>。这个部分也是可选的。</p></li></ol><p>Angular 规范的提交信息格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>): <span class="hljs-tag">&lt;<span class="hljs-name">subject</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BLANK</span> <span class="hljs-attr">LINE</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BLANK</span> <span class="hljs-attr">LINE</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上就是 Angular 规范的基本内容。遵循这种规范可以帮助我们更好地管理代码提交的内容，使得每次提交的目的和主要改动都能清晰地体现在 Commit Message 中，便于后续的代码维护和版本管理。具体的规范可能会因团队和项目的不同而有所差异。所以，虽然 Git 本身没有强制的 Commit Message 规范，但在实际使用中，我们通常会根据实际需求来约定一些规范，以提高代码的可读性和维护性。</p><h2 id="Commit-Message-规范工具"><a href="#Commit-Message-规范工具" class="headerlink" title="Commit Message 规范工具"></a>Commit Message 规范工具</h2><p>在实际开发中，我们通常会使用一些工具来帮助我们规范 Commit Message，这样可以避免我们手动编写 Commit Message，提高开发效率。</p><p>这里介绍一个 VS Code 插件：<strong>git-commit-plugin</strong>，它可以帮助我们快速生成符合 Angular 规范的 Commit Message。这是它的仓库地址：<a href="https://github.com/RedJue/git-commit-plugin">https://github.com/RedJue/git-commit-plugin</a>。我们也可以直接在 VS Code 的扩展商店中直接下载安装。</p><blockquote><p>注意：商店中有两个名为 git-commit-plugin 的插件，我们选择作者为 redjue 的那一个。另一个为fork的版本，已经不再维护。</p></blockquote><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/0cd57b334faac82c88858d17cb3ff3e3/1703558434900.png" alt="git-commit-plugin"></p><p>安装完成后，我们点击 VS Code 左侧面板的存储库图标，可以看到存储库的右边出现了一个 git 图标，点击它就可以打开 git-commit-plugin 的界面。</p><ol><li><p>打开 git-commit-plugin 界面：</p><p>   <img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/153afa2bf93c4a55d9e4c5420aa43ee0/1703558938449.png"></p></li><li><p>选择提交类型，这里以 fix 为例：</p><p>   <img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/1ec1f6e85b71bd74e244632584d64eb3/1703559027194.png"></p></li><li><p>按照 Angular 规范依次完成 scope，subject，body 和 footer 字段</p><p>   <img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/45e369bb0b664b9ee79ae550bc0524cb/1703559610753.png"></p></li><li><p>完成每项内容的填写后，点击 Complete，插件会将填写的内容，按照规范自动生成在左侧源代码管理面板中的提交信息中：</p><p>   <img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/cd6eb2280db4b9e0e125bc83329c0bd6/1703559528891.png"></p><p>   <img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/df8e94be63ac8bdc9528e84a2bf2cd83/1703559648902.png"></p><p>   注意此处 VS Code 会提示“当前行比72超出39个字符”，这是因为 VS Code 限制了提交消息每行的最大长度。我们在上一步编辑 Body 时，受限于插件的界面，将所有内容都写在了一行中，因此在这里我们需要将 Body 部分的内容进行换行，达到美观和规范的目的。</p></li><li><p>最后我们点击提交按钮将本次修改提交到本地仓库，再点击同步就可以将本地仓库的提交记录推送到远程仓库了。</p></li></ol><h2 id="Commit-Message-模板的配置和使用"><a href="#Commit-Message-模板的配置和使用" class="headerlink" title="Commit Message 模板的配置和使用"></a>Commit Message 模板的配置和使用</h2><p>在某些环境下，可能仅有的就是一个命令行终端，我们需要在命令行中手动输入 Commit Message。这时候我们就需要一个 Commit Message 模板来帮助我们快速生成符合规范的 Commit Message。</p><p>以 Linux 端为例，git 提供了一个 commit.template 的配置项，用来指定期望使用的 Commit Message 模板。</p><ol><li><p>首先我们在项目的根目录创建一个 .gitmessage 文件，用来存放 Commit Message 模板：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> .gitmessage<br></code></pre></td></tr></table></figure></li><li><p>然后我们编辑 .gitmessage 文件，将以下内容复制到 .gitmessage 文件中：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># head: &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="hljs-comment"># - type: ✨ feat, 🐞 fix, 📃 docs, 🌈 style, 🦄 refactor, 🎈 perf, 🧪 test, 🔧 build, 🐎 ci, 🐳 chore, ↩ revert</span><br><span class="hljs-comment"># - scope: can be empty (eg. if the change is a global or difficult to assign to a single component)</span><br><span class="hljs-comment"># - subject: start with verb (such as &#x27;change&#x27;), 50-character line</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-comment"># body: 72-character wrapped. This should answer:</span><br><span class="hljs-comment"># * Why was this change necessary?</span><br><span class="hljs-comment"># * How does it address the problem?</span><br><span class="hljs-comment"># * Are there any side effects?</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-comment"># footer: </span><br><span class="hljs-comment"># - Include a link to the ticket, if any.</span><br><span class="hljs-comment"># - BREAKING CHANGE</span><br><span class="hljs-comment">#</span><br><br></code></pre></td></tr></table></figure></li><li><p>在项目路径下，我们通过 <code>git config</code> 命令指定 commit.template 的路径：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config commit.template .gitmessage<br></code></pre></td></tr></table></figure><blockquote><p>注意：这里仅对当前项目进行了模板配置，如果想要对所有项目使用该模板，则将该文件放置到用户目录下，然后在上述命令中添加 –global 参数即可。 </p><p><code>git config --global commit.template ~/.gitmessage</code></p></blockquote></li></ol><p>此时通过命令 <code>git commit</code> （<strong>不能带参数 -m ！</strong>）即可显示模板，并在模板中快速完成 Commit Message 的编辑。</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/2f3bac498fc45f31f266dc5c6edb3135/1703569918312.png"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/a0b698669c2690308be04db208c5dd77/1703570281939.png"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/bd892785244176b2fc593c84e84a81a5/1703570593953.png"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/793f74f73b0aa895fcc4abf8ab95eb4a/1703571607092.png"></p>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Home Assistant——涂鸦智能接入方法</title>
    <link href="/2023/10/25/Home%20Assistant%E2%80%94%E2%80%94%E6%B6%82%E9%B8%A6%E6%99%BA%E8%83%BD%E6%8E%A5%E5%85%A5%E6%96%B9%E6%B3%95/"/>
    <url>/2023/10/25/Home%20Assistant%E2%80%94%E2%80%94%E6%B6%82%E9%B8%A6%E6%99%BA%E8%83%BD%E6%8E%A5%E5%85%A5%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>备注：</p><ol><li>涂鸦</li><li>UI</li><li>node-red</li></ol><h1 id="Home-Assistant——涂鸦智能接入方法"><a href="#Home-Assistant——涂鸦智能接入方法" class="headerlink" title="Home Assistant——涂鸦智能接入方法"></a>Home Assistant——涂鸦智能接入方法</h1><p><img src="https://github.com/rospogrigio/localtuya-homeassistant/raw/master/img/logo-small.png" alt="local tuya"></p><p>最近家中添置了一台小甜橙的自动宠物喂食器，官方说明书中指定使用 “智能生活APP” 进行接入和控制。另外手头上还有一个 “全橙智能” 的智能插座用于控制电脑主机的电源。由于各自的 APP 不同而无法集中控制，因此想将两个设备接入到 Home Assistant 中进行统一管理，而且有跨平台的有点。</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>tuya</tag>
      
      <tag>涂鸦智能</tag>
      
      <tag>HomeAssistant</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git —— 常用指令</title>
    <link href="/2023/07/31/Git%20%E2%80%94%E2%80%94%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/07/31/Git%20%E2%80%94%E2%80%94%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-——-常用命令"><a href="#Git-——-常用命令" class="headerlink" title="Git —— 常用命令"></a>Git —— 常用命令</h1><ol><li><p>克隆</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;git-repository-url&gt; [local-path] <br><span class="hljs-comment"># option</span><br><span class="hljs-comment"># 1. --recursive # 递归克隆子模块</span><br>git <span class="hljs-built_in">clone</span> &lt;git-repository-url&gt; --recursive [local-path]<br><span class="hljs-comment"># 2. --depth=1 # 浅克隆</span><br>git <span class="hljs-built_in">clone</span> &lt;git-repository-url&gt; --depth=1 [local-path]<br><span class="hljs-comment"># 3. --branch &lt;branch-name&gt; / -b &lt;branch-name&gt; # 克隆指定分支</span><br>git <span class="hljs-built_in">clone</span> &lt;git-repository-url&gt; --branch &lt;branch-name&gt; [local-path]<br></code></pre></td></tr></table></figure></li><li><p>提交</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 添加文件</span><br>git add &lt;file-path&gt;<br><span class="hljs-comment"># 2. 提交</span><br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span><br><span class="hljs-comment"># commit option</span><br><span class="hljs-comment"># 1. --amend # 修改上一次提交记录，注意！仅允许在本地仓库修改，不允许在远程仓库修改，且会覆盖上一次提交的记录</span><br>git commit --amend -m <span class="hljs-string">&quot;commit message&quot;</span><br><span class="hljs-comment"># 2. --no-edit # 仅修改上一次提交的文件，不修改提交记录</span><br>git commit --amend --no-edit<br><span class="hljs-comment"># 3. -a # 跳过 git add，添加所有存在跟踪记录的修改文件</span><br>git commit -a -m <span class="hljs-string">&quot;commit message&quot;</span><br><span class="hljs-comment"># 4. -v # 显示修改的文件</span><br>git commit -v -m <span class="hljs-string">&quot;commit message&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>推送至远程仓库</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意！不建议直接在主干分支中进行修改和更新。</span><br><span class="hljs-comment"># 注意！建议在本地创建分支进行修改，并创建远程分支进行提交，修改完成后在主界面上提交merge request，由管理员审核后合并到主干分支</span><br><span class="hljs-comment"># 注意！建议先拉取远程仓库更新，并将更新合并到本地分支后，确定无conflict后再推送</span><br>git push &lt;remote-name&gt; &lt;branch-name&gt;<br></code></pre></td></tr></table></figure></li><li><p>创建&#x2F;切换分支</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.查看远程分支</span><br>git branch -r<br><span class="hljs-comment"># 2.查看本地分支</span><br>git branch -l<br><span class="hljs-comment"># 3.创建分支</span><br>git branch &lt;branch-name&gt;<br>git add .<br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span><br><span class="hljs-comment"># 4.切换分支</span><br>git checkout &lt;branch-name&gt;<br></code></pre></td></tr></table></figure></li><li><p>将远程仓库更新合并到本地分支</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 git fetch 获取远程仓库更新</span><br>git fetch origin &lt;branch-name&gt;<br><span class="hljs-comment"># 比较本地分支与远程分支的差异</span><br>git <span class="hljs-built_in">log</span> -p FETCH_HEAD &lt;branch-name&gt;<br>git diff FETCH_HEAD &lt;branch-name&gt;<br><span class="hljs-comment"># 修改存在差异和冲突的文件</span><br><span class="hljs-comment"># 将远程分支合并到本地分支</span><br>git merge FETCH_HEAD<br><span class="hljs-comment"># 如果存在冲突，解决冲突后，再次提交</span><br>git commit -am <span class="hljs-string">&quot;commit message&quot;</span><br><span class="hljs-comment"># 将本地分支推送至远程分支</span><br>git push origin &lt;branch-name&gt;<br></code></pre></td></tr></table></figure></li><li><p>删除本地已合并分支</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch --merged main | grep -v <span class="hljs-string">&#x27;^[ *]*main$&#x27;</span> | xargs git branch -d<br></code></pre></td></tr></table></figure></li><li><p>删除远程仓库中已不存在的本地分支</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -a<br><span class="hljs-comment"># </span><br>git remote show origin<br><br>git remote prune origin<br><br></code></pre></td></tr></table></figure></li><li><p>http&#x2F;https 免密</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global credential.helper store<br></code></pre></td></tr></table></figure></li><li><p>ssh 免密</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;your_email&quot;</span><br><span class="hljs-comment"># copy id_ras.pub to git</span><br></code></pre></td></tr></table></figure></li><li><p>stash</p></li><li><p>git fsck –full</p></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开启 Cloudflare CDN 代理，实现 IPv4 to IPv6 转换</title>
    <link href="/2023/06/01/%E5%BC%80%E5%90%AF%20Cloudflare%20CDN%20%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%20IPv4%20to%20IPv6%20%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/06/01/%E5%BC%80%E5%90%AF%20Cloudflare%20CDN%20%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%20IPv4%20to%20IPv6%20%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="开启-Cloudflare-CDN-代理，实现-IPv4-to-IPv6-转换"><a href="#开启-Cloudflare-CDN-代理，实现-IPv4-to-IPv6-转换" class="headerlink" title="开启 Cloudflare CDN 代理，实现 IPv4 to IPv6 转换"></a>开启 Cloudflare CDN 代理，实现 IPv4 to IPv6 转换</h1><p>通过公网IPv6地址实现远程访问专栏系列文章：</p><ol><li><a href="https://ccccx159.github.io/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/">《使用公网IPv6远程访问内网设备》</a></li><li><a href="https://ccccx159.github.io/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/">《DDNS动态域名解析IPv6地址》</a></li><li><a href="https://ccccx159.github.io/2023/06/01/%E5%BC%80%E5%90%AF%20Cloudflare%20CDN%20%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%20IPv4%20to%20IPv6%20%E8%BD%AC%E6%8D%A2/">《开启 Cloudflare CDN 代理，实现 IPv4 to IPv6 转换》</a></li></ol><blockquote><p><font color="blue">温馨提示：</font><br>本文存在一部分付费内容，但是付费仅限于域名的购买，如果已经有域名的朋友，请放心大胆食用本文，因为剩余内容均为免费使用。没有域名的朋友，可以移步上一篇文章<a href="https://ccccx159.github.io/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/">《DDNS动态域名解析IPv6地址》</a>，里面详细介绍了如何在腾讯云购买便宜好用的域名。</p></blockquote><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在前两篇文章中，我们详细介绍了如何开启 IPv6 来实现远程访问内网设备，以及如何使用域名和搭建 DDNS 服务实现通过域名来进行远程访问。我们先简单回顾一下，首先需要开启本地网络运营商分发 IPv6 地址的功能，并且开启内网设备的 IPv6 网络权限，因为 IPv6 地址是公网地址，所以此时我们可以直接使用内网设备具体的 IPv6 地址进行直接访问。但是由于IPv6 地址实在是太长了，难以记忆，因此我们通过域名（domain）来绑定 IP 地址，方便记忆。运营商提供的 IP 地址是动态地址，在一定时间后、或者重新拨号联网后会发生变化，针对这一情况，我们在本地搭建了 DDNS 服务，用于监测当前的 IP 地址是否发生变化，如果发生变化，则将新 IP 发送给 DNS 解析服务商，更新域名的 DNS 解析记录。</p><p>但是我们仍然遗留了一个问题，部分网络环境没有 IPv6 解析能力，比如我们公司的网络，在这种情况下，我们无法仅仅使用前两篇文章的内容来进行远程访问了。那么是否有方法能在 IPv4 Only 的环境来访问 IPv6 的站点呢？答案是有的，即<mark>套用 CDN 进行流量回源，简单来说就是在源站和客户端之间建立一个中间服务节点，用来 IPv6 和 IPv4 流量的双向转换</mark>。</p><p>当然答案并不是唯一的，有能力的大神，完全可以自建用于中继转换的服务，但是有免费，简单的轮子，我们当然首选直接拿来用啦。</p><h2 id="二、什么是-CDN"><a href="#二、什么是-CDN" class="headerlink" title="二、什么是 CDN"></a>二、什么是 CDN</h2><p>全称：Content Delivery Network 或 Content Ddistribute Network，即内容分发网络，顾名思义，它是一个分布式节点网络（也称为边缘位置服务器），它有助于根据用户的位置，内容源服务器和边缘服务器向最终用户的地点传送内容（网页、视频、图像等）。CDN节点具有缓存内容的缓存功能，并且可以从地理上靠近最终用户的位置向用户提供内容。CDN节点由CDN提供商部署在多个地理位置，并且可以跨越多个ISP（因特网服务提供商）网络。</p><p>简单来说，它是一个边缘位置服务器，再简单点，它就是一个服务器，用来干什么，用来传递（中转）内容。也就是说我们在访问源站的过程中，实质上是先访问了 CDN 中的边缘服务器，然后由它向源站请求内容后再由它向我们传送了响应内容。</p><p>如果无法理解，那也没关系，看完本文内容，会用即可。</p><h2 id="三、为什么选择-Cloudflare（简称“CF”）"><a href="#三、为什么选择-Cloudflare（简称“CF”）" class="headerlink" title="三、为什么选择 Cloudflare（简称“CF”）"></a>三、为什么选择 Cloudflare（简称“CF”）</h2><p>我们先说一下 Cloudflare 开启 CDN 后最大的缺点：慢！如果使用 Cloudflare 提供的默认边缘节点，有可能会让你的访问速度变得奇慢无比，因为 Cloudflare 的服务器大部分在境外，所以国内访问这些境外的边缘节点的速度你自然懂的。</p><p>但是为什么我们还是选择 Cloudflare 呢？有这几个让人无法拒绝的理由：</p><ol><li>提供了免费的 DNS 解析和 CDN 代理，DNS 支持泛解析；</li><li>CDN 支持 IPv4 和 IPv6 双栈流量的互相转换；</li><li>可以使用第三方开源的 Cloudflare 边缘节点 IP 优选脚本，通过 host 劫持来提高访问速度；</li><li>启用 CDN 后，我们可以隐藏真实 IP 地址，提高个人网络安全；</li><li>国内的 CDN 收费，并且需要绑定实名备案的云服务器，部分 CDN 不支持 IPv6 回源（腾讯云默认 CDN 不支持，需要购买额外的 ECDN 支持 IPv6 的回源）；</li></ol><p>其实仅凭第四点就薄纱国内的 CDN 服务了。CF 速度慢可以通过付费和优选 IP 解决，既然都要付费，那为什么不付给更良心的 CF 呢？</p><h2 id="四、将域名托管至-CF"><a href="#四、将域名托管至-CF" class="headerlink" title="四、将域名托管至 CF"></a>四、将域名托管至 CF</h2><p>前文中，我们在腾讯云购买了域名，并使用 dnspod 进行域名解析。那我们在使用 CF 前，首先要做的就是将域名托管到 CF。CF 使用需要注册账号，这一步就不做过多赘述了，网站支持简体中文，我相信按照说明注册账号应该都能顺利完成。</p><p>在注册完成后，我们点击主页中的“<strong>添加站点</strong>”按钮，导入我们购买的域名：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/483cec301c56b56f697ccb21605e50ce/1685951169889.jpg"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/37a856c85d1a6fe44f380261327cbb6f/1685953812251.jpg"></p><p>这里我们选择免费计划即可，如果有额外需求的，可以按需选择付费计划：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/e64117b1d2645418d6777759462d8143/1685954149112.png"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/b2ca18a9f53b7c773ed56b598e340aed/1685954472920.png"></p><p>完成到这一步时，我们已经完成了托管过程中在 CF 的界面所有操作，接下来我们去腾讯云的控制台，修改域名的名称服务器：</p><p>进入我的域名界面：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/1ffede4f3fc54987e9195931b3ddbca4/1685955178290.png"></p><p>在“修改DNS服务器”界面中，完成名称服务器的修改：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/795c0d5460d21f80df505c4a368f94c7/1685954836479.png"></p><h2 id="四、开启-CDN"><a href="#四、开启-CDN" class="headerlink" title="四、开启 CDN"></a>四、开启 CDN</h2><p>在域名托管的过程中，CF 会自动将原有的域名解析记录导入，我们进入 CF 的域名详情页面，选择左侧的 DNS 选项，打开当前域名的 DNS 解析记录界面：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/d39ea2b19a4fb646e050a8100fec5d31/image.png"></p><p>可以看到我这边已经添加了几条解析记录，下面我们从零开始介绍，如何添加解析记录并开启代理。</p><ol><li><p>手动添加一条 DNS 泛解析记录，并关闭代理：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/7c7b5244b0822b67697fc111b1385e26/image.png"></p></li><li><p>本地尝试 Ping 域名，确认 DNS 解析生效：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/237a1e5abb6c40d63531a4418c43906b/image.png"></p><p>可以看到 CF 的 DNS 解析已经生效了，域名被正确解析到了我们填写的 IP 上。</p></li><li><p>修改 DNS 解析记录，开启 CDN 代理：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/88df5e9aab35e19c32c3ff9ecb895f63/image.png"></p></li><li><p>再次尝试 Ping 域名，观察其返回的 IP 是否已经更新为代理的边缘节点 IP：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/731154f5637920912d564a89d9f572cd/image.png"></p></li><li><p>关闭本地电脑的 IPv6 网络，重新 Ping 域名，观察是否能正常 Ping 通，且返回的 IP 为 IPv4 地址：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/c0f48015f6d7c6824e1af70cfcf1ac56/image.png"></p></li><li><p>修改 OpenWrt 中的 DDNS 信息：</p><p>需要先在 CF 的个人资料中获取一个 API Key，用于更新 DNS 解析记录：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/a53419986eba8d4b3b27de92b501c857/image.png"></p><p>然后再去 OpenWrt 的“动态 DNS”插件中添加&#x2F;修改 DDNS 服务配置信息：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/1a4bb932f2720abbc81a808122e1c664/image.png"></p><p><font color=red>注意：当开启 CDN 代理时，这个插件可能会有 “warn” 级别日志，因为它默认使用了 nslookup 获取域名指向的 IP，在开启代理后 nslookup 获取到的是 CF 边缘节点的 IP 地址，和我们真实的 IP 地址并不相同，并且会获取到多个 IP 导致脚本执行过程中有一步骤 expand_ipv6 会报错。但是这两个问题是没有什么关系的，唯一的影响就是每次检查 IP 的时候，都会强制更新一次 DNS 解析记录，即使真实的 IP 没有发生变化。</font></p></li></ol><p>经过以上6步，我们已经成功给域名套上了 CDN，所有对域名的请求将通过 CF 的边缘节点进行分发和返回，并且我们可以看到，当本地的 IPv6 网络被关闭时，CF 自动给我们分配了 IPv4 的边缘节点，实现了无 IPv6 网络环境下对 IPv6 源站的访问。</p><h2 id="五、Cloudflare-IP-优选"><a href="#五、Cloudflare-IP-优选" class="headerlink" title="五、Cloudflare IP 优选"></a>五、Cloudflare IP 优选</h2><p>在上面开启 CDN 代理的操作步骤中，第2步未开启代理时，单次 ping 的响应时间是15 ms，而第4、5步中 ping 的响应时间则直接上涨到了 200 ms，可见 CF 开启 CDN 代理，对我们访问的速度影响还是比较大的。因此我们需要对 CDN 边缘节点的接入 IP 进行优选。</p><p>此处推荐一个第三方开源的 IP 优选脚本：<a href="https://github.com/XIU2/CloudflareSpeedTest">XIU2&#x2F;CloudflareSpeedTest</a>。详细的使用方法和文档在其 github 主页中都有详细介绍，本文就不再赘述了。</p><h2 id="六、Cloudflare-开启-CDN-后的局限性"><a href="#六、Cloudflare-开启-CDN-后的局限性" class="headerlink" title="六、Cloudflare 开启 CDN 后的局限性"></a>六、Cloudflare 开启 CDN 后的局限性</h2><p>是否只要套用的 CDN，就万事大吉了呢？实则不然，Cloudflare CDN 仅仅能代理 HTTP 和 HTTPS 流量，而我们实际使用过程中，往往还有不同的协议流量，例如 SSH 访问服务器后台（不建议将 SSH 服务暴露到公网）、微软的RDP（mstsc）等，无法通过被代理的域名进行访问。</p><p>解决办法倒也不算麻烦，只要单独为特殊的流量设置独立子域名，并关闭代理即可。比如添加一个用于微软 RDP（mstsc）的子域名解析记录：rdp.yourDomain.com，并指定对应的 IP 地址。同时在添加一个 <code>rdp.yourDomain.com</code> 的 DDNS 服务即可。但是这种方式由于没有 CDN 的代理，也就意味着将直接访问 IPv6 地址，当处于无 IPv6 能力的环境下时，将不可访问。</p><p>当然 Cloudflare 提供了更安全的付费服务 <a href="https://developers.cloudflare.com/spectrum/">Cloudflare Spectrum</a> 来解决这个问题</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/e489644ba5f788f159e905142f4fca6d/image.png"></p><p>对于 HTTP 和 HTTPS 流量的代理，也存在一定的局限性。由于国内无法使用标准的 80 和 443 端口，因此我们不得不使用非标准端口来进行 HTTP(s) 通信。而 Cloudflare 支持转发的端口存在限制，仅支持以下端口的转发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">HTTP  端口：80、8080、8880、2052、2082、2086、2095<br>HTTPS 端口：443、2053、2083、2087、2096、8443<br></code></pre></td></tr></table></figure><p>因此势必需要设置端口转发，将 CF 端口的流量转发到部署的服务指定的端口。</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/242211644d7144a59450b84bdc80a411/image.png"></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>到这里，IPv6 远程访问的系列专题基本告一段落了。我们通过三篇文章，详细地介绍了如何开启 IPv6 网络，如何通过域名进行远程访问，以及如何在无 IPv6 网络环境下通过 CDN 代理访问 IPv6 源站。</p><p>虽然这个专题主要介绍的都是 IPv6，但是 IPv4 网络也同样使用，无非就是域名的 DNS 解析类型从 “AAAA” 转变为 “A” 记录。</p><p>尽管 Cloudflare 免费计划无法做到尽善尽美，但是我们可以略微绕个弯进行规避后，一般的个人家用场景基本足够使用了，更别说还有 Frp，ZeroTier 这些优秀的穿透工具可以辅助使用。对 Frp 和 ZeroTier 感兴趣的朋友，推荐观看司波图的这期视频：<a href="https://www.bilibili.com/video/BV1dr4y147aq/?spm_id_from=333.999.0.0&vd_source=d8c59e2abebb7aaa6127921565c34c80">独享带宽，教你搭建只属于自己的内网穿透服务器（基于frp与zerotier moon服务器）</a></p><p>希望这个专题系列能给有需要的人带去帮助~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://developers.cloudflare.com/dns/">Cloudflare DNS 官方文档</a></li><li><a href="https://developers.cloudflare.com/spectrum/">Cloudflare spectrum 官方文档</a></li><li><a href="https://developers.cloudflare.com/api/">Cloudflare API 官方文档</a></li><li><a href="https://www.v2ex.com/t/870627">《家里只有 IPv6 公网地址，怎么操作才能使其他 IPv4 网络也访问到？》</a></li><li><a href="https://github.com/XIU2/CloudflareSpeedTest">XIU2&#x2F;CloudflareSpeedTest</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>cloudflare</tag>
      
      <tag>CDN</tag>
      
      <tag>IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fail2ban 防止暴力破解密码</title>
    <link href="/2023/05/31/fail2ban%20%E9%98%B2%E6%AD%A2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%AF%86%E7%A0%81/"/>
    <url>/2023/05/31/fail2ban%20%E9%98%B2%E6%AD%A2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="fail2ban-防止暴力破解密码"><a href="#fail2ban-防止暴力破解密码" class="headerlink" title="fail2ban 防止暴力破解密码"></a>fail2ban 防止暴力破解密码</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在五一劳动节期间发现家中搭建的 unRAID 服务器的 CPU 直接被拉满了，怀疑是被暴力破解入侵了，并植入了挖矿程序。经过两天的斗智斗勇，发现在系统盘中被创建了一个名为 wireguard.go 的定时脚本，会定时下载运行 Xmrig 的挖矿程序。。。打死我也没想到伪装名用的是 wireguard。由于部分服务被我暴露到公网上，所以不可避免的会被扫描到，然后被暴力破解了 sshd 的 root 密码，从而导致了以上惨剧。因此设置高位端口和复杂密码的必要性可想而知，一旦自建服务器被黑，如果只是植入挖矿程序，还算良心，万一隐私信息的暴露，或者被勒索，那就杯具了。</p><p>由于端口的有限性，尽管设置了高位端口，但还是有可能会有意者扫描到，因此防止暴力破解也是一个非常关键的安全手段。群晖自带了多次登录失败封禁 ip 的功能，但是 unRAID 本身没有这个功能，我们可以借助安装 fail2ban 这个防入侵软件来保护我们的服务器。</p><h2 id="二、fail2ban-简介"><a href="#二、fail2ban-简介" class="headerlink" title="二、fail2ban 简介"></a>二、fail2ban 简介</h2><p>fail2ban 的官方开源仓库：<a href="https://github.com/fail2ban/fail2ban">https://github.com/fail2ban/fail2ban</a></p><p>这里引用 fail2ban 开源仓库的文档内容：</p><blockquote><p>Fail2Ban 扫描日志文件 <code>/var/log/auth.log</code> 并禁止 IP 地址进行过多失败的登录尝试。它通过更新系统防火墙规则以在可配置的时间内拒绝来自这些 IP 地址的新连接来实现这一点。Fail2Ban 开箱即用，可以读取许多标准日志文件，例如 sshd 和 Apache 的日志文件，并且可以轻松配置为读取您选择的任何日志文件，以获取您希望的任何错误。</p><p>尽管 Fail2Ban 能够降低不正确的身份验证尝试率，但它无法消除弱身份验证带来的风险。如果您真的想保护服务，请将服务设置为仅使用两个因素或公共&#x2F;私人身份验证机制。</p></blockquote><p>简单来说，fail2ban 通过扫描日志文件获取相关错误，并通过改写 iptable 来阻止对应 IP 的连接，支持多种服务的保护。</p><p>fail2ban 提供了 docker 版本，因此安装配置也是相对简单的，下面就简要介绍一下如何在 unRAID 中安装 docker 版本的 fail2ban。</p><h2 id="三、docker-安装"><a href="#三、docker-安装" class="headerlink" title="三、docker 安装"></a>三、docker 安装</h2><p>这里以 unRAID 为例，简单介绍一下安装和配置的过程，由于 unRAID 的 APP 市场中存在现有的 docker 应用，因此我们直接拉取市场应用，并填写相关配置即可。当然你也可以基于其 github 发布的源码或者 release 包自行编写 dockerfile 构建镜像。</p><ol><li>点击 unRAID 的 APP 按钮，进入应用市场，在搜索栏中输入 fail2ban，会出来两个应用，我们选择发布者为 linuxserver 的应用，相对安全。另一个是第三方个人构建的 docker 镜像：<br><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/b997e4a75c8c7a7692f7fcdad88c7f02/1685515906781.jpg"></li><li>点击安装后会跳出一个提示界面，提示当前应用将运行在特权（privilege）模式下，可能存在安全风险。由于 fail2ban 是开源的，因此放心大胆的安装吧<br><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/5e62abe2e324bb0e600864bd51a8476a/1685516101870.png"></li><li>进入后是 docker 的配置界面，其实就是 docker run 的参数，填充完参数后完成创建<br><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/7354da94922920c9ead8d4d012049fc6/1685517579501.png">如果仅仅是为了读取系统的日志，其实我们什么都不需要填写和修改，直接创建即可。但是我们也可以看到，模板中还提供了可选的、其他服务的日志监控路径的挂载配置，上图未截全，如果有对应需求的朋友可以自行配置。</li><li>此时根据<a href="https://github.com/linuxserver/fail2ban-confs/blob/master/README.md">linuxserver的说明文档</a>，还要手动去创建和设置一个配置文件 jail.local，否则重启容器后会丢失配置，而且默认的监控服务是被禁用的，我们直接拷贝 ta 提供的完整配置，然后手动修改其中的部分内容，并保存为 jail.local：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs shell">[DEFAULT]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;bantime.increment&quot;</span> allows to use database <span class="hljs-keyword">for</span> searching of previously banned ip<span class="hljs-string">&#x27;s to increase a</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">default ban time</span></span><br>bantime.increment = true<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;bantime.maxtime&quot; is the max number of seconds using the ban time can reach (doesn&#x27;</span>t grow further)</span><br>bantime.maxtime = 5w<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;bantime.factor&quot;</span> is a coefficient to calculate exponent growing of the formula or common multiplier</span><br>bantime.factor = 24<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;bantime&quot;</span> is the number of seconds that a host is banned.</span><br>bantime = 1h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">A host is banned <span class="hljs-keyword">if</span> it has generated <span class="hljs-string">&quot;maxretry&quot;</span> during the last <span class="hljs-string">&quot;findtime&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">seconds.</span><br>findtime = 24h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;maxretry&quot;</span> is the number of failures before a host get banned.</span><br>maxretry = 5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Prevents banning LAN subnets</span><br>ignoreip    = 127.0.0.1/8 ::1<br>              10.0.0.0/8<br>              172.16.0.0/12<br>              192.168.0.0/16<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The ban action <span class="hljs-string">&quot;iptables-multiport&quot;</span> (default) should work <span class="hljs-keyword">for</span> most</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The ban action <span class="hljs-string">&quot;iptables-allports&quot;</span> can be used <span class="hljs-keyword">if</span> multiport causes issues</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">banaction = %(banaction_allports)s</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Read https://github.com/sebres/PoC/blob/master/FW.IDS-DROP-vs-REJECT/README.md before changing block <span class="hljs-built_in">type</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The block <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;REJECT --reject-with icmp-port-unreachable&quot;</span> (default behavior) should respond to, but <span class="hljs-keyword">then</span> instantly reject connection attempts</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The block <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;DROP&quot;</span> should not respond to connection attempts, resulting <span class="hljs-keyword">in</span> a <span class="hljs-built_in">timeout</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">banaction = iptables-multiport[blocktype=DROP]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Add additional actions</span><br>action  = %(action_)s<br>          apprise-api[host=&quot;127.0.0.1&quot;, tag=&quot;fail2ban&quot;]<br>          cloudflare[cfuser=&quot;YOUR-EMAIL&quot;, cftoken=&quot;YOUR-TOKEN&quot;]<br><br>abuseipdb_apikey = YOUR-API-KEY<br><br>[unraid-sshd]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">configuration inherits from jail.d/unraid-sshd.conf</span><br>enabled = true<br>chain   = INPUT<br>action  = %(known/action)s<br>          abuseipdb[abuseipdb_apikey=&quot;%(abuseipdb_apikey)s&quot;, abuseipdb_category=&quot;18,22&quot;]<br><br>[unraid-webgui]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">configuration inherits from jail.d/unraid-webgui.conf</span><br>enabled = true<br>chain   = INPUT<br>port    = http,https,YOUR-UNRAID-MY-SERVERS-WAN-PORT<br>action  = %(known/action)s<br>          abuseipdb[abuseipdb_apikey=&quot;%(abuseipdb_apikey)s&quot;, abuseipdb_category=&quot;18,21&quot;]<br><br>[unifi-controller-auth]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">configuration inherits from jail.d/unifi-controller-auth.conf</span><br>enabled = true<br>chain   = DOCKER-USER<br>action  = %(known/action)s<br>          abuseipdb[abuseipdb_apikey=&quot;%(abuseipdb_apikey)s&quot;, abuseipdb_category=&quot;18,21&quot;]<br><br>[vaultwarden-auth]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">configuration inherits from jail.d/vaultwarden-auth.conf</span><br>enabled = true<br>chain   = DOCKER-USER<br>action  = %(known/action)s<br>          abuseipdb[abuseipdb_apikey=&quot;%(abuseipdb_apikey)s&quot;, abuseipdb_category=&quot;18,21&quot;]<br><br></code></pre></td></tr></table></figure></li></ol><p>  配置文件中，我们需要手动修改部分内容：</p><ul><li><p>删除第31行行首的 “#” 取消注释，按照其说明，默认的封禁 action 是 iptables-multiport，但是不知道为什么，我这边使用默认的封禁 action 时无法生效，因此我将这行注释取消，使用 iptables-allports 封禁所有端口</p></li><li><p>在 39 ~ 40 行中定义了三种 action，后面两种是推送消息的，如果有需要可以自行配置一下，如果不需要则在第 40 和 41 行的行首分别加上 “#” 即可</p></li><li><p>从 45 行开始，就是各个待监控的服务，每个服务都以 <code>[xxxxxx]</code> 开头，默认配置中添加了 <code>[unifi-controller-auth]</code> 和 <code>[vaultwarden-auth]</code> 的监控，如果不需要可以直接删除，并且默认的监控配置中，action 还额外增加了一条 abuseipdb 的配置，如果没有的，也可以直接将 abuseipdb 这行删除，保留默认的 <code>action = %(known/action)s</code> 即可。</p></li><li><p>如果需要添加其他的服务监控，可以从 docker 本身配置中复制过来，路径为 <code>/mnt/user/appdata/fail2ban/fail2ban/jail.d</code> 下面有各个服务独立的 conf 文件，我们以 gitlab.conf 为例。直接复制粘贴到 jail.local 中即可，将 enable 修改为 true，logpath 中的 &#x2F;gitlab&#x2F;xxxx 修改为 docker 配置界面中的挂载路径即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Version 2022/08/06</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fail2Ban jail configuration <span class="hljs-keyword">for</span> gitlab</span><br><br>[gitlab]<br><br>enabled = false<br>port    = http,https<br>logpath = %(logs_path)s/gitlab/gitlab-rails/application.log<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>将 jail.local 拷贝到 unRAID 的目录中 <code>/mnt/user/appdata/fail2ban/fail2ban/jail.d</code>，重启 docker。</li></ol><h2 id="四、fail2ban-client-命令和效果测试"><a href="#四、fail2ban-client-命令和效果测试" class="headerlink" title="四、fail2ban-client 命令和效果测试"></a>四、fail2ban-client 命令和效果测试</h2><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/1c02f915b01c6f05f89b579cfd94109e/1685520145020.png"></p><p>可以看到在输错几次密码后，ssh 连接直接被拒绝了。我们进 fail2ban 的控制台中看一下封禁状态 <code>fail2ban-client status &lt;服务名称&gt;</code>：</p><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/e6fcd2c4d2085ef6739a64c2331afc1a/1685520332045.png"></p><p>我这边开了7个监控服务，刚才被封禁的是 unraid-sshd，我们在看一下详细的监控服务状态：</p><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/8667dfceba63606dcbd1bb3eea6dfee2/1685520362023.png"></p><p>列出了当前服务失败次数和总次数，以及当前封禁的 ip 数量和总 ip 数量，并列举出了被封禁的详细 ip。<br>我们可以通过 <code>fail2ban-client set &lt;服务名称&gt; unbanip &lt;被封禁的 IP 地址&gt;</code> 来取消封禁：</p><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/b82877dd944756d2e25844094fd5a41a/1685520388282.png"></p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>fail2ban</tag>
      
      <tag>防破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git —— submodule 操作说明</title>
    <link href="/2023/05/19/Git%20%E2%80%94%E2%80%94%20submodule%20%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/"/>
    <url>/2023/05/19/Git%20%E2%80%94%E2%80%94%20submodule%20%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-——-submodule-操作说明"><a href="#Git-——-submodule-操作说明" class="headerlink" title="Git —— submodule 操作说明"></a>Git —— submodule 操作说明</h1><h2 id="1-add-添加子模块"><a href="#1-add-添加子模块" class="headerlink" title="1. add 添加子模块"></a>1. add 添加子模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">git submodule add -b master https://github.com/coolsnowwolf/lede.git ./lede</span><br>git submodule add -b &lt;branch-name]&gt; &lt;git-repository-url&gt; [local-path]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地提交</span><br>git commit -m &quot;add submodule xxxx&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">推送到远程仓库</span><br>git push<br></code></pre></td></tr></table></figure><h2 id="2-checkout-子模块检出"><a href="#2-checkout-子模块检出" class="headerlink" title="2. checkout 子模块检出"></a>2. checkout 子模块检出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">有两种方式：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 使用 --recursive 参数，跟随主仓库递归 <span class="hljs-built_in">clone</span></span><br>git clone &lt;your main repository url&gt; --recursive # 此时 clone 下来的主项目会直接 clone 远程仓库中记录的 commit id 版本的子模块<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 单独 checkout 子模块</span><br>git clone &lt;your main repository url&gt; # 不带 --recursive 递归参数时，submodule 无法被一起 clone 下来<br>git submodule update --init --recursive # 将 submodule 更新到远程仓库中记录的 commit id 版本<br></code></pre></td></tr></table></figure><h2 id="3-update-更新-x2F-切换子模块-commit-id-和当前分支"><a href="#3-update-更新-x2F-切换子模块-commit-id-和当前分支" class="headerlink" title="3. update 更新&#x2F;切换子模块 commit id 和当前分支"></a>3. update 更新&#x2F;切换子模块 commit id 和当前分支</h2><p>这里存在一个较大的坑，默认检出的子模块并不属于任何分支，而是一个 “detached head” ，虽然可以提交更改，但是并没有本地分支跟踪提交的更改，这意味着<font color=red>下次更新子模块会丢失这些更改</font>。</p><p>因此在对子模块进行开发修改前，请先切换其所属分支和对应的 commit id。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">默认添加的 submodule 的 commit <span class="hljs-built_in">id</span> 是 add 时默认分支当前的一个 commit <span class="hljs-built_in">id</span>，当子模块原始仓库更新后，期望切换到指定的 commit <span class="hljs-built_in">id</span> 版本，或者像要切换分支</span><br>git pull<br>git submodule update # 更新本地仓库，避免出现冲突<br>cd &lt;submodule dir&gt;<br>git checkout &lt;branch name&gt; # 切换分支<br>git pull # 拉取新分支源码<br>git checkout &lt;commit id&gt; # 更新子模块版本<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">回到主仓库目录，提交子模块的引用版本修改</span><br>cd ..<br>git add . # 暂存 submodule 的引用版本修改<br>git commit -m &quot;update submodule xxx from xxx to xxx&quot; # 提交<br>git push # 推送到远程仓库<br><br></code></pre></td></tr></table></figure><h2 id="4-commit-提交子模块"><a href="#4-commit-提交子模块" class="headerlink" title="4. commit 提交子模块"></a>4. commit 提交子模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull <br>git submodule update # 确保提交前已将本地仓库更新到远程仓库最新版本，避免提交出现冲突<br>cd &lt;submodulde dir&gt;<br>git add .<br>git commit -am &quot;submodule modify&quot;<br>git push # 将子模块提交的更改推送至远程仓库<br></code></pre></td></tr></table></figure><p>由于子模块和主模块是独立的两个仓库，主模块仅仅应用了子模块的 url 和 commit id。因此当子模块推送更改后，生成新的 commit id，但是主模块对子模块的引用配置并未发生更改，因此需要在主模块中同步进行提交更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ../ # 回到主模块目录<br>git add .<br>git commit -am &quot;submodule reference modify&quot;<br>git push # 推送主模块对子模块的引用记录更改到远程仓库<br></code></pre></td></tr></table></figure><p>可以看到对于子模块的修改，我们需要分别提交和推送子、主模块的更改，当然我们也可以将 “推送至远程仓库” 这一步合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd &lt;main module dir&gt; # 进入主模块目录<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 --recurse-submodules=on-demand 选项，可以在推送主模块更改时，自动推送未推送的子模块</span><br>git push --recurse-submodules=on-demand<br></code></pre></td></tr></table></figure><p>如果出现子模块提交了更改记录，但是未推送到远程仓库，主模块提交了子模块引用记录的变更，并完成了推送到远程仓库的操作。此时拉取主模块没问题，但是在拉取子模块时，会出现 “not our ref” 的报错。这是因为主模块引用了一个远程仓库未记录的 commit id 版本的子模块。需要在提交了变更记录的子模块中完成 push 即可。为了避免<mark>忘记推送子模块修改，仅推送了主模块的引用记录变更</mark>，可以将主模块的推送命令修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 --recurse-submodule=check 选项可以自动检查子模块未 push 的错误</span><br>git push --recurse-submodule=check<br></code></pre></td></tr></table></figure><p>当使用 “–recurse-submodule&#x3D;check” 选项时，如果子模块存在未 push 情况，则当前 push 操作会报警；并且如果子模块存在 push 失败的情况时，也同样会报错。可以直接将其写入 git 配置，减少重复劳动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config push.recurseSubmodules check<br></code></pre></td></tr></table></figure><h2 id="5-modify-修改-submodule-远程仓库-url"><a href="#5-modify-修改-submodule-远程仓库-url" class="headerlink" title="5. modify 修改 submodule 远程仓库 url"></a>5. modify 修改 submodule 远程仓库 url</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd &lt;main module dir&gt; # 进入主模块目录<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改主模块中 .gitmodules 中的 url</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 <span class="hljs-built_in">sync</span> 命令同步修改至 .git/config 中</span><br>git submodule sync<br>git commit -am &quot;modify submodule url&quot; # 提交修改<br>git push # 推送到主模块远程仓库<br></code></pre></td></tr></table></figure><p>如果时别人修改了子模块 url，则拉取主模块的更新后，使用 sync 命令同步到本地 .git&#x2F;config 中即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd &lt;main module dir&gt; # 进入主模块目录<br>git pull # 拉取主模块更新，即获取 .gitmodule 中 url 的修改<br>git submodule sync # 将 .gitmodule 中的修改同步到本地仓库的配置中 .git/config<br></code></pre></td></tr></table></figure><h2 id="6-deinit-移除已有的-submodule"><a href="#6-deinit-移除已有的-submodule" class="headerlink" title="6. deinit 移除已有的 submodule"></a>6. deinit 移除已有的 submodule</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git submodule deinit &lt;submodule name&gt;<br>git rm &lt;submodule dir&gt;<br>git commit -am &quot;remove submodule xxx&quot;<br>git push<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://ldjhust.github.io/2018/08/22/Standard-Operation-of-Git-Submodule.html">《Git - 使用git submodule的规范操作》</a></li><li><a href="https://knightyun.github.io/2021/03/21/git-submodule">《Git submodule 知识总结》</a></li><li><a href="https://juejin.cn/post/6844903920645455879">《来说说坑爹的 git submodule》</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Git</tag>
      
      <tag>submodule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WinRAR去广告</title>
    <link href="/2023/05/18/WinRAR%E5%8E%BB%E5%B9%BF%E5%91%8A/"/>
    <url>/2023/05/18/WinRAR%E5%8E%BB%E5%B9%BF%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="WinRAR-去广告。。。"><a href="#WinRAR-去广告。。。" class="headerlink" title="WinRAR 去广告。。。"></a>WinRAR 去广告。。。</h1><p>搜索引默认提供的 winrar 官网由国内公司代理。。。免费版中的广告就是被这个国内代理商插入的。。。真的就是中国人专坑中国人。。。</p><p>直接去源网站 <a href="https://www.rarlab.com/">https://www.rarlab.com/</a> 下载正式发布的英文版或者繁体中文版，纯净无广告。。。</p><p>无语至极。。。</p><p>不想重新安装的，也可以使用以下方法：</p><ol><li>在 WinRAR 的安装目录下新建一个 txt 文件，并重命名为 “<strong>rarreg.key</strong>“</li><li>用记事本，notepad++等软件打开 “<strong>rarreg.key</strong>“，并粘贴以下内容后保存即可 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">RAR registration data  <br>Federal Agency for Education  <br>1000000 PC usage license  <br>UID=b621cca9a84bc5deffbf  <br>6412612250ffbf533df6db2dfe8ccc3aae5362c06d54762105357d  <br>5e3b1489e751c76bf6e0640001014be50a52303fed29664b074145  <br>7e567d04159ad8defc3fb6edf32831fd1966f72c21c0c53c02fbbb  <br>2f91cfca671d9c482b11b8ac3281cb21378e85606494da349941fa  <br>e9ee328f12dc73e90b6356b921fbfb8522d6562a6a4b97e8ef6c9f  <br>fb866be1e3826b5aa126a4d2bfe9336ad63003fc0e71c307fc2c60  <br>64416495d4c55a0cc82d402110498da970812063934815d81470829275<br></code></pre></td></tr></table></figure></li></ol><p>完成上面两个步骤后，在打开 rar 文件就没有广告弹窗了。</p><p>参考：<a href="https://blog.csdn.net/qq_39313596/article/details/85169627">《WinRAR去除 屏蔽广告弹窗方法》</a></p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>WinRAR</tag>
      
      <tag>去广告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云网盘媒体库海报墙加载卡顿解决办法</title>
    <link href="/2023/05/15/%E9%98%BF%E9%87%8C%E4%BA%91%E7%BD%91%E7%9B%98%E5%AA%92%E4%BD%93%E5%BA%93%E6%B5%B7%E6%8A%A5%E5%A2%99%E5%8A%A0%E8%BD%BD%E5%8D%A1%E9%A1%BF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2023/05/15/%E9%98%BF%E9%87%8C%E4%BA%91%E7%BD%91%E7%9B%98%E5%AA%92%E4%BD%93%E5%BA%93%E6%B5%B7%E6%8A%A5%E5%A2%99%E5%8A%A0%E8%BD%BD%E5%8D%A1%E9%A1%BF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云网盘媒体库海报墙加载卡顿解决办法"><a href="#阿里云网盘媒体库海报墙加载卡顿解决办法" class="headerlink" title="阿里云网盘媒体库海报墙加载卡顿解决办法"></a>阿里云网盘媒体库海报墙加载卡顿解决办法</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>由于阿里云网盘的不限速，以及其支持webdav挂载的优点，很多同学将阿里云盘作为自己的网络媒体库，通过infuse，Emby，plex，fileball等工具进行维护管理实现家庭媒体中心的功能。但是在今年大约4月左右，阿里云官方API对请求的QPS进行了限制，目前最新的QPS限制如下所示：</p><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/13d53b961050c08ea25e237098e189ed/image.png"></p><p>当时几乎所有的第三方阿里云webdav服务都出现了 “to many requests” 的问题，例如 <a href="https://github.com/alist-org/alist">xhofe&#x2F;alist</a> 和 <a href="https://github.com/messense/aliyundrive-webdav">messense&#x2F;aliyundrive-webdav</a> 都有 issue 提到这个问题。虽然各位作者大大都对此进行了适配和优化，但是在挂载后，仍然出现该问题，和媒体海报墙加载极其缓慢和卡顿的问题。</p><h2 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h2><p>出现 “to many requests” 的问题，归根结底还是因为频繁请求导致的。这里以 Emby Server 为例（其余的多媒体管理服务虽然作者本人也有所使用，但 Emby 为主力服务，了解的相对比较详细，因此其余服务再次不作讨论，各位看官可以参考借鉴），在加载海报墙时，Emby 会读取媒体文件的图片和 nfo 文件（ nfo 文件实质上是一个 xml 格式的媒体信息文件，其中包含了刮削后获取的影片详细信息），当进入某个媒体库时，需要预读这个库中所有影片的海报图片和 nfo 文件，可想而知这瞬时的QPS有多大了。</p><p>如果是之前未优化的 webdav 服务，则有可能直接报错然后短时间无法显示，甚至会掉盘，需要重新挂载才能恢复正常。优化后的服务，虽然不会掉盘，但是由于 QPS 的限制，仍然无法像以前一样丝滑的加载海报墙，而且会非常慢，体验十分糟糕。<br><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/c18eebb883199b3f5c964b7868b1f5b1/image.png"></p><h2 id="三、解决思路"><a href="#三、解决思路" class="headerlink" title="三、解决思路"></a>三、解决思路</h2><p>由于 Emby 加载海报墙需要预读图片和 nfo 文件，默认情况下图片和 nfo 文件被保存在媒体文件夹中，即网盘中，那只要将海报和 nfo 文件存储到本地硬盘中不就不需要像阿里云网盘请求就可以加载海报墙并显示影片信息了吗？但是我逛了逛 Emby 的官方论坛，发现官方并没有支持将海报和 nfo 文件存储到独立目录的功能，并且表示没有支持计划。</p><p>但是我在论坛中发现了另一个信息，Emby Server 会在搭建服务的本地维护一个媒体信息的数据库，如果在创建媒体库时，不设置海报和 nfo 文件的读取，就可以将数据存储在本地的数据库中，这样 Emby 在加载海报墙时会直接从本地数据库中获取图片和影片详情，这样就能极大提升海报墙的加载速度了。</p><h2 id="四、操作步骤"><a href="#四、操作步骤" class="headerlink" title="四、操作步骤"></a>四、操作步骤</h2><p>操作非常简单，只需要修改媒体库的设置即可。（作者在这里为了尽可能减少请求数量，将网盘的媒体目录中所有海报和 nfo 文件都删除了，因为列出目录和获取每个文件的下载 url 都会触发 QPS 限制。如果删除海报和 nfo 文件，则需要重新扫库，如果库中影片数量巨大，可能耗时很久）</p><ol><li><p>打开媒体库编辑界面<br> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/0d14378c23268f10ba3bb742eacaf923/image.png"></p></li><li><p>取消勾选下面图示三处选项<br> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/f3f8efe822b0b6df4a3ec324a8234ce4/image.png"></p><p> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/a982f2a6e26c8920bead5f3baaad27d0/image.png"></p><p> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/2d4ffec15e38b1c097ce8d231b520d91/image.png"></p></li><li><p>如果删除了原始的海报文件和 nfo 文件，那么重新执行以下扫描媒体库即可。</p></li></ol><h2 id="四、效果展示"><a href="#四、效果展示" class="headerlink" title="四、效果展示"></a>四、效果展示</h2><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/2d35f4f37e392aaad54bdc480dbabfa2/1.gif"></p><h2 id="五、存在的缺点"><a href="#五、存在的缺点" class="headerlink" title="五、存在的缺点"></a>五、存在的缺点</h2><p>在解决思路一节中提到，这种方法是将海报和媒体详细信息保存在本地数据库中，因此当同一个网盘，在异地搭建媒体服务器时，两地的数据库并不是同一份。再加上 Emby 刮削存在错误的可能性，这就导致同一媒体库多次刮削，对于刮削错误需要多次进行手动修改。</p><p>话虽如此，目前 Emby 自带的刮削器效果比较不错，作者的电影库中影片数量共661部，自动刮削错误数量不到10部，其中部分的错误原因还是因为电影的年份和命名不正确导致，在这样的正确率下，这个缺陷也就无伤大雅了。</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Emby</tag>
      
      <tag>阿里云网盘</tag>
      
      <tag>海报墙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDNS动态域名解析IPv6地址</title>
    <link href="/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="DDNS动态域名解析IPv6地址"><a href="#DDNS动态域名解析IPv6地址" class="headerlink" title="DDNS动态域名解析IPv6地址"></a>DDNS动态域名解析IPv6地址</h1><p>通过公网IPv6地址实现远程访问专栏系列文章：</p><ol><li><a href="https://ccccx159.github.io/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/">《使用公网IPv6远程访问内网设备》</a></li><li><a href="https://ccccx159.github.io/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/">《DDNS动态域名解析IPv6地址》</a></li></ol><blockquote><p><font color=red>付费提示！</font></p><p>由于本文教程中需要使用域名和域名解析服务，因此存在付费内容。域名可自行在阿里云、腾讯云、华为云等云服务提供商进行购买，域名解析服务则可以自行选择使用云服务提供商所提供的免费解析服务，也可以将域名托管至第三方服务提供商，例如大名鼎鼎的Cloudflare。<br>根据不同的顶级域名，域名价格从几块钱到上百元不等，可自行选择。</p></blockquote><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在上一篇文章《使用公网IPv6远程访问内网设备》的文末，我们提到了使用IPv6地址进行远程访问几个缺陷：</p><ol><li>IPv6 地址很长，不方便记忆；</li><li>公网 IPv6 地址并非固定不变，在一定情况下，地址发生变更，如果不能及时获取地址，则无法进行远程访问</li><li>部分网络无IPv6的Internet访问权限，比如公司内网等，则无法访问任何IPv6地址</li></ol><p>这三个缺陷，从解决方案的角度来看，我们可以将其分为两类，缺陷1、2分为一类，缺陷3分为第二类。本文我们就来详细介绍一下，如何解决第一类问题，IPv6地址难以记忆且不定时更新。</p><h2 id="二、方案简介"><a href="#二、方案简介" class="headerlink" title="二、方案简介"></a>二、方案简介</h2><p>折腾过IPv4的朋友应该也遇到过这类问题，虽然IPv4地址相对简短，更好记忆，但是一串毫无意义的数字，总归还是难以记忆。解决方案的思路和IPv4相同，都是通过申请域名和设置域名的DNS解析服务，将简单好记的域名绑定到自己的公网IP上，后续可直接通过域名进行访问无需再记忆IP地址，仅需记住自定义的域名即可。域名有多方便记忆应该所有人都有所体会，例如百度（baidu.com）、淘宝（taobao.com）等。</p><p>对于IP不断更新变化的问题，不论是IPv4还是IPv6都存在，解决思路并不复杂，简单来说，我们在本地定时获取光猫或者路由器通过拨号获取的IP地址，即WAN口地址，并与上一次获取记录进行比较判断，如果IP发生变化，则通知用户重新设置DNS解析，或者通过DNS服务的API接口，自动进行设置。自动设置的过程实际上就是文章的标题，DDNS解析IP地址。</p><p>我们来看一下 Wiki 对 DDNS 的解释：</p><blockquote><p><strong>动态DNS</strong>（英语：<strong>Dynamic DNS</strong>，简称<strong>DDNS</strong>）是<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F" title="域名系统">域名系统</a>（DNS）中的一种自动更新<a href="https://zh.wikipedia.org/wiki/%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8" title="名称服务器">名称服务器</a>（Name server）内容的技术。根据互联网的域名订立规则，域名必须跟从固定的IP地址。但动态DNS系统为动态网域提供一个固定的<a href="https://zh.wikipedia.org/wiki/%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8" title="名称服务器">名称服务器</a>（Name server），透过即时更新，使外界用户能够连上动态用户的网址。</p><p>这个术语被用来描述两种不同的概念。在<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF" title="互联网">互联网</a>的管理层面来说，动态DNS更新是指创建一个DNS系统，能够自动更新传统的DNS记录，而不需要手动编辑。这个机制在RFC 2136中被解释，利用<a href="https://zh.wikipedia.org/w/index.php?title=TSIG&action=edit&redlink=1">TSIG</a>机制来提供安全性。————<a href="https://zh.wikipedia.org/wiki/%E5%8B%95%E6%85%8BDNS">Wiki百科</a></p></blockquote><p>OK，话不多说，下面开始逐步进行详细的说明和介绍</p><h2 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h2><p>因为作者本人使用的是腾讯云，所以接下来的教程中，将全部按照腾讯云进行示范，对于其他的域名提供商，整理流程大同小异，也可参考本文进行。</p><h3 id="3-1、申请域名"><a href="#3-1、申请域名" class="headerlink" title="3.1、申请域名"></a>3.1、申请域名</h3><p><img src="https://user-images.githubusercontent.com/35327600/232372209-761d3447-0d43-4926-9907-3a67bc25f335.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/232372574-c1d44454-8c73-43cd-a933-02a06ce622a5.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/232373399-7af123a7-c0e5-41ce-b141-546a67952705.png"></p><p>这里我们选择了 “.top” 这个顶级域名，并二级域名自定义输入了 “ipv6test”，那么最终我们所申请的域名就是 “ipv6test.top”。</p><blockquote><p>什么是 “<strong>顶级域名</strong>“ 和 “<strong>二级域名</strong>“ 请自行百度或者Google搜索，这里不展开赘述了。</p></blockquote><p><img src="https://user-images.githubusercontent.com/35327600/232375887-3b3156b7-4e98-43cc-8490-883d84c24b50.png"></p><p>域名购买的过程中有坑点，需要单独注意下，上图中已经标明了，这里再简单说明一下：</p><ol><li>将域名添加到购物车之后，会弹出 “DNS解析（专业版）” 和 “SSL证书” 这两个购买项， 我们确实需要使用 DNS 解析服务，但是免费版本已经足够使用，无需再单独购买专业版；而 “SSL证书” 我们可以从第三方进行免费申请，根本不需要这个</li><li>点击查询后展示的域名价格是 “<strong>首年价格</strong>“，折扣力度比较大，<font color=red>但是！！！后续每年的续费价格则会恢复原价，导致续费价格会比首年价格贵好几倍！！！</font>如果不想每年重新购买域名，那么最好直接买一个续费价格也相对比便宜的域名。（富哥们不需要在意这个）</li></ol><p>现在购买域名需要实名审核，在结算界面会需要创建一个个人信息模板，按要求填写后，购买成功即可。作者之前已经注册了域名，因此这里不再重复注册了。</p><h3 id="3-2、添加DNS解析记录"><a href="#3-2、添加DNS解析记录" class="headerlink" title="3.2、添加DNS解析记录"></a>3.2、添加DNS解析记录</h3><p>完成域名注册后，和上面的第一步一样，通过云产品中的域名注册，回到我的域名界面，原本的空列表中会显示你刚刚注册的域名，刚刚注册完成的，可能服务状态会显示 “实名认证审核中”，这个审核时长不定。如果实名信息是之前已经认证过的，很快就能通过审核，最终如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/232395377-c1d40738-34e2-4f8f-b4ed-3752f7a4296a.png"></p><p>当服务状态显示为正常时，我们点击后边的解析按钮，进行 DNS 解析记录设置。</p><p><img src="https://user-images.githubusercontent.com/35327600/232397281-5251e681-1ea7-4c7e-924c-b047a95dbc8d.png"></p><p>在点击”添加记录”按钮之后，出现一条空白的解析记录，一共有5项待填充内容，分别是：</p><ol><li>主机记录</li><li>记录类型</li><li>线路类型</li><li>记录值</li><li>TTL<br>一般来说，我们只需要填写其中的主机记录、记录类型和记录值三项就行，线路类型和TTL保持默认即可。</li></ol><h4 id="3-2-1、主机记录"><a href="#3-2-1、主机记录" class="headerlink" title="3.2.1、主机记录"></a>3.2.1、主机记录</h4><p>鼠标点击对应的填充框，下面都会有对应提示，先来看看主机记录：</p><p><img src="https://user-images.githubusercontent.com/35327600/232398413-3a50dc48-9c73-4e6d-8e23-63100544888e.png"></p><p>用通俗的语言来说，主机记录就是域名的前缀，通常指三级及以上的域名（腾讯云的提示中描述的时二级域名，这个描述和计算机网络中的标准定义有差异，本文将按照标准定义进行描述），比如作者申请注册的域名为 “testdomaim.xyz”，我想添加一条解析记录到 “ipv6.testdomain.xyz”，那么主机记录这里就需要填写 “ipv6”；要是还想添加一个域名叫 “ipv4.testdomain.xyz”，那么主机记录就填 “ipv4”。因为我们注册申请了一个二级域名，那么这个二级域名之上的三级域名，四级域名都可以自行设置分配。</p><p>主机记录中有两个特殊的值：”@” 和 “*“。”@” 用于直接解析我们申请的二级域名，也就是 “testdomain.xyz”，当你直接访问这个域名时，DNS服务器将会查询主机记录为 “@” 的解析记录。”*“ 则用于泛解析，故名思意，解析泛域名，意味着所有的三级域名都将通过这条解析记录进行查询。当设置了 “*“ 泛解析后，再单独设置某个三级域名解析记录，将会出现访问错误的情况。</p><h4 id="3-2-2、记录类型"><a href="#3-2-2、记录类型" class="headerlink" title="3.2.2、记录类型"></a>3.2.2、记录类型</h4><p><img src="https://user-images.githubusercontent.com/35327600/232398661-5b8504fa-f4d5-4f56-a63b-30b7e3380739.png"></p><p>记录类型只能点击下方提示的条目进行自动填充，由于我们这次需要指定的 IP 地址为 IPv6 类型，因此这里我们选择 “AAAA” 记录类型。</p><h4 id="3-2-3、记录值"><a href="#3-2-3、记录值" class="headerlink" title="3.2.3、记录值"></a>3.2.3、记录值</h4><p><img src="https://user-images.githubusercontent.com/35327600/232398697-486d6c8f-6209-4b09-98e8-9a5ba93cba68.png"></p><p>简单来说，待访问的终端 IP 地址。通过上一步的教程，我们将电脑的 IPv6 地址填入即可（请先确认地址有效，通过 mstsc 直接填入 IPv6 地址进行连接测试）。</p><p>完成以上三项内容填写后，点击保存，我们就完成了 “ipv6.testdomain.xyz” 这个域名到我们电脑的 IPv6 地址解析记录添加。如下图所示：<br><img src="https://user-images.githubusercontent.com/35327600/232403948-a30edf1b-bb73-4555-9059-dcda07ba3430.png"></p><p>打开CMD，进行 ping 连接测试 <code>ping -6 ipv6.testdomain.xyz</code>：<br><img src="https://user-images.githubusercontent.com/35327600/232404597-67f21713-5820-45fb-b232-ec8e0b21593e.png"></p><p>显示正常 ping 通，说明解析服务已经正常生效了。然后我们再使用 mstsc 进行远程方式试试：<br><img src="https://user-images.githubusercontent.com/35327600/232405249-d864a176-6e29-4d03-a9fa-f8d713524e2d.png"></p><p>也能正常进行远程连接了。至此我们已经完成了通过域名解析到IPv6地址，并进行远程访问的所有设置。接下来我们进行 DDNS 动态域名解析的相关设置。</p><h3 id="3-3、DDNS设置"><a href="#3-3、DDNS设置" class="headerlink" title="3.3、DDNS设置"></a>3.3、DDNS设置</h3><p>由于我的路由器 openwrt 固件中自带 DDNS 插件，因此下文将以路由器中的插件 “动态 DNS” 进行配置说明。</p><blockquote><p>这里推荐一个多平台（win、linux、macos等）可用，且支持docker运行的开源 DDNS 服务：”<a href="https://github.com/jeessy2/ddns-go">ddns-go</a>“，可以直接前往 github 仓库查看其使用说明。整体使用和下文配置大同小异，可相互参考借鉴。</p></blockquote><p>openwrt 中的 “动态 DNS” 界面如下：<br><img src="https://user-images.githubusercontent.com/35327600/232416946-0c5db466-f400-42de-9668-da6ecc806b1b.png"></p><p>可以看到我已经添加了一条配置，下面我们将详细介绍如何通过 “动态 DNS” 插件完成对腾讯云域名的动态解析设置。</p><p><img src="https://user-images.githubusercontent.com/35327600/232418446-39dda62d-3a00-4457-8281-4b3e4442b537.png"></p><p>点击添加按钮后，进入详细配置：</p><p><img src="https://user-images.githubusercontent.com/35327600/232418767-a9c47b89-b09a-4614-821d-b174f86ab446.png"></p><p>由于不同 DNS 服务提供商所需要填充的设置也不同，因此进入以后我们先选择 “DDNS 服务提供商”，由于我们是通过腾讯云注册的，腾讯云提供的默认服务商为 DNSPOD，因此这里我们选择 “dnspod.cn”:</p><p><img src="https://user-images.githubusercontent.com/35327600/232419295-ace51558-691f-49cc-ad44-df5f2f30c22f.png"></p><p>点击更改提供者之后，就能看到详细的配置项了：</p><p><img src="https://user-images.githubusercontent.com/35327600/232421210-57247aea-d68d-4bca-8e6e-d83d8aea852d.png"></p><p>其中 dsnpod 的用户 id 和 token，可前往 <a href="https://console.dnspod.cn/account/token/token">DNSPOD 控制台</a>进行创建。</p><p><img src="https://user-images.githubusercontent.com/35327600/232422150-426adcc2-6627-49ac-836f-288e891964f6.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/232422444-c358c376-7cf3-4a11-b051-436e3d91ee6f.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/232422934-e4179e8e-cb08-4fb2-aed1-a8a9ac49fd4a.png"></p><p>将此处获取的 id 和 token 填入到插件配置中，填充完成后点击右下角 “保存&amp;应用” 完成配置创建。然后点击下图中的启动按钮，即可启动 DDNS 服务：</p><p><img src="https://user-images.githubusercontent.com/35327600/232423971-36958701-6405-4201-97b1-c1a398a9aa66.png"></p><p>我们在点击修改按钮进入配置界面，点击上方的”日志查看器”，点击”读取&#x2F;重新读取日志文件”，查看下方日志内容：<br><img src="https://user-images.githubusercontent.com/35327600/232425360-7d05ca20-83c8-43ca-aa0a-89a05e08eebe.png"><br><img src="https://user-images.githubusercontent.com/35327600/232426260-766bf78b-70f0-45da-843b-3d2166db963a.png"></p><p>可以看到服务已经可以正常查询指定域名的 DNS 解析记录和本地 IPv6 地址。若日志中出现了 “warning “ 和 “error” 等级的日志内容，则说明有配置不正确，需要根据日志提示进行排查和修改。</p><p>DDNS 服务会每隔几分钟轮询 DNS 解析记录和本地 IP，如果本地 IP 发生变更，则会调用 DNSPod 的 API 接口，将新的 IP 地址注册到 DNSPod 中，修改对应域名的解析记录，完美解决了 IP 地址不定时更新的问题。</p><h3 id="3-4、端口转发"><a href="#3-4、端口转发" class="headerlink" title="3.4、端口转发"></a>3.4、端口转发</h3><p><font color=red>注意！！！</font><br><font color=red>如果 DDNS 服务直接运行在期望访问的远程主机上，则不需要进行此章节的设置！</font></p><p>本来配置 DDNS 解析本地 IPv6 地址的过程在上一章节就完全结束了，但是由于作者是通过路由器获取的 IPv6 地址，直接访问域名的话，实际上访问的是路由器。因此如果需要远程访问路由器下的某台电脑，则还需要在路由器的防火墙中，设置端口转发，将流量转发到指定的子网设备中。</p><p>openwrt 防火墙的端口转发仅支持 IPv4 to IPv4。我们现在需要进行 IPv6 向 IPv4 进行转发，因此还需借助另一个插件 “Socat”，来完成 IPv6 流量向 IPv4 地址的转发。</p><p>点击插件界面的 “添加” 按钮，按下图所示完成配置后，点击 “保存&amp;应用”，即可完成最后的端口转发设置。</p><p><img src="https://user-images.githubusercontent.com/35327600/232432133-eeadc95b-5d55-4ddb-afd8-8e5de8998c3c.png"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>在本文中，我们注册申请了一个二级域名，并通过设置域名的 DNS 解析记录，使得可以通过域名来对内网下的windows主机进行远程访问。完全自定义的二级和三级域名，可以是具备标识意义的名称，完美解决了 IP 地址难以记忆的问题。</p><p>我们又通过 DDNS 服务插件完成了当 IP 地址变更时，自动更新对应域名的 DNS 解析记录，确保 IP 变更时，域名仍然能正确指向我们的终端设备。</p><p>通过<a href="https://blog.csdn.net/qq_38894585/article/details/129664331">《使用公网IPv6远程访问内网设备》</a>和本文的所有配置，一般家用场景下已经能完美通过公网 IPv6 地址进行远程访问内网设备了。当然还有进阶的玩法，比如通过 DNSPod 提供的泛解析和路由器的端口转发，我们可以用不同的三级域名来访问家中的不同服务，再加上 Nginx 反向代理，实现全服务的 https 访问。</p><p>后续有时间，也许会补上 DDNS 泛解析和 Nginx 反向代理，实现内网服务的 https 外网访问。</p><p>当前专题系列还有一个问题尚未解决，要能够解析 IPv6 的域名，则当前网路需要能访问 IPv6 网络，但是部分网络环境下，这是个不可解决的难题，比如公司内网为了网络安全，往往会关闭 IPv6 网络，此时即使我们有正确的域名和解析记录，我们也无法完成远程访问。</p><p>限于篇幅原因，我们将在下一篇文章中来解决这一难题，敬请期待~</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>IPv6</tag>
      
      <tag>DDNS</tag>
      
      <tag>Domain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用公网IPv6远程访问内网设备</title>
    <link href="/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="使用公网IPv6远程访问内网设备"><a href="#使用公网IPv6远程访问内网设备" class="headerlink" title="使用公网IPv6远程访问内网设备"></a>使用公网IPv6远程访问内网设备</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>IPv4公网IP一号难求的环境下，如何优雅的使用公网IPv6进行远程访问？本文将以中国移动的宽带和光猫为例，进行IPv6的设置说明，并实现通过IPv6地址和Windows系统自带的远程工具”mstsc”，远程访问内网的Windows主机。</p><p>可能部分宽带安装师傅默认没有打开 IPv6 的功能，因此我们先登录光猫的后台确认光猫是否开启了 IPv6。由于电信的宽带服务相对比较容易获取到公网IPv4地址，因此这里以移动宽带举例，其他宽带运营商提供的光猫可能有所差异，但是功能大同小异，请自行搜索相应操作细节。</p><h2 id="二、确认IPv6连接状态"><a href="#二、确认IPv6连接状态" class="headerlink" title="二、确认IPv6连接状态"></a>二、确认IPv6连接状态</h2><p>如果宽带是由光猫拨号连接的，在浏览器中输入光猫的后台地址，例如 <code>192.168.1.1</code>，移动光猫的后台界面如下图所示。一般来说，移动光猫的管理员账号和密码是相同的，曾经在同一省份的不同城市都办理过移动宽带，光猫后台的账号密码都如图中所示 <code>账号：CMCCAdmin  密码：aDm8H%MdA</code> 。不确定不同省份是否有所差异，如果这个账号密码不可用，请自行搜索或者向宽带运营商索取。</p><p><img src="https://user-images.githubusercontent.com/35327600/223893633-286b2a64-fbe5-4f88-b4b1-ed7ea31af0d4.png"></p><p>点击确定后，进入后台界面，按下图中所标识的按钮和顺序，依次点击，可以在当前界面查看到 IPv6 的连接信息。</p><p><img src="https://user-images.githubusercontent.com/35327600/223897533-878fed3e-07c9-4912-8679-dc645432fefb.png"></p><p>如果确定 IPv6 已正确连接，在上图界面中，可以拉动横向的滚动条，查看当前的 IPv6 地址。</p><p><img src="https://user-images.githubusercontent.com/35327600/226225202-a8abe3c7-357b-4a32-83b4-2e618983d270.png"></p><p>如果上述界面中显示IPv6未连接，请根据以下界面检查运营商是否给当前宽带套餐开通IPv6功能。</p><p><img src="https://user-images.githubusercontent.com/35327600/226227385-07eb44f5-9836-47d3-89ef-7237f855b369.png"></p><h2 id="三、打开并查看远程主机IPv6地址"><a href="#三、打开并查看远程主机IPv6地址" class="headerlink" title="三、打开并查看远程主机IPv6地址"></a>三、打开并查看远程主机IPv6地址</h2><p>这里以win10系统为例，可能部分人的PC默认没有开启IPv6，按照以下步骤打开IPv6，并获取IPv6地址。</p><ol><li>按下 “windows徽标” + “R”，打开运行窗口，输入 “ncpa.cpl” 后回车，打开网络适配器管理界面<br> <img src="https://user-images.githubusercontent.com/35327600/226231169-7eb0ce41-e3b9-429b-b9b2-06306351b0a5.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226231296-153119ad-ce30-4477-ac49-2e53a3a88316.png"></li><li>双击以太网连接，查看当前以太网状态，若IPv6连接显示无网络连接，则按以下图片内说明打开IPv6连接<br> <img src="https://user-images.githubusercontent.com/35327600/226232249-91264fa3-74f0-44d1-891b-64f0ba50561c.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226233016-617c197b-32e8-4d0e-bbdf-d36cac0deb69.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226234598-aa6dba1e-1b3c-4928-a1ea-5ae0794f61f0.png"></li></ol><h2 id="四、打开本地PC的IPv6连接"><a href="#四、打开本地PC的IPv6连接" class="headerlink" title="四、打开本地PC的IPv6连接"></a>四、打开本地PC的IPv6连接</h2><p>由于需要使用IPv6进行远程连接，需要确保本地 PC 和远程 PC 同时具备 IPv6 的连接能力，因此对于本地PC，也需要按照上述<strong>第2步</strong>进行确认。</p><blockquote><p>远程PC和本地PC可使用浏览器访问<a href="http://ipv6.test-ipv6.com/">IPv6测试网站</a>进行连接测试。</p></blockquote><p>完成两端的 IPv6 连接设置后，可以直接使用 IPv6 地址尝试远程连接，不出意外，此时已经可以成功进行远程访问了。</p><ul><li>按下 “windows 徽标” + “R”，打开运行界面，输入 “mstsc”，回车，打开远程连接界面，填入第二步中获取的”<strong>远程 PC 的 IPv6 地址</strong>“，点击连接。正常情况下，此时会弹出要求输入用户名和密码。<br>  <img src="https://user-images.githubusercontent.com/35327600/226236201-a851eec6-c3a7-40dd-b6f0-70f4e48889c2.png"></li></ul><h2 id="五、遇到的坑"><a href="#五、遇到的坑" class="headerlink" title="五、遇到的坑"></a>五、遇到的坑</h2><p>整个过程可能会存在两个坑，导致无法连接：</p><ol><li>光猫默认使能IPv6防火墙的控制转发报文功能（作者的移动光猫中是这么描述的），导致所有的IPv6数据包被拦截，从而无法建立远程连接，甚至无法 ping 通。需要将该功能关闭，才能正常使用IPv6。<br> <img src="https://user-images.githubusercontent.com/35327600/226237991-c5b5cadb-0837-40c6-aa1d-48d968927ce3.png"></li><li>远程PC未打开远程访问功能。win10家庭版不支持远程桌面，专业版则默认关闭了远程桌面，因此需要手动打开和确认。<br> <img src="https://user-images.githubusercontent.com/35327600/226238918-83374ecb-6640-4c8e-87bd-2153e81124ac.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226239110-a296c35e-5546-4a3d-b5cb-913901ac9121.png"></li><li>部分网络默认不开启IPv6，例如公司内部网络等，因此远程PC虽然开启了IPv6，但仍然无法通过IPv6进行远程连接；</li></ol><h2 id="六、存在的缺陷"><a href="#六、存在的缺陷" class="headerlink" title="六、存在的缺陷"></a>六、存在的缺陷</h2><p>按步骤完成上述操作后，一般来说，已经能成功使用IPv6地址进行远程访问。但是使用起来仍然存在2个比较致命的问题：</p><ol><li>IPv6 地址很长，不方便记忆；</li><li>公网 IPv6 地址并非固定不变，在一定情况下，地址发生变更，如果不能及时获取地址，则无法进行远程访问</li><li>部分网络无IPv6的Internet访问权限，比如公司内网等，则无法访问任何IPv6地址</li></ol><p>针对第一个缺陷，由于域名可以自定义申请，并且方便记忆，因此我们可以申请一个域名（例如 baidu.com、google.com），并将域名解析到对应IP地址（DNS服务商提供解析服务），通过域名来进行访问。</p><p>而第二个缺陷，在域名的基础上，我们还需要定期将当前的IP地址，同步给DNS服务商，修改域名解析的目标IP，确保域名能正确解析到我们自己的设备上。</p><p>第三个缺陷，我们则需要借助域名解析服务商提供的CDN功能进行IPv4访问，IPv6回源，同时国内的CDN服务都需要域名在工信部备案（这里点个名，由于作者域名在鹅厂购买的，本来考虑直接使用它的ECDN，结果个人域名备案需要绑定国内云服务器实例….其他云服务商不确定是否也具有同样的骚操作），不得不考虑国外的CDN服务，例如大名鼎鼎的 Cloudflare。</p><p>由于文章篇幅较长，因此将在专栏后续文章中进行详细说明介绍~</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>IPv6</tag>
      
      <tag>mstsc</tag>
      
      <tag>网络运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于DSM7.1，通过nginx反代破解Emby Server Premiere</title>
    <link href="/2023/03/13/%E5%9F%BA%E4%BA%8EDSM7-1%EF%BC%8C%E9%80%9A%E8%BF%87nginx%E5%8F%8D%E4%BB%A3%E7%A0%B4%E8%A7%A3Emby-Server-Premiere/"/>
    <url>/2023/03/13/%E5%9F%BA%E4%BA%8EDSM7-1%EF%BC%8C%E9%80%9A%E8%BF%87nginx%E5%8F%8D%E4%BB%A3%E7%A0%B4%E8%A7%A3Emby-Server-Premiere/</url>
    
    <content type="html"><![CDATA[<h1 id="基于DSM7-1，通过nginx反代破解Emby-Server-Premiere"><a href="#基于DSM7-1，通过nginx反代破解Emby-Server-Premiere" class="headerlink" title="基于DSM7.1，通过nginx反代破解Emby Server Premiere"></a>基于DSM7.1，通过nginx反代破解Emby Server Premiere</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><strong><font color="red">！！！破解教程仅供学习参考，务必支持正版软件，构建良好的软件版权生态！！！</font></strong></p><p>Emby Server是一个开源的流媒体中心软件，可以非常方便的管理和维护电影，电视剧集等媒体库，并生成强大美观的海报墙。并且全平台的客户端，使其跨设备观看变得非常便利。但是服务端的部分插件功能，以及视频转码功能，需要会员才能解锁。针对尝鲜的个人用户来说，这个会员着实不便宜，经过搜寻相关资料后，确定其会员验证是通过与<code>mb3admin.com</code>这个网站通信完成，因此本教程将通过nginx的反向代理+hosts进行域名劫持来实现会员的”破解”。</p><h2 id="二、准备工具"><a href="#二、准备工具" class="headerlink" title="二、准备工具"></a>二、准备工具</h2><ul><li>DMS7.1群晖系统（本质上任意一个nginx服务都可以，DSM本身的web就是通过nginx实现的，因此不需要单独在开一个nginx服务了）</li><li>文本编辑软件（Notepad++，subline text，vs code均可）</li><li>ssh工具（Xshell，MobaXterm，putty，finalshell等）</li></ul><h2 id="三、破解步骤"><a href="#三、破解步骤" class="headerlink" title="三、破解步骤"></a>三、破解步骤</h2><h3 id="1、申请ssl证书"><a href="#1、申请ssl证书" class="headerlink" title="1、申请ssl证书"></a>1、申请ssl证书</h3><p>由于Emby Server需要和<code>mb3admin.com</code>进行https通信，因此我们需要针对该域名申请ssl证书。</p><p>推荐 GMCert.org <a href="https://www.gmcert.org/subForm%E3%80%82%E6%8C%89%E4%BB%A5%E4%B8%8B%E7%94%B3%E8%AF%B7%E6%AD%A5%E9%AA%A4%E8%BF%9B%E8%A1%8C%EF%BC%9A">https://www.gmcert.org/subForm。按以下申请步骤进行：</a></p><p><img src="https://user-images.githubusercontent.com/35327600/201810752-d921d035-c76d-439c-9160-e320a36af37d.jpg"></p><ul><li>CA证书如果此前PC端已安装过，则可不用重复下载安装；如果是全新安装，则尽量安装一下，双击证书，点击安装，然后手动选择证书存储，将证书安装到“受信任的根证书颁发机构”即可。</li><li>主题名称为此次所需的二级域名<code>mb3admin.com</code></li></ul><p>点开下方的“<strong>高级选项</strong>”，并按照以下进行配置：</p><p><img src="https://user-images.githubusercontent.com/35327600/201813309-cc83b055-df1d-4b61-bda9-103939c7cc2c.png"></p><ul><li>在主题备用名称中，填入上图内容，将泛域名也填充进去，保证任意三级域名都处于ssl证书授权范围</li><li>密钥用途和扩展密钥用途按图中红框勾选即可</li><li>点击“<strong>签发证书</strong>”，会下载一个包含密钥和证书的压缩包，解压并保存</li></ul><h3 id="2、上传密钥和证书"><a href="#2、上传密钥和证书" class="headerlink" title="2、上传密钥和证书"></a>2、上传密钥和证书</h3><p>将上一步中解压获取的证书和密钥文件，上传至群晖中</p><p><img src="https://user-images.githubusercontent.com/35327600/201814624-8bc428eb-1947-430f-a27a-2301ce7379d8.png"></p><h3 id="3、创建nginx代理配置"><a href="#3、创建nginx代理配置" class="headerlink" title="3、创建nginx代理配置"></a>3、创建nginx代理配置</h3><p>新建文件<code>emby_crack_nginx.conf</code>，粘贴以下内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>     <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>     <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">443</span> ssl;<br>     <span class="hljs-attribute">server_name</span> mb3admin.com;<br>     <span class="hljs-attribute">ssl_certificate</span> /volume1/web/mb3admin.com/mb3admin.com.cert.pem;<br>     <span class="hljs-attribute">ssl_certificate_key</span> /volume1/web/mb3admin.com/mb3admin.com.key.pem;<br>     <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;<br>     <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>     <span class="hljs-attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<br>     <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br>     <span class="hljs-section">location</span> = /webdefault/images/logo.jpg &#123;<br>     <span class="hljs-attribute">alias</span> /usr/syno/share/nginx/logo.jpg;<br>            &#125;<br>     <span class="hljs-section">location</span> <span class="hljs-variable">@error_page</span> &#123;<br>     <span class="hljs-attribute">root</span> /usr/syno/share/nginx;<br>     <span class="hljs-attribute">rewrite</span> (.*) /<span class="hljs-literal">error</span>.html <span class="hljs-literal">break</span>;<br>            &#125;<br>     <span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /.well-known/acme-challenge &#123;<br>     <span class="hljs-attribute">root</span> /var/lib/letsencrypt;<br>     <span class="hljs-attribute">default_type</span> text/plain;<br>            &#125;<br>     <span class="hljs-section">location</span> / &#123;<br>     <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^</span> / <span class="hljs-literal">redirect</span>;<br>            &#125;<br>     <span class="hljs-section">location</span> <span class="hljs-regexp">~ ^/$</span> &#123;<br>     <span class="hljs-attribute">rewrite</span> / https://<span class="hljs-variable">$host</span>:5001/ <span class="hljs-literal">redirect</span>;<br>            &#125;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin *;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers *;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Method *;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;<br>     <span class="hljs-section">location</span> /admin/service/registration/validateDevice &#123;<br>     <span class="hljs-attribute">default_type</span> application/json;<br>     <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&#123;&quot;cacheExpirationDays&quot;: 365,&quot;message&quot;: &quot;Device Valid&quot;,&quot;resultCode&quot;: &quot;GOOD&quot;&#125;&#x27;</span>;<br>    &#125;<br>     <span class="hljs-section">location</span> /admin/service/registration/validate &#123;<br>     <span class="hljs-attribute">default_type</span> application/json;<br>     <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&#123;&quot;featId&quot;:&quot;&quot;,&quot;registered&quot;:true,&quot;expDate&quot;:&quot;2099-01-01&quot;,&quot;key&quot;:&quot;&quot;&#125;&#x27;</span>;<br>    &#125;<br>     <span class="hljs-section">location</span> /admin/service/registration/getStatus &#123;<br>     <span class="hljs-attribute">default_type</span> application/json;<br>     <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&#123;&quot;deviceStatus&quot;:&quot;0&quot;,&quot;planType&quot;:&quot;Lifetime&quot;,&quot;subscriptions&quot;:&#123;&#125;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><p>由于证书和密钥的文件路径可能各有不同，在上述代码块中修改成自定义路径</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># ssl_certificate /volume1/web/mb3admin.com/mb3admin.com.cert.pem;</span><br><span class="hljs-attribute">ssl_certificate</span> /change/to/your/own/cert/file/path;<br><span class="hljs-comment"># ssl_certificate_key /volume1/web/mb3admin.com/mb3admin.com.key.pem;</span><br><span class="hljs-attribute">ssl_certificate_key</span> /change/to/your/own/key/file/path;<br></code></pre></td></tr></table></figure></li></ul><p>将配置文件<code>emby_crack_nginx.conf</code>拷贝至群晖的系统目录<code>/etc/nginx/sites-enabled</code>目录下。</p><h3 id="4、修改hosts文件"><a href="#4、修改hosts文件" class="headerlink" title="4、修改hosts文件"></a>4、修改hosts文件</h3><p>由于Emby Server和Emby Client在验证会员时，向<code>mb3admin.com</code>进行post请求，因此需要在服务器或者客户端发出请求时，劫持到我们自行构建的nginx服务上，通过nginx发送假的验证通过的消息，实现会员资格验证成功。</p><p>因此需要在Emby Server和Emby Client所在的设备上修改hosts文件，将mb3admin.com域名直接指向群晖的IP。</p><ul><li>如果家中有能修改hosts的路由设备，可在路由器中直接修改，这样就不需要在每一个子设备中进行修改了；如果没有则在以下设备中的hosts文件中加入代码块中内容；</li><li>Emby Server所在服务端设备；</li><li>windows系统PC端；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># hosts</span><br><span class="hljs-comment"># &lt;群晖IP&gt; mb3admin.com</span><br><span class="hljs-comment"># 假如群晖IP是：192.168.1.100，则如下所示</span><br>192.168.1.100 mb3admin.com<br></code></pre></td></tr></table></figure><h3 id="5、向Emby服务端的证书库中导入CA证书"><a href="#5、向Emby服务端的证书库中导入CA证书" class="headerlink" title="5、向Emby服务端的证书库中导入CA证书"></a>5、向Emby服务端的证书库中导入CA证书</h3><p>在日志中发现会存在无法建立SsL连接的情况，爬贴后发现，是因为自签名证书不被Emby信任导致。这时候就需要我们将当初申请证书时，获取到的CA证书导入到Emby的可信任证书库中。docker 版本的话，需要先确认根证书文件是否由 host 端导入。整体操作流程，无论是套件版本还是 docker 版本，都大同小异。下面以套件版本为例进行说明。</p><blockquote><p>一般根证书文件存储在 <code>/etc</code> 目录下，因此需要 root 权限才能完成。以下操作均在 root 用户下进行。</p></blockquote><ol><li>进入证书存储的目录，以上文为例，执行命令： <code>cd /volume1/web/mb3admin.com</code> </li><li>打印证书内容，观察格式是否正确：<code>cat mb3admin.com.cert.pem</code><br> 按下回车键后，屏幕将输出形如一下内容，确认文件以 <code>-----BEGIN CERTIFICATE-----</code> 开头，<code>-----END CERTIFICATE-----</code> 结尾：<br> <img src="https://user-images.githubusercontent.com/35327600/224621454-b0d99048-5b8c-470e-b7b9-70d81d5865df.jpg"></li><li>将证书拷贝至对应目录，并重命名。这里以群晖7.1为例，执行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /usr/syno/etc/security-profile/ca-bundle-profile/ca-certificates/;<br><span class="hljs-built_in">cp</span> /volume1/web/mb3admin.com/mb3admin.com.cert.pem /usr/syno/etc/security-profile/ca-bundle-profile/ca-certificates/mb3admin.com.crt;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p> &#x2F;usr&#x2F;syno&#x2F;etc&#x2F;security-profile&#x2F;ca-bundle-profile&#x2F;ca-certificates&#x2F; 这个路径是从update-ca-certificates.sh中获取的，不同系统的路径可能不同，建议先执行 <code>sodu find / -name &quot;update-ca-certificates</code> ，查找这个文件。例如群晖7.1中，该文件位于 &#x2F;usr&#x2F;syno&#x2F;bin 中。使用 cat 命令查看文件内容，找到 <code>USERCERTSDIR=xxxxxxx</code> 行，”xxxxxxxx” 就是对应的路径；Ubuntu系统下，找到 LOCALCERTSDIR&#x3D;xxxxx 行即可。</p></blockquote><ol start="4"><li>更新根证书，执行命令：<code>update-ca-certificates.sh</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Emby</tag>
      
      <tag>群晖DSM7.1</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unraid自定义docker和虚拟机图标</title>
    <link href="/2023/02/21/Unraid%E8%87%AA%E5%AE%9A%E4%B9%89docker%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BE%E6%A0%87/"/>
    <url>/2023/02/21/Unraid%E8%87%AA%E5%AE%9A%E4%B9%89docker%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Unraid自定义docker和虚拟机图标"><a href="#Unraid自定义docker和虚拟机图标" class="headerlink" title="Unraid自定义docker和虚拟机图标"></a>Unraid自定义docker和虚拟机图标</h1><h2 id="一、自定义docker图标"><a href="#一、自定义docker图标" class="headerlink" title="一、自定义docker图标"></a>一、自定义docker图标</h2><p>在 Unraid 中可以通过自带的应用市场安装 docker 容器，但是也有部分docker并未上架市场，需要通过 “ADD CONTAINER” 按钮手动安装，这样的 docker 容器并没有自带图标。还有一部分即使是在应用市场安装的 docker 容器本身有图标，但是由于国内的网络环境原因，导致图标链接不可访问，最终在 docker 界面中显示一个灰底的问号。</p><p>这里用一个手动安装的 python:alpine3.16 的容器作为示例进行说明：<br><img src="https://user-images.githubusercontent.com/35327600/220238709-7d4f5fff-c5f6-4955-a2be-b84d23658354.png"></p><p>下面介绍两种方式来自定义设置 Docker 容器的图标。</p><h3 id="1-1、方法一：直接修改-Docker-容器配置"><a href="#1-1、方法一：直接修改-Docker-容器配置" class="headerlink" title="1.1、方法一：直接修改 Docker 容器配置"></a>1.1、方法一：直接修改 Docker 容器配置</h3><p>无论是从应用市场安装的 docker 容器还是手动创建的，都会在安装前展示容器的配置界面，两种安装方式的差别仅仅就是应用市场的 docker 容器会将大部分的配置参数预先填充，避免了手动配置填充的过程，为部分经验不足的新手提供了相当的便利。</p><p>一般来说，配置界面只展示了基础配置，我们点击右上角的 “BASIC VIEW” 按钮，打开高级配置 “ADVANCED VIEW”:<br><img src="https://user-images.githubusercontent.com/35327600/220241255-d0f8e445-8d3d-4de6-929a-01719f8c7d87.png"></p><p>打开后可见新增了许多配置项：<br><img src="https://user-images.githubusercontent.com/35327600/220242308-ad3b6a1f-621c-4fc7-b13f-5e5d56e45ec3.png"></p><p>可以看到新增的配置项中，有一项名为 “Icon URL” 的配置，这里填充的就是当前 docker 容器的图标链接。我们在网上找一个 Python 的图标，并复制其图片地址进行配置填充：<br>python图标链接：<code>https://github.com/walkxcode/dashboard-icons/blob/main/png/python.png?raw=true</code><br><img src="https://user-images.githubusercontent.com/35327600/220243495-3daabdd1-79bf-42d9-a819-375c763719de.png"></p><p>配置完成后，点击 “APPLY” 按钮更新应用配置，待完成后在 Docker 界面就能看到图标由原本的问号，变为刚在填充的链接所展示的 python 图标了。<br><img src="https://user-images.githubusercontent.com/35327600/220243941-f6dc6ec8-7df4-4cb9-a83b-39ec20738bdf.png"></p><p>方法一操作简单，直接在 WebUI 中进行配置即可。但是也有朋友想用本地自己制作的个性化图标，一种方法就是将图标上传到图床，然后使用图床链接进行配置。如果是具有个人版权的图标，不想上传到公共图床或者网络上，同时也不想自建图床，因为自建图床的学习成本相对较高，那么有没有其他办法进行修改配置呢？请看方法二——本地存储图标配置。</p><h3 id="1-2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）"><a href="#1-2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）" class="headerlink" title="1.2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）"></a>1.2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）</h3><p><mark>再次重申一下，方法二需要使用命令行操作，不会的朋友请尽量使用方法一，避免对系统本身造成无法修复的损害</mark>。</p><ul><li><p>首先我们先将图标下载到本地（因为我本地没有 Python 的图标，所以此处需要下载，如果本地已经有对应图标，就不需要下载），并存放到 unRAID 的任意共享目录中。</p></li><li><p>将图片名称修改为以下样式 <code>&lt;docker 容器名&gt;-icon.png</code> 。例如此处使用命令 <code>mv python.png python-icon.png</code> 即可完成重命名。<br>  这里我直接采用的 unRAID 后台命令行进行操作，也可以直接在windows下进行重命名<br>  <img src="https://user-images.githubusercontent.com/35327600/220259348-6b70c342-98e6-4d57-bade-6e6ee4111d04.png"></p></li><li><p>然后我们通过命令行将重命名后的图标文件拷贝到这个目录：<code>/var/lib/docker/unraid/images</code> 。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp python-icon.png /var/lib/docker/unraid/images;<br></code></pre></td></tr></table></figure><p>  其实在这个目录下，使用 ls 命令就能发现，所有 docker 容器的图标都被存放在这个目录底下。<br>  此时 docker 的图标还未生效，刷新界面后仍然显示的是灰底的问号。</p></li><li><p>下一步，我们需要去修改 docker 容器的配置。和<strong>方法一</strong>一样，打开高级配置，找到 “Icon URL” 配置项，但是此时<font color=red>不需要填充真实的链接，随意填入内容即可</font>。这是为了告诉 unRAID 系统，这个 docker 容器是有图标的，你得给我显示出来。<br>  但是为什么可以填充随意内容呢？结合上一步中在目录 <code>/var/lib/docker/unraid/images</code> ，我们不难猜到，unRAID 只是根据 “Icon URL” 中的链接去下载图标到特定目录，然后根据 docker 容器的命名和图标文件的命名进行匹配和展示的。由于我们自行将图标重命名并且存放到了指定位置，所以 unRAID 系统自然能进行匹配和展示了。</p><p>  <img src="https://user-images.githubusercontent.com/35327600/220262561-88362131-b355-498c-8193-899e7bc8564d.png"></p><p>  填充完成后，还是老样子，点击下方 “APPLY” 按钮，此时你会发现图标已经变成你自定义的样子了。</p><p>  <img src="https://user-images.githubusercontent.com/35327600/220262946-6d53e1b0-5197-4e09-b79e-a4a96aa2ccb5.png"></p></li></ul><h2 id="二、自定义虚拟机图标"><a href="#二、自定义虚拟机图标" class="headerlink" title="二、自定义虚拟机图标"></a>二、自定义虚拟机图标</h2><p>unRAID 提供的虚拟机图标类型较少，可能无法满足部分朋友的需要，此时也可通过自定义的方式进行配置。配置方法十分简单，下面一起来看下。</p><p>注意：虚拟机的配置修改需要在虚拟机处于关机状态下进行。</p><ol><li>第一步，打开虚拟机配置编辑，点击右上角的 “FORM VIEW”，打开 “XML VIEW” 模式<br> <img src="https://user-images.githubusercontent.com/35327600/220265145-e9d995dd-acd7-46fa-b717-b205d76de807.png"></li><li>按下键盘的 <code>Ctrl</code> + <code>F</code> 键，在弹出的搜索框中输入 “icon”，并回车进行搜索，找到 XML 文件中对应的字样<br> <img src="https://user-images.githubusercontent.com/35327600/220266149-ece8dd67-c4a1-4b5f-9111-a50b7999b615.png"></li><li>将下划线部分 <code>icon=&quot;/mnt/user/domains/DSM7.1/synology_icon.png&quot;</code> 双引号中的内容，修改为你自定义虚拟机图标的绝对路径。图标存放位置不限。<blockquote><p>图标文件的绝对路径，以存在位置为 unRAID 上创建的共享路径为例，可以参考这样修改：&#x2F;mnt&#x2F;user&#x2F;&lt;共享路径&gt;。将尖括号内的路径修改为图标在共享目录下的路径即可。以上文为例，我的共享目录是 domains，并在 domains 下创建了 DSM7.1 的子目录，图标存放在子目录中，因此绝对路径就是：&#x2F;mnt&#x2F;user&#x2F;domains&#x2F;DSM7.1&#x2F;synology_icon.png</p></blockquote></li><li>点击下方 “UPDATE” 按钮后即可生效<br> <img src="https://user-images.githubusercontent.com/35327600/220266951-c1cf9a8d-e093-4de1-a11d-f7cf9434d1ac.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>docker</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个“size_type”引发的Bug</title>
    <link href="/2023/02/21/%E4%B8%80%E4%B8%AA%E2%80%9Csize-type%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84Bug/"/>
    <url>/2023/02/21/%E4%B8%80%E4%B8%AA%E2%80%9Csize-type%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84Bug/</url>
    
    <content type="html"><![CDATA[<h1 id="一个“size-type”引发的Bug"><a href="#一个“size-type”引发的Bug" class="headerlink" title="一个“size_type”引发的Bug"></a>一个“size_type”引发的Bug</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">10</span>&#125;;<br>  <span class="hljs-comment">// 这是一个极端示例</span><br>  <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (pos &lt;= v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;pos &lt;= v.size() - 2&quot;</span> &lt;&lt; endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;pos &gt; v.size() - 2&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察上述示例代码，请回答出程序输出内容是什么？答案是 “pos &lt;&#x3D; v.size() - 2”，还是 “pos &gt; v.size() - 2” 呢？</p><p>可能有的人和我一样，第一反应是 <code>std::vector v</code> 中只有一个元素，因此 <code>v.size() == 1</code>，那 <code>0</code> 和 <code>1 - 2</code> 比较大小，肯定是结果是 “&gt;” 嘛。但是程序运行结果却告诉我们，这里输出的内容是 <code>pos &lt;= v.size() - 2</code> !</p><p>在 Ubuntu20.04 和 Debian10.2.1 中进行测试，结果均为 <code>pos &lt;= v.size() - 2</code>。运行结果如下</p><p><img src="https://user-images.githubusercontent.com/35327600/218906559-3314a6d2-d277-45a6-b50c-d9005bd3f496.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/218907216-e6132f30-a3e5-4ed8-8e52-63a242cc8242.png"></p><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>既然运行结果是 <code>pos &lt;= v.size() - 2</code>，那我们把这个 “&lt;&#x3D;” 号左右两边的值打印出来看看，到底是否与我们认为的 <code>pos == 0</code> 和 <code>v.size() - 2 == -1</code> 的结论一致。将日志输出行修改一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-keyword">if</span> () &#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;pos[&quot;</span> &lt;&lt; pos &lt;&lt; <span class="hljs-string">&quot;] &lt;= v.size() - 2[&quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;]&#x27;</span> &lt;&lt; endl;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>再次编译执行，结果如下：</p><p><img src="https://user-images.githubusercontent.com/35327600/218909328-2a63cad0-6eae-4bef-9529-bea27192ef65.png"></p><p>在控制台输出打印中可以看到，表达式 <code>v.size() - 2</code> 并非像我们认为的那样等于 “1 - 2 &#x3D;&#x3D; -1”，而是一个非常大的数值。其实到这里，有一定经验的程序员已经大概知道这是为什么了。负数，巨大数值，根据这两个因素基本可以确定是<font color=red>有符号类型（-1）被隐式转换成了无符号类型导致的溢出</font>！</p><p>这个问题，具体情况，我们可以通过gdb进行反汇编调试来仔细跟踪一下。</p><blockquote><p>真正的地址需要程序运行起来之后才能正确反汇编出来，否则反汇编出来的是偏移地址。</p></blockquote><p>先设置一个程序入口断点，确保程序已运行，我们在 main 函数的入口设置一个断点 <code>b *main</code>，并运行命中断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b *main<br>Breakpoint 1 at 0x11f5: file ./size_t.cc, line 7.<br>(gdb) r<br>Starting program: /home/openwrt/tmp/size_t/unittest_size_t<br><br>Breakpoint 1, main (argc=1, argv=0x11bf) at ./size_t.cc:7<br>7       int main(int argc, char* argv[]) &#123;<br>(gdb)<br><br></code></pre></td></tr></table></figure><p>然后再确定一下 if 这个判断语句的地址范围和反汇编内容。在 gdb 模式下输入 <code>disas /m main</code> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas /m main<br>Dump of assembler code for function main(int, char**):<br>7       int main(int argc, char* argv[]) &#123;<br>=&gt; 0x00005555555551f5 &lt;+0&gt;:     push   %rbp<br><br>......<br><br>11        if (pos &lt;= v.size() - 2) &#123;<br>   0x0000555555555261 &lt;+108&gt;:   mov    -0x24(%rbp),%eax<br>   0x0000555555555264 &lt;+111&gt;:   movslq %eax,%rbx<br>   0x0000555555555267 &lt;+114&gt;:   lea    -0x50(%rbp),%rax<br>   0x000055555555526b &lt;+118&gt;:   mov    %rax,%rdi<br>   0x000055555555526e &lt;+121&gt;:   call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>   0x0000555555555273 &lt;+126&gt;:   sub    $0x2,%rax<br>   0x0000555555555277 &lt;+130&gt;:   cmp    %rax,%rbx<br>   0x000055555555527a &lt;+133&gt;:   setbe  %al<br>   0x000055555555527d &lt;+136&gt;:   test   %al,%al<br>   0x000055555555527f &lt;+138&gt;:   je     0x5555555552f5 &lt;main(int, char**)+256&gt;<br><br>......<br>(gdb)<br><br></code></pre></td></tr></table></figure><p>我们先看其中这一段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x000055555555526e &lt;+121&gt;:   call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>0x0000555555555273 &lt;+126&gt;:   sub    $0x2,%rax<br>0x0000555555555277 &lt;+130&gt;:   cmp    %rax,%rbx<br></code></pre></td></tr></table></figure><p>这里第一个 call 语句中，我们可以看到调用了 <code>std::vector::size()</code> 的方法，我们将断点设置在这一处 <code>b *0x000055555555526e</code>，并执行 continue，直至命中断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b *0x000055555555526e<br>Breakpoint 2 at 0x55555555526e: file ./size_t.cc, line 11.<br>(gdb) c<br>Continuing.<br><br>Breakpoint 2, 0x000055555555526e in main (argc=1, argv=0x7fffffffe4a8)<br>    at ./size_t.cc:11<br>11        if (pos &lt;= v.size() - 2) &#123;<br>(gdb) x/3i $pc<br>=&gt; 0x55555555526e &lt;main(int, char**)+121&gt;:<br>    call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>   0x555555555273 &lt;main(int, char**)+126&gt;:      sub    $0x2,%rax<br>   0x555555555277 &lt;main(int, char**)+130&gt;:      cmp    %rax,%rbx<br><br></code></pre></td></tr></table></figure><p>观察 pc 指针，已经运行到断点所在地址，从这三句汇编语句中，我们不难看出寄存器 rax 中存放的是表达式 <code>v.size() - 2</code> 的结果，rbx 中则存放的是变量 pos 的值。我们进行单步调试，并在每次步进后查看这两个寄存器的值和寄存器标志位的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) ni  ## call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>11        if (pos &lt;= v.size() - 2) &#123; <br>(gdb) i r rax rbx eflags<br>rax            0x1                 1<br>rbx            0x0                 0<br>eflags         0x202               [ IF ]<br>(gdb) ni  ## sub    $0x2,%rax<br>11        if (pos &lt;= v.size() - 2) &#123;<br>(gdb) i r rax rbx eflags<br>rax            0xffffffffffffffff  -1<br>rbx            0x0                 0<br>eflags         0x297               [ CF PF AF SF IF ]<br>(gdb) x/3i $pc<br>=&gt; 0x555555555277 &lt;main(int, char**)+130&gt;:      cmp    %rax,%rbx<br>   0x55555555527a &lt;main(int, char**)+133&gt;:      setbe  %al<br>   0x55555555527d &lt;main(int, char**)+136&gt;:      test   %al,%al<br>(gdb) ni  ## cmp    %rax,%rbx<br>0x000055555555527a      11        if (pos &lt;= v.size() - 2) &#123;<br>(gdb) i r rax rbx eflags<br>rax            0xffffffffffffffff  -1<br>rbx            0x0                 0<br>eflags         0x213               [ CF AF IF ]<br>(gdb)<br><br></code></pre></td></tr></table></figure><p>通过记录标志位，我们不难发现，当执行 <code>sub $0x2 %rax</code> 时，标志位 CF 被置位了，这代表了<font color=red>这次的减法运算，是无符号类型数的减法运算，并且存在借位，即溢出</font>，同时 SF 也被置位了，表明当前的减法计算结果是一个负数（由于计算机中存放的数据以其补码形式存放，所以此处 0xffffffffffffffff 为补码，转换为源码就是 0x8000000000000001，十进制表示就是-1）。但是在后续的 <code>cmp %rax %rbx</code> 语句中，<mark>标志位 CF 再次被置位，也就意味着计算机将 rax 和 rbx 中的值都按照无符号数进行了减法计算</mark> <code>0x0 - 0xffffffffffffffff</code> 自然产生了借位的情况，所以计算机自然而然地认为 “0 &lt; -1”！</p><p>所以问题的根本原因在于计算机执行 cmp 指令时，将原本应该是有符号数 “-1” 当成了无符号数 “0xffffffffffffffff” 进行比较。因此在判断大小时，出现了异常的结果。</p><h2 id="问题跟踪"><a href="#问题跟踪" class="headerlink" title="问题跟踪"></a>问题跟踪</h2><p>那为什么计算机会将 “-1” 当成是无符号数呢，我们来看一下 <code>std::vector::size()</code> 方法的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><p>因此 <code>v.size()</code> 返回的 1 是 size_type 类型的。这个类型在 cplusplus 网站中，被释义为无符号整型，通常境况下同 size_t。到这里就真相大白了，由于 <code>v.size()</code> 这个方法返回了一个无符号整形结果，因此后续的减法运算和大小比较中，C++ 默认对此进行了隐式转换有符号整型转换为无符号整形，所有的运算都变成了无符号数的运算（对于无符号整形作减法的溢出，编译器不会做出任何警告）。</p><p>结合上文中通过反汇编调试得到的结论，证明问题的原因和最初我们的猜想是一致的。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>既然知道了问题的根本原因，那么解决方法也相对简单，只要保证进行运算操作时类型转换是合法的即可，</p><p>因为示例代码中 <code>v.size()</code> 获得的无符号整形较小，因此我们可以将其直接显式转换为有符号整形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br>  <span class="hljs-keyword">if</span> (pos &lt;= (<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>) &#123;<br>...<br></code></pre></td></tr></table></figure><p>但是这并不意味着只要显式地转换数据类型，就不会发生错误了。比如负数转换成无符号数，无符号数的最大值转换成有符号数，这两种就是典型的类型转换导致数值溢出的问题。</p><p>我们应该在不得不进行数据类型转换前，保证转换后不会出现溢出的问题！</p>]]></content>
    
    
    <categories>
      
      <category>踩坑日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>C++</tag>
      
      <tag>Bug</tag>
      
      <tag>溢出</tag>
      
      <tag>类型转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令简记</title>
    <link href="/2023/02/21/Linux%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/"/>
    <url>/2023/02/21/Linux%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令简记"><a href="#Linux命令简记" class="headerlink" title="Linux命令简记"></a>Linux命令简记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于部分linux命令使用频率较低，导致遇到时常常忘记命令选项的含义和使用方法，因此在本文中记录linux命令的常用选项和具体使用方法，并对部分命令记录使用实例。</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>常用选项：</p><ul><li>-c: 建立压缩档案</li><li>-x：解压</li><li>-t：查看内容</li><li>-r：向压缩归档文件末尾追加文件</li><li>-u：更新原压缩包中的文件</li><li>-f: 使用档案名字，这个参数是最后一个参数，后面只能接档案名</li></ul><p>可选参数：</p><ul><li>-z：有gzip属性的</li><li>-j：有bz2属性的</li><li>-Z：有compress属性的</li><li>-v：显示所有过程</li><li>-O：将文件解开到标准输出</li></ul><h3 id="压缩、解压"><a href="#压缩、解压" class="headerlink" title="压缩、解压"></a>压缩、解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩 file.tar.gz：压缩档案名称；file：待压缩目录</span><br>tar -czvf file.tar.gz ./file<br><br><span class="hljs-comment"># 解压</span><br>tar -xzvf file.tar.gz<br></code></pre></td></tr></table></figure><h3 id="加密压缩、解压"><a href="#加密压缩、解压" class="headerlink" title="加密压缩、解压"></a>加密压缩、解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加密压缩</span><br><span class="hljs-comment"># 使用 --exclude 选项排除指定目录</span><br>tar -czvf - --exclue=<span class="hljs-string">&quot;file/exclude_dir&quot;</span> ./file | openssl enc -e -des3 -salt -k P@ssw0rd | <span class="hljs-built_in">dd</span> of=file.tar.gz.des3<br><br><span class="hljs-comment"># 解压</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=file.tar.gz.des3 | openssl enc -d -des3 -salt -k P@ssw0rd | tar -xzvf -<br></code></pre></td></tr></table></figure><h3 id="分卷加密压缩、解压"><a href="#分卷加密压缩、解压" class="headerlink" title="分卷加密压缩、解压"></a>分卷加密压缩、解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 分卷加密压缩</span><br><span class="hljs-comment"># split 参数</span><br><span class="hljs-comment"># -b, --bytes=SIZE, 指定每个分割文件的大小，单位有K, M, G, P等</span><br><span class="hljs-comment"># -d, --numeric-suffixes, 指定分割文件的后缀为数字</span><br><span class="hljs-comment"># -a, --suffix-length=N, 指定分割文件数字后缀的长度，如果-a 1，则后缀为*.1，*.2；如果-a 2，则后缀为*.01，*.02</span><br><span class="hljs-comment"># -c, --line-bytes=SIZE, 指定每行最大的字节数</span><br><span class="hljs-comment"># -l, --lines=NUMBER, 指定每个文件最大的行数</span><br>tar -czvf - --exclue=<span class="hljs-string">&quot;file/exclude_dir&quot;</span> ./file | openssl enc -e -des3 -salt -k P@ssw0rd | <span class="hljs-built_in">split</span> -b 200m -d -a 2 - file.tar.gz.des3.<br><br><span class="hljs-comment"># 解压</span><br><span class="hljs-built_in">cat</span> file.tar.gz.des3.* | openssl enc -d -des3 -salt -k P@ssw0rd | tar -zxvf -<br></code></pre></td></tr></table></figure><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><ol><li><p>–exclude参数报错</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar: The following options were used after any non-optional arguments <span class="hljs-keyword">in</span> archive create or update mode.  These options are positional and affect only arguments that follow them.  Please, rearrange them properly.<br></code></pre></td></tr></table></figure><p> 这是因为不同版本的tar，<code>--exclude</code>选项添加的位置存在差异。当tar的版本小于1.30时，该选项可以放在待压缩目录之后；若tar版本为1.30时，<code>--exclude</code>需要添加在待压缩目录之前。如下所示</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tar --version tar (GNU tar) 1.30</span><br>tar -czvf file.tar.gz --exclude=<span class="hljs-string">&quot;file/exclude_dir&quot;</span> ./file<br><br><span class="hljs-comment"># tar --version tar (GNU tar) 1.26</span><br>tar -czvf file.tar.gz ./file --exclude=<span class="hljs-string">&quot;file/exclude_dir&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>常用选项：</p><ul><li>-c 或 –count : 计算符合样式的列数。</li><li>-h –no-filename : 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。 </li><li>-H –with-filename : 在显示符合范本样式的那一列之前，标示该列的文件名称。</li><li>-i 或 –ignore-case : 忽略字符大小写的差别。</li><li>-E 或 –extended-regexp : 将样式为延伸的正则表达式来使用。</li><li>-o 或 –only-matching : 只显示匹配PATTERN 部分。</li><li>-v 或 –invert-match : 显示不包含匹配文本的所有行。</li><li>-V 或 –version : 显示版本信息。</li><li>–include : 搜索指定的文件</li><li>–exclude : 搜索结果中排除指定文件</li><li>–exclude-from &lt;fileList&gt;: 在搜索结果中排除fileList中的文件，一行一个“pattern”</li></ul><h3 id="多条件与（and），或（or）查询"><a href="#多条件与（and），或（or）查询" class="headerlink" title="多条件与（and），或（or）查询"></a>多条件与（and），或（or）查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 与（and）</span><br>grep <span class="hljs-string">&#x27;pattern1&#x27;</span> file | grep <span class="hljs-string">&#x27;pattern2&#x27;</span><br><br><span class="hljs-comment"># 或（or），用法1</span><br>grep -E <span class="hljs-string">&#x27;pattern1|pattern2&#x27;</span> file<br><span class="hljs-comment"># 或（or），用法2</span><br>grep <span class="hljs-string">&#x27;pattern1\|pattern2&#x27;</span> file<br><span class="hljs-comment"># 或（or），用法3</span><br>egrep <span class="hljs-string">&#x27;pattern1|pattern2&#x27;</span> file<br><br></code></pre></td></tr></table></figure><h3 id="输出不包含指定内容的行，（非（NOT）查询）"><a href="#输出不包含指定内容的行，（非（NOT）查询）" class="headerlink" title="输出不包含指定内容的行，（非（NOT）查询）"></a>输出不包含指定内容的行，（非（NOT）查询）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出不包含‘pattern’的行</span><br>grep -v <span class="hljs-string">&#x27;pattern&#x27;</span> file<br></code></pre></td></tr></table></figure><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><ol><li>根据可执行文件名称和运行参数，过滤输出进程id <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps ef | grep -i <span class="hljs-string">&#x27;$&#123;process_name&#125;&#x27;</span> | grep -i <span class="hljs-string">&#x27;$&#123;excute_param&#125;&#x27;</span> | grep -v <span class="hljs-string">&#x27;grep&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>dd 命令用于读取、转换并输出数据。可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p><p>格式：<br><code>dd [operand]</code><br><code>dd option</code></p><p>常用参数：</p><ul><li>bs&#x3D;BYTES：同时设置输入&#x2F;输出的块大小为BYTES字节</li><li>count&#x3D;N：仅拷贝N个block块，块大小等于ibs指定的字节数</li><li>cbs&#x3D;BYTES：一次转换BYTES个字节，即指定转换缓冲区大小</li><li>ibs&#x3D;BYTES：一次读取BYTES个字节，即指定读取的一个块大小为BYTES字节</li><li>obs&#x3D;BYTES：一次输出BYTES个字节，即指定输出的一个块大小为BYTES字节</li><li>if&#x3D;FILE：输入文件名，默认为标准输入</li><li>iflag&#x3D;FLAGS</li><li>of&#x3D;FILE：输出文件名，默认为标准输出</li><li>oflag&#x3D;FLAGS</li><li>skip&#x3D;N：从输入文件开头跳过N个block块后开始复制</li><li>seek&#x3D;N：从输出文件开头跳过N个block块后开始复制</li><li>status&#x3D;LEVEL：打印到stderr的信息级别<ul><li>‘node’：    抑制错误消息之外的所有内容、</li><li>‘noxfer’：  抑制最终的传输统计数据</li><li>‘progress’：显示定期传输统计信息</li></ul></li><li>conv&#x3D;&lt;CONVS KEY WORDS&gt;<ul><li>lcase：把大写字符转换为小写字符</li><li>ucase：把小写字符转换为大写字符</li><li>noerror：出错时不停止</li><li>notrunc：不截断输出文件</li></ul></li></ul><h3 id="与管道符（-）配合读取-x2F-输出文件"><a href="#与管道符（-）配合读取-x2F-输出文件" class="headerlink" title="与管道符（|）配合读取&#x2F;输出文件"></a>与管道符（|）配合读取&#x2F;输出文件</h3><ol><li><p>读取文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配合 grep 查找指定内容</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=./testfile status=none | grep <span class="hljs-string">&#x27;HelloWord&#x27;</span><br></code></pre></td></tr></table></figure><p> <img src="https://user-images.githubusercontent.com/35327600/212609068-f83073cf-06b9-4c73-ad8b-55af99d80d98.png"></p></li><li><p>输出文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将docker image信息写入指定文件</span><br>docker image <span class="hljs-built_in">ls</span> | <span class="hljs-built_in">dd</span> of=./docker_image_info.txt status=none<br></code></pre></td></tr></table></figure><p> <img src="https://user-images.githubusercontent.com/35327600/212609286-2525b883-4bfc-4ac9-a804-09f720f3828e.png"></p></li></ol><h3 id="备份磁盘并恢复"><a href="#备份磁盘并恢复" class="headerlink" title="备份磁盘并恢复"></a>备份磁盘并恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 备份</span><br><span class="hljs-comment"># SATA硬盘被挂载在/dev/sda，将该SATA硬盘备份到sda.img中</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/root/sda.img<br><br><span class="hljs-comment"># 恢复</span><br><span class="hljs-comment"># /dev/sda 硬盘出现故障时，将备份的sda.img恢复到指定的sdb盘中去</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/root/sda.img of=/dev/sdb<br><br><span class="hljs-comment"># 复制完整磁盘环境</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/dev/sdc<br></code></pre></td></tr></table></figure><h3 id="压缩备份"><a href="#压缩备份" class="headerlink" title="压缩备份"></a>压缩备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 备份</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda | gzip &gt; /root/sda.img.gz<br><br><span class="hljs-comment"># 恢复</span><br>gzip -dc /root/sda.img.gz | <span class="hljs-built_in">dd</span> of=/dev/sdc<br></code></pre></td></tr></table></figure><h3 id="备份磁盘MBR表"><a href="#备份磁盘MBR表" class="headerlink" title="备份磁盘MBR表"></a>备份磁盘MBR表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 一块磁盘的第一个扇区的 512 个字节所存储的正是这块磁盘的 MBR 信息，我们尝试用 dd 命令备份 MBR：</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/root/sda.mbr.img count=1 bs=512<br><br><span class="hljs-comment"># 恢复</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/root/sda.mbr.img of=/dev/sda<br></code></pre></td></tr></table></figure><h3 id="简单的磁盘读写性能测试"><a href="#简单的磁盘读写性能测试" class="headerlink" title="简单的磁盘读写性能测试"></a>简单的磁盘读写性能测试</h3><p>通过 <code>/dev/null</code> 和 <code>/dev/zero</code> 完成读写性能测试</p><ul><li><code>/dev/null</code>，也叫空设备，小名“无底洞”。任何写入它的数据都会被无情抛弃。</li><li><code>/dev/zero</code>，可以产生连续不断的 null 的流（二进制的零流），用于向设备或文件写入 null 数据，一般用它来对设备或文件进行初始化。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 向磁盘上写入一个大小为1Gb的大文件, 通过计算该命令执行时间，判断磁盘写性能</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file<br><br><span class="hljs-comment"># 读取一个刚才生成的1Gb的文件，通过计算命令执行时间，判断磁盘读取性能</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/root/1Gb.file bs=64k of=/dev/null<br></code></pre></td></tr></table></figure><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch 不仅可以创建文件，还可以对其进行时间的一些修改  <br>格式：touch 参数 文件名  <br>参数：  <br>-a: 修改访问时间，或 -–time=atime 或 -–time=access 或 -–time=use  <br>-c: 或 -–no-creat，如果文件不存在则不创建文件  <br>-d: 使用指定的日期时间，可以使用不同的格式  <br>-m: 或 -–time=mtime 或 -–time=modify，改变修改时间  <br>-r: 把指定的文件日期更设成和参考文档或目录日期相同的时间  <br>-t: 使用指定的日期时间，格式与 date 指令相同<br></code></pre></td></tr></table></figure><h2 id="mtime"><a href="#mtime" class="headerlink" title="-mtime"></a>-mtime</h2><p>查找指定时间修改的文件，单位天，但是按24小时更便于理解，在下面的示例中，将文件修改时间与当前时间的时间差记为 “T”</p><p>e.g.</p><ul><li>-mtime -1：T &lt; 24</li><li>-mtime 1： 24 &lt; T &lt; 48</li><li>-mtime +1：T &gt; 48</li><li>-mtime -2：T &lt; 48</li><li>-mtime 2： 48 &lt; T &lt; 72</li><li>-mtime +2：T &gt; 72</li></ul><p>总结一下：</p><ol><li>假设期望获取修改时间为 <strong>N 天之内</strong>（T &lt; <code>N * 24h</code>内修改过）的文件，则 -mtime -N</li><li>假设期望获取修改时间为<strong>距离当前时间的第 N 天</strong>（<code>N * 24h</code> &lt; T &lt;  <code>(N + 1) * 24h</code>  之间修改）的文件，则 -mtime N</li><li>假设期望获取修改时间为<strong>距离当前时间 N 天之前</strong>（T &gt; <code>N * 24h</code>之前修改）的文件，则 -mtime (N-1)</li></ol><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Watchdog for Emby Media Server</title>
    <link href="/2023/02/21/Watchdog-for-Emby-Media-Server/"/>
    <url>/2023/02/21/Watchdog-for-Emby-Media-Server/</url>
    
    <content type="html"><![CDATA[<h1 id="Watchdog-for-Emby-Media-Server"><a href="#Watchdog-for-Emby-Media-Server" class="headerlink" title="Watchdog for Emby Media Server"></a>Watchdog for Emby Media Server</h1><h2 id="修订版本"><a href="#修订版本" class="headerlink" title="修订版本"></a>修订版本</h2><p><mark><font color="red">v1.x版本后续将不再更新维护，如有需要请更新使用v2.x版本！！！</font></mark></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>借助python中的看门狗模块（“watchdog”）监视emby媒体库目录，通过电报（telegram）的bot和channel，向频道订阅者推送Emby媒体库中新增影片信息，包括电影和剧集。</p><h2 id="实现说明"><a href="#实现说明" class="headerlink" title="实现说明"></a>实现说明</h2><p>v2.x版本中，删除了原始版本中的xmllint依赖，仅通过python完成所有功能实现。**因此在dockerfile中将基础镜像由<code>ubuntu:latest</code>变更为<code>python:alpine3.17</code>，拉取后镜像体积由231MB减小至69.5MB，体积减少约70%**。</p><p><strong>watchdog_for_Emby</strong> 对 Emby Server 自动影片刮削生成的“xxxx.nfo”文件进行监控。影片新入库后，Emby Server 自动执行刮削生成xml格式的nfo文件，<del>通过xmllint可以解析到部分该影片或者剧集的信息</del>通过“ElementTree”模块解析nfo文件，获取当前影片的基本信息。而影片的封面图，和剧集的详细信息，则需要通过TMDB的api进行查询获取，通过调用”requests.get()”方法完成查询。在按照电报bot的api文档对payload数据组装后，调用”requests.post()”方法推送给bot，由bot发布至对应频道。</p><h2 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h2><ol><li>python3.10及以上版本（v2.x版本中，使用了match..case..语法，仅在3.10及以上版本完成支持）</li><li>python Module: <em>watchdog</em>, <em>requests</em> (cmd: <code>pip3 install watchdog requests</code>)，<em>ElementTree</em></li><li><del>xmllint (os: ubuntu 20.04，cmd: <code>sudo apt-get install libxml2-utils</code>)</del> v2.x版本中已去除此依赖</li></ol><h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>BOT_TOKEN</td><td>电报 bot token</td></tr><tr><td>CHAT_ID</td><td>电报频道 chat_id</td></tr><tr><td>TMDB_API</td><td>TMDB api token</td></tr><tr><td>MEDIA_PATH</td><td>Emby 媒体库路径</td></tr><tr><td>LOG_PATH</td><td>&lt;可选&gt;日志文件路径，默认为<code>/var/tmp/overwatch.log</code></td></tr></tbody></table><h2 id="Docker-Run"><a href="#Docker-Run" class="headerlink" title="Docker Run"></a>Docker Run</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=watchdog-emby --restart=unless-stopped \<br>  -v &quot;your media lib&#x27;s host path&quot;:&quot;media lib&#x27;s container path&quot; \<br>  -e BOT_TOKEN=&quot;your telegram bot&#x27;s token&quot; \<br>  -e CHAT_ID=&quot;your telegram channle&#x27;s chat_id&quot; \<br>  -e TMDB_API=&quot;tmdb api token&quot; \<br>  -e MEDIA_PATH=&quot;media lib&#x27;s container path&quot; \<br>  -e LOG_PATH=&quot;log&#x27;s output path&quot; \<br>  b1gfac3c4t/overwatch<br>  <br></code></pre></td></tr></table></figure><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>电影：</p><p><img src="https://user-images.githubusercontent.com/35327600/209752390-4e45180b-d8cc-4378-bd98-c489638f7cb7.png"></p><p>剧集：</p><p><img src="https://user-images.githubusercontent.com/35327600/209752275-bad230b0-97a7-47e5-9a77-081afae7d6cf.png"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li>tmdb api 文档：<a href="https://developers.themoviedb.org/3">https://developers.themoviedb.org/3</a></li><li>telegram bot api 文档：<a href="https://core.telegram.org/bots/api">https://core.telegram.org/bots/api</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Emby</tag>
      
      <tag>Python3.10</tag>
      
      <tag>Watchdog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unraid USB Drive Crack 教程</title>
    <link href="/2023/02/21/Unraid-USB-Drive-Crack-%E6%95%99%E7%A8%8B/"/>
    <url>/2023/02/21/Unraid-USB-Drive-Crack-%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Unraid-USB-Drive-Crack-教程"><a href="#Unraid-USB-Drive-Crack-教程" class="headerlink" title="Unraid USB Drive Crack 教程"></a>Unraid USB Drive Crack 教程</h1><p><strong><font color="red">！！！破解教程仅供学习参考，务必支持正版软件，构建良好的软件版权生态！！！</font></strong></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>由于Unraid OS使用硬盘阵列的形式构建存储池，能尽可能利用硬盘空间，并且可以通过创建校验盘保护数据，因此Unraid OS也不失为一个NAS系统的好选择。</p><p>但是因为试用版需要在联网环境下完成授权，导致处于内网环境的NAS机器无法使用。网上虽然有大量的开心版，不过大多是通过第三方提供的一个keyMaker.exe对USB的GUID生成一个key文件进行破解，总感觉不是很安全。</p><p>在爬了无数帖子后，终于在老毛子的一个论坛中找到了每个人都能轻松”<strong>转正</strong>“，且安全的方法！论坛连接放在文末，近期论坛中已经释出6.11版本。</p><h2 id="二、准备工具"><a href="#二、准备工具" class="headerlink" title="二、准备工具"></a>二、准备工具</h2><ol><li>一个U盘</li><li>官方usb引导创建工具：<strong>Unraid.USB.Creator.Win32-2.1.exe</strong>（官网下载即可）</li><li>一个可以使用gcc的编译环境（Debian、Ubuntu、Centos等，虚拟机，云主机都可以）（windos下其实也可以，但是环境配置相对麻烦，不如直接使用虚拟机创建前面提到的三个linux系统）</li><li>一份源码构建密钥的源码：<code>https://github.com/mysll/unraid_test.git</code></li></ol><h2 id="三、Crack-系统盘破解"><a href="#三、Crack-系统盘破解" class="headerlink" title="三、Crack 系统盘破解"></a>三、Crack 系统盘破解</h2><h3 id="3-1、制作系统盘"><a href="#3-1、制作系统盘" class="headerlink" title="3.1、制作系统盘"></a>3.1、制作系统盘</h3><p>通过在官网下载的USB引导创建工具，制作官方系统盘即可，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/209258446-6d68256c-f8bf-4275-a102-13b0c288f0d3.png"></p><p>制作过程不在这里进行赘述了，B站大佬<a href="https://space.bilibili.com/28457/channel/seriesdetail?sid=896368">司波图</a>的Unraid系列教程中介绍的很详细了，不了解的朋友可以移步观看。</p><p>这里有几个需要注意的点：</p><ol><li><p>由于服务器在国外，直接在线下载可能会很慢，或者没有速度，也可以单独下载官网中的zip包，然后在图中第一步中选择”Local Zip”；</p></li><li><p>图中第二步”Select your USB Flash device”，注意是否是待制作的U盘，确认后将USB名称后面中括号内的一串数字记录下，如图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/209281193-0a968f78-8add-4d06-97cb-c80b44517b2a.png"></p><p>这是U盘的<strong>GUID</strong>，在后续破解中还需使用到。（如果忘记保存了，也没关系，重新打开这个制作工具就能再次看到了)</p></li><li><p>点击“<strong>Write</strong>”后会提示当前选中U盘会被格式化，如果没选错的话，OK就行；</p></li></ol><p>等待进度条满后，系统盘就制作完成了。<font color="blue">如果在制作系统盘时，选择了”Local Zip”，那么接下来还需要注意以下一点</font>:</p><blockquote><p>打开U盘目录，找到根目录下“make_bootable.bat”文件，右键点击后，选择管理员模式运行</p></blockquote><p>完成以上步骤后，暂时先不要拔下U盘，后续还需要对内部的文件进行操作。</p><h3 id="3-2、制作密钥"><a href="#3-2、制作密钥" class="headerlink" title="3.2、制作密钥"></a>3.2、制作密钥</h3><p>制作密钥过程需要在linux环境中进行（如果你的windows系统也部署了gcc，那也可以在windows下操作）。利用windows自带的“Hyper-V”虚拟机搭建一个Ubuntu非常的简单方便，不会的朋友可自行百度教程。下面我以Ubuntu为例介绍密钥的制作过程。</p><ol><li><p>首先将准备工具中第4点提到的源码下载下来，依次执行以下两条命令：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/mysll/unraid_test.git ./Unraid_test<br>cd Unraid_test<br></code></pre></td></tr></table></figure><p> <img src="https://user-images.githubusercontent.com/35327600/209284969-1ccd4d06-b0ad-4129-a746-3e7d487923ae.png"><br> 当然也可以不用以上命令，直接点击源码链接，去github网站上进行下载。（此处也有可能有网络问题，存在网络问题是，请百度关键词“github 下载失败”）</p></li><li><p>进入源码目录后，执行命令 <code>gcc -fPIC -shared unraid.c -o BTRS.key</code>，会一点C语言或者C++在linux环境编译的话，就能明白这一步在做什么，不明白也没关系，无脑执行即可。<br><font color="red">此时会在当前目录下生成一个名为“<strong>BTRS.key</strong>”的文件，你猜的没错，这就是我们所需要的密钥文件</font></p></li><li><p>将第二步中生成的“<strong>BTRS.key</strong>”拷贝到U盘的“<strong>config</strong>”目录下</p><p> <img src="https://user-images.githubusercontent.com/35327600/209305975-9f6ec553-e639-4fd3-8170-6584aa525047.png"></p></li><li><p>在config目录下找到一个名为“<strong>go</strong>”的文件，先将该文件备份一下，然后用以下内容替换原文件的内容</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">---------修改以下三项内容，只需要修改等号右边内容，左边不要变更--------- <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">GUID 将单引号内的内容替换成你自己U盘对应GUID</span><br>export UNRAID_GUID=&#x27;xxxx-xxxx-xxxx-xxxxxxxxxxxx&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME 随便填</span><br>export UNRAID_NAME=unraid_test<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是unix的一个时间戳，百度关键词“unix时间戳”，找一个转换网站，将当前时间转换为时间戳后填入，下面有示例</span><br>export UNRAID_DATE=1658129986<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-----------不要修改！！！不要修改！！！不要修改！！！------------------ <span class="hljs-comment">#</span></span><br>export UNRAID_VERSION=Pro<br>LD_PRELOAD=/boot/config/BTRS.key /usr/local/sbin/emhttp &amp;<br></code></pre></td></tr></table></figure></li></ol><p>  时间戳转换示例，<a href="https://tool.lu/timestamp/">在线转换工具</a>：</p><p>  <img src="https://user-images.githubusercontent.com/35327600/209291869-4c00d313-2e98-414c-b755-e2f48ab44e50.png"></p><p>此时可以拔下U盘，然后插到你的NAS上，愉快的使用啦~~~</p><p>当然了，还是希望有能力的朋友支持正版，毕竟这种开心版是否在后续使用中还是有所缺陷，例如强大的my_server就无法使用。更何况软件版权生态也是需要大家共同维护的。</p><h2 id="四、Backup-系统盘备份"><a href="#四、Backup-系统盘备份" class="headerlink" title="四、Backup 系统盘备份"></a>四、Backup 系统盘备份</h2><p>由于Unraid的系统文件完全被存储在U盘中，并且十分的轻量，因此备份变得非常方便。</p><p>在APP市场中下载“<strong>User Scripts</strong>”插件，通过定时执行备份脚本，实现定期备份系统盘的功能。</p><p><img src="https://user-images.githubusercontent.com/35327600/209297717-10fcb3ff-b65c-48fe-a796-a7a419912c20.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/209298058-adb48d23-c188-4000-b24a-0619df42ebb2.png"></p><p>创建完成后点击脚本前的小齿轮，选择”<strong>EDIT SCRIPT</strong>“，将下方内容贴入，然后点击”<strong>SAVE CHANGES</strong>即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>CUR_TIME=$(date &quot;+%Y%m%d%H%M%S&quot;)<br>BACKUP_FILE=&quot;unraid_flash_backup_$&#123;CUR_TIME&#125;.tar.gz&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将等号后面的路径修改为你自己的备份路径</span><br>BACKUP_PATH=&quot;/your/back/up/path/&quot;<br><br>tar -czvf $&#123;BACKUP_PATH&#125;$&#123;BACKUP_FILE&#125; /boot;<br></code></pre></td></tr></table></figure><p>保存后可以点击 “RUN SCRIPT” 测试一下备份文件是否成功创建。注意不可关闭运行后的弹窗，否则脚本会中止执行。</p><blockquote><p>这里还有更进阶的玩法，可以结合阿里云的webdav和rclone挂载，将备份包上传至网盘中，并删除过期备份包，避免占用过多网盘空间，这个有需要的话，可以后面再出一篇详细教程。</p></blockquote><h2 id="五、Rescure-系统盘恢复"><a href="#五、Rescure-系统盘恢复" class="headerlink" title="五、Rescure 系统盘恢复"></a>五、Rescure 系统盘恢复</h2><p>由于Unraid OS的完整系统都存在U盘中，因此当系统配置出现问题，导致无法进入引导，无法进入GUI界面时，并不会影响阵列！</p><p>因此系统盘的恢复，比备份更简单。只需要使用官方的USB制作工具创建一个官方的系统盘，然后将备份包中的config目录完全拷贝至当前的U盘内即可！是不是超级，非常，极其简单和方便！！！</p><p><mark>当然还有一个注意点，如果U盘更换了，config目录中的”<strong>go</strong>“文件中的GUID也需要同步修改一下。千万别忘记啦！</mark></p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oh-my-posh安装教程</title>
    <link href="/2023/02/21/oh-my-posh%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2023/02/21/oh-my-posh%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="oh-my-posh安装教程"><a href="#oh-my-posh安装教程" class="headerlink" title="oh-my-posh安装教程"></a>oh-my-posh安装教程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>github: <a href="https://github.com/JanDeDobbeleer/oh-my-posh">https://github.com/JanDeDobbeleer/oh-my-posh</a></li><li>docs:   <a href="https://ohmyposh.dev/">https://ohmyposh.dev/</a></li></ul><p>docs中有详细的安装和使用说明，下文中有不明白的可以移步官方文档自行学习使用~</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下面以新安装的x86_64的debian环境进行举例</p><p><code>Linux debian 5.10.0-19-amd64 #1 SMP Debian 5.10.149-2 (2022-10-21) x86_64 GNU/Linux</code></p><p>针对内网和非root用户进行安装，避免污染其他用户的使用环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 获取posh可执行文件，内网环境可以直接从github中下载后，拷贝到用户下指定目录</span><br><span class="hljs-comment"># 当前命令中下载的可执行文件是基于amd64架构的，根据自己的系统架构选择下载</span><br><span class="hljs-built_in">mkdir</span> -p ~/oh-my-posh<br>wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-amd64 -O ~/oh-my-posh/posh;<br><span class="hljs-built_in">wait</span>;<br><span class="hljs-built_in">chmod</span> +x ~/oh-my-posh/posh;<br><br><span class="hljs-comment"># 下载主题</span><br><span class="hljs-built_in">mkdir</span> -p ~/oh-my-posh/.poshthemes;<br>wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/oh-my-posh/.poshthemes/themes.zip;<br><span class="hljs-built_in">wait</span>;<br>unzip -q ~/oh-my-posh/.poshthemes/themes.zip -d ~/oh-my-posh/.poshthemes;<br><span class="hljs-built_in">wait</span>;<br><span class="hljs-built_in">rm</span> ~/oh-my-posh/.poshthemes/themes.zip -vf;<br><span class="hljs-built_in">chmod</span> u+rw ~/oh-my-posh/.poshthemes/*.omp.*;<br><br><span class="hljs-comment"># 向~/.profile，或者~/.bashrc，或者~/.bash_profile中写入posh初始化命令，下面命令中以~/.profile为例，并指定主题 montys.omp.json</span><br>sed -i <span class="hljs-string">&#x27;$a eval &quot;$(~/oh-my-posh/posh init bash --config ~/oh-my-posh/.poshthemes/montys.omp.json)&quot;&#x27;</span> ~/.profile;<br><br><span class="hljs-comment"># 重新启用bash</span><br><span class="hljs-built_in">source</span> ~/.profile;<br><br><span class="hljs-comment"># 若安装了zsh，则最后两行命令用下面两行替代</span><br><span class="hljs-comment"># 向~/.zshrc中写入posh初始化命令，并指定主题 montys.omp.json</span><br><span class="hljs-comment">#sed -i &#x27;$a eval &quot;$(~/oh-my-posh/posh init zsh --config ~/oh-my-posh/.poshthemes/montys.omp.json)&quot;&#x27; ~/.zshrc;</span><br><span class="hljs-comment"># 应用新的.zshrc文件</span><br><span class="hljs-comment">#exec zsh;</span><br><br></code></pre></td></tr></table></figure><h2 id="示例动画"><a href="#示例动画" class="headerlink" title="示例动画"></a>示例动画</h2><p><img src="https://user-images.githubusercontent.com/35327600/211761346-9d91a9ad-bc18-4128-8cf4-49a91ebfcb0e.gif"></p><h2 id="montys-omp-json主题微调"><a href="#montys-omp-json主题微调" class="headerlink" title="montys.omp.json主题微调"></a>montys.omp.json主题微调</h2><p>由于montys主题默认会在powerline中输出完整的路径，当路径层级较深时，powerline显示就太长了，因此参考文档进行了微调。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/themes/montys.omp.json b/themes/montys.omp.json</span><br><span class="hljs-comment">index c7797e88..c8eeb6c4 100644</span><br><span class="hljs-comment">--- a/themes/montys.omp.json</span><br><span class="hljs-comment">+++ b/themes/montys.omp.json</span><br><span class="hljs-meta">@@ -17,10 +17,11 @@</span><br>           &quot;foreground&quot;: &quot;#ffffff&quot;,<br>           &quot;powerline_symbol&quot;: &quot;\ue0b0&quot;,<br>           &quot;properties&quot;: &#123;<br><span class="hljs-deletion">-            &quot;folder_icon&quot;: &quot;\uf115&quot;,</span><br><span class="hljs-addition">+            &quot;folder_icon&quot;: &quot;\uf07c&quot;,</span><br>             &quot;folder_separator_icon&quot;: &quot;\\&quot;,<br>             &quot;home_icon&quot;: &quot;\uf7db&quot;,<br><span class="hljs-deletion">-            &quot;style&quot;: &quot;full&quot;</span><br><span class="hljs-addition">+            &quot;style&quot;: &quot;agnoster_short&quot;,</span><br><span class="hljs-addition">+            &quot;max_depth&quot;: 3</span><br>           &#125;,<br>           &quot;style&quot;: &quot;powerline&quot;,<br>           &quot;template&quot;: &quot; &lt;#000&gt;\uf07b \uf553&lt;/&gt; &#123;&#123; .Path &#125;&#125; &quot;,<br></code></pre></td></tr></table></figure><p>效果对比：</p><p>before：</p><p><img src="https://user-images.githubusercontent.com/35327600/211757664-172072e7-7c19-49e0-b900-7c6975471931.png"></p><p>after:</p><p><img src="https://user-images.githubusercontent.com/35327600/211762075-d3a46f69-5bf8-4dfe-a15a-e39ff4ca9198.png"></p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Shell</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>Debain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows10挂载Webdav</title>
    <link href="/2023/02/21/Windows10%E6%8C%82%E8%BD%BDWebdav/"/>
    <url>/2023/02/21/Windows10%E6%8C%82%E8%BD%BDWebdav/</url>
    
    <content type="html"><![CDATA[<h1 id="windows10挂载webdav"><a href="#windows10挂载webdav" class="headerlink" title="windows10挂载webdav"></a>windows10挂载webdav</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>当前市面上大部分的网盘，可以挂载到 “<strong>Alist</strong>“ 中。Alist 又支持 webdav协议。这就意味着通过 Alist 的 webdav 服务，我们可以直接将网盘挂载到本地，类似于本地磁盘一样读写网盘中文件。</p><p>但是在本地挂载的过程中，无论是添加网络位置，还是映射网络驱动器，都会出现文件路径不对、网络错误无法访问等错误，如下所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/215680157-9de51400-15cc-4d22-9d01-5e6bf8411e8f.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/215675986-ba71818f-88cb-4151-86b9-aae6ee69aa22.png"></p><p>本文将简单介绍如何在Windows环境下挂载本地webdav。</p><h2 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h2><p>导致简介中的问题其实非常简单。<mark>windows 默认的 WebClient 服务仅支持 https 协议</mark>，而本地搭建的 webdav 服务和链接都是基于 http 协议的，因此才造成了挂载失败的情况。</p><p>对于部分高手来说，将 webdav 服务转换为 https 协议必然是更安全，更好的选择。但是对于部分仅内网挂载访问，安全性需求较低的朋友来说，升级 https 的代价可能有些高昂，因此使 windows 自带的 WebClient 支持 http，可能是更快捷方便的选择。</p><h3 id="三、设置-WebClient，允许-http-链接挂载"><a href="#三、设置-WebClient，允许-http-链接挂载" class="headerlink" title="三、设置 WebClient，允许 http 链接挂载"></a>三、设置 WebClient，允许 http 链接挂载</h3><p>步骤1：<br>按下 “<strong>windows徽标键</strong>“ + “<strong>R</strong>“，打开运行窗口，输入<code>regedit</code>，点击确定后，打开注册表编辑器窗口。</p><p>步骤2：<br>将路径定位到以下路径：<code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters</code>。双击右侧界面中的 <code>BasicAuthLevel</code> 条目，将数值数据修改为“2”，点击确定后关闭注册表编辑器。</p><p><img src="https://user-images.githubusercontent.com/35327600/215690501-29b6636a-a17b-4fcd-a871-f3ddf031dfef.png"></p><p>步骤3：<br>按下 “<strong>windows徽标键</strong>“ + “<strong>R</strong>“，打开运行窗口，输入<code>services.msc</code>，点击确定后，打开“服务”界面。找到 “<strong>WebClient</strong>“<br>服务，右键点击打开选项菜单，选择重新启动，稍等几秒，待完成后，关闭“服务”界面。</p><p><img src="https://user-images.githubusercontent.com/35327600/215691793-fc3e4385-f6e4-47ed-bd8e-7a00d3a7cf4f.png"></p><p>完成上述三个步骤后，WebClient 服务已经允许使用 http 协议进行挂载。</p><h2 id="四、挂载测试"><a href="#四、挂载测试" class="headerlink" title="四、挂载测试"></a>四、挂载测试</h2><ol><li><p>映射网络驱动器<br> <img src="https://user-images.githubusercontent.com/35327600/215694498-777dba03-505a-4922-9485-ba99c0eb5809.png"><br> <img src="https://user-images.githubusercontent.com/35327600/215694514-24f0ddf9-f2b2-4059-8e7a-107b216565d9.png"></p></li><li><p>添加网络位置<br> <img src="https://user-images.githubusercontent.com/35327600/215695212-f220eeb9-23f0-4500-987d-dea5146898a4.png"><br> <img src="https://user-images.githubusercontent.com/35327600/215695227-595b63d6-c31e-4d06-83da-98179b01fdb1.png"></p></li></ol><p>可以看到，在修改注册表后，映射网络驱动器和添加网络位置，都能正确访问 webdav 服务了。</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Windows10</tag>
      
      <tag>Webdav</tag>
      
      <tag>注册表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/2023/02/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/02/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><blockquote><p>在C++11和更高版本中，Lambda表达式（通常称为Lambda）是一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。Lambda通常用于封装传递给算法或异步函数的少量代码行。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++ 中的 Lambda 表达式（https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170）](https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170)">[1]</span></a></sup></p></blockquote><p>Lambda表达式是C++11中一个较为重要的特性，其来源于函数式编程的概念，也是现代编程语言的一个特点。</p><p>Lambda表达式有以下优点：</p><ul><li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。以更直接的方式撰写程序代码，具有较高的可读性和可维护性。</li><li>简介：不需要额外写一个函数或函数对象，避免代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也具备更高的生产效率。</li><li>在需要的时间和地点实现功能闭包，使程序更灵活。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++11 lambda表达式精讲（http://c.biancheng.net/view/3741.html）](http://c.biancheng.net/view/3741.html)">[2]</span></a></sup></li></ul><p>下文将记录和简述Lambda表达式中的基本概念和用法。</p><h2 id="一、Lambda表达式组成"><a href="#一、Lambda表达式组成" class="headerlink" title="一、Lambda表达式组成"></a>一、Lambda表达式组成</h2><p>ISO C++ 标准展示了作为第三个参数传递给 <code>std::sort()</code> 函数的简单 lambda：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abssort</span><span class="hljs-params">(<span class="hljs-type">float</span>* x, <span class="hljs-type">unsigned</span> n)</span> </span>&#123;<br>std::<span class="hljs-built_in">sort</span>(x, x+n, <br><span class="hljs-comment">// Lambda expression begins</span><br>[](<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b) &#123;<br><span class="hljs-built_in">return</span> (std::<span class="hljs-built_in">abs</span>(a) &lt; std::<span class="hljs-built_in">abs</span>(b));<br>&#125; <span class="hljs-comment">// end of lambda expression</span><br>);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的简单Lambda示例，可以将其按照下图进行概括：</p><p><img src="https://learn.microsoft.com/zh-cn/cpp/cpp/media/lambdaexpsyntax.png?view=msvc-170" alt="Lambda组成"></p><p>其中各个组成部分分别表示为：</p><ol><li>capture子句（C++规范中也称为Lambda引导）</li><li>参数列表（可选）。（也称为Lambda声明符）</li><li>mutable规范（可选）。</li><li>exception-specification（可选）。</li><li>trailing-return-type（可选）。</li><li>Lambda体，即函数体。</li></ol><h2 id="二、capture子句"><a href="#二、capture子句" class="headerlink" title="二、capture子句"></a>二、capture子句</h2><p>Lambda 以 capture 子句开头，它用于指示 Lambda 捕获周边范围中的哪些变量，以及捕获变量的方式（按值捕获、按引用捕获’&amp;’），当然也可以使用空的 capture 子句<code>[ ]</code>表示不捕获任何变量。</p><p>除了在 capture 子句中直接指定待捕获的外部变量，也可以使用默认捕获模式来指示如何捕获Lambda体中引用的任何外部变量：</p><ol><li><p><code>[&amp;]</code>：表示通过“<strong>引用捕获</strong>”引用所有的变量</p></li><li><p><code>[=]</code>：表示通过“<strong>值捕获</strong>”获取外部变量的值</p></li></ol><p><font color=red>当使用默认捕获模式时，仍然可以为特定变量显式地指定相反的模式</font>。例如，Lambda 体通过引用访问外部变量 <code>a</code> ，并通过值访问外部变量 <code>b</code> ，则可以参考以下 capture 子句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[&amp;a, b] <span class="hljs-comment">// 分别指定引用访问a，值访问b</span><br>[b, &amp;a] <span class="hljs-comment">// 单独指定时，不区分先后顺序</span><br>[=, &amp;a] <span class="hljs-comment">// 默认使用值捕获，但是变量a使用引用捕获</span><br>[&amp;,  b] <span class="hljs-comment">// 默认使用引用捕获，但是表量b使用值捕获</span><br><span class="hljs-comment">// 使用默认捕获时，只有 Lambda 体中提及的变量才会被捕获。</span><br></code></pre></td></tr></table></figure><p><mark>在类成员函数中使用 Lambda，如果 Lambda 需要访问类的成员函数和数据成员，则需要将this指针传递给 capture 子句。在C++17及以上版本中，可以通过在 capture 子句中指定<code>*this</code>通过值捕获<code>this</code>指针</mark>。</p><p>在使用 capture 子句时，有以下几点建议：</p><ul><li><font color=red>Lambda 能捕获当前作用域内的<code>non-static</code>类型变量，对于全局变量，局部静态变量，则可以在 Lambda 体中直接引用</font>，但是此处容易存在依赖问题，在下文章节 [“Effective Modern C++ 中的 Lambda 表达式”](#八、Effective Modern C++ 中的 Lambda 表达式) 中进行介绍。</li><li>引用捕获可用于修改外部变量，而值捕获却不能实现此操作。（<font color=red><code>mutable</code>声明允许修改Lambda中的副本，但不会修改原始项</font>）</li><li>引用捕获会反映外部变量的更新，而值捕获不会。</li><li>避免使用默认捕获模式。（同第一条，将在 [“Effective Modern C++ 中的 Lambda 表达式”](#八、Effective Modern C++ 中的 Lambda 表达式) 章节中详细描述）</li></ul><h2 id="三、通用捕获-x2F-初始化捕获（init-capture）（C-14）"><a href="#三、通用捕获-x2F-初始化捕获（init-capture）（C-14）" class="headerlink" title="三、通用捕获&#x2F;初始化捕获（init capture）（C++14）"></a>三、通用捕获&#x2F;初始化捕获（<em>init capture</em>）（C++14）</h2><p>在某些场景下，如果有一个只能被移动的对象（例如<code>std::unique_ptr</code>或<code>std::future</code>）要进入闭包中，使用C++11是无法实现的。又或者要复制的对象复制开销非常高，但移动成本却相对比较低（例如stl标准库中的大多数容器），并且开发者期望的是宁愿移动该对象到闭包而不是复制时，C++11也无法实现该目标。</p><p>在C++14标准中，增加了通用捕获，又或者叫初始化捕获，移动捕获是它可以执行的技术之一。</p><p>使用初始化捕获时，开发者可以指定：</p><ol><li>从 lambda 生成的闭包类中的数据成员名称；</li><li>初始化该成员的表达式</li></ol><p>见以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pNums = make_unique&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(nums);<br><br><span class="hljs-keyword">auto</span> a = [ptr = <span class="hljs-built_in">move</span>(pNums)]() &#123;<br><span class="hljs-comment">// use ptr</span><br>  &#125;;<br></code></pre></td></tr></table></figure><h2 id="四、参数列表"><a href="#四、参数列表" class="headerlink" title="四、参数列表"></a>四、参数列表</h2><p>参数列表（在标准语法中称为 Lambda 声明符）是可选的。在大多数时候，它类似于参数的参数列表。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>在C++14中，可以使用<code>auto</code>关键字作为类型说明符，表示泛型参数类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>在C++14中，Lambda 也接受可变形参</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> &amp;&amp;...params) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(params)&gt;(params)...));<br>  &#125;;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>由于参数列表是可选的，因此在不将自变量传递到 Lambda 表达式，并且其 Lambda 声明符不包含 exception-specification、trailing-return-type 或 <strong><code>mutable</code></strong> 的情况下，可以省略空括号。</p></blockquote><h2 id="五、mutable-规范"><a href="#五、mutable-规范" class="headerlink" title="五、mutable 规范"></a>五、mutable 规范</h2><p><mark>通常，Lambda 的函数调用运算符是<code>const-by-value</code>，但是对<code>mutable</code>关键字的使用可以取消。利用<code>mutable</code>规范，Lambda 表达式的主题可以修改通过值捕获的变量。</mark></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *b = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">auto</span> f4 = [b]() <span class="hljs-keyword">mutable</span> &#123;<br>  b = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>  *b = <span class="hljs-number">10</span>;<br>  cout &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;--&quot;</span> &lt;&lt; *b &lt;&lt; endl;<br>  <span class="hljs-keyword">delete</span> b;<br>&#125;;<br><span class="hljs-built_in">f4</span>();<br></code></pre></td></tr></table></figure><h2 id="六、异常规范"><a href="#六、异常规范" class="headerlink" title="六、异常规范"></a>六、异常规范</h2><p>你可以使用 noexcept 异常规范来指示 Lambda 表达式不会引发任何异常。 与普通函数一样，如果 Lambda 表达式声明 noexcept 异常规范且 Lambda 体引发异常，Microsoft C++ 编译器将生成警告。</p><h2 id="七、返回类型"><a href="#七、返回类型" class="headerlink" title="七、返回类型"></a>七、返回类型</h2><p>编译器能够自动推导 Lambda 表达值返回值类型，缺省状态下即表示为自动推导。当然也可以手动指定 trailing-return-type。trailing-return-type 类似普通函数的return-type，但是返回类型必须更在参数列表后面，并且必须在返回类型前包含关键字 <code>-&gt;</code>。</p><p>Lambda 表达式可以生成另一个 lambda 表达式作为其返回值。</p><h2 id="八、Effective-Modern-C-中的-Lambda-表达式"><a href="#八、Effective-Modern-C-中的-Lambda-表达式" class="headerlink" title="八、Effective Modern C++ 中的 Lambda 表达式"></a>八、Effective Modern C++ 中的 Lambda 表达式</h2><p>在《Effective Modern C++》中也对 lambda 表达式给出了相关的建议，一共包含了四项条款，将在下文进行介绍和记录。</p><h3 id="条款31：避免使用默认捕获模式"><a href="#条款31：避免使用默认捕获模式" class="headerlink" title="条款31：避免使用默认捕获模式"></a>条款31：避免使用默认捕获模式</h3><p>Item 31: Avoid default capture modes</p><p>就个人理解而言，该条款主要还是针对使用默认的按引用捕获时，由于引用存在依赖生命周期的问题，因此极易导致悬空引用的问题。而默认的按值捕获，按照作者的描述，则可能诱骗开发者以为能解决悬空引用的问题（实际上并没有解决），还会让开发者误以为自己所构建的闭包是独立的（事实上也并不是独立的）。</p><p>对于默认按引用捕获导致悬空引用的问题，我们先来举一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> Fn = function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><br><span class="hljs-function">Fn <span class="hljs-title">capture_by_ref</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Fn <span class="hljs-title">capture_by_val</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">capture_by_ref</span>();<br>  <span class="hljs-built_in">f</span>();<br>  f = <span class="hljs-built_in">capture_by_val</span>();<br>  <span class="hljs-built_in">f</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Fn <span class="hljs-title">capture_by_val</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [=]()&#123;cout &lt;&lt; <span class="hljs-string">&quot;capture_by_val: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;;<br>&#125;<br><br><span class="hljs-function">Fn <span class="hljs-title">capture_by_ref</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [&amp;]()&#123;cout &lt;&lt; <span class="hljs-string">&quot;capture_by_ref: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在<code>Ubuntu 20.04</code>下编译运行，结果如下图所示：<br><img src="https://user-images.githubusercontent.com/35327600/215710670-8e68c21d-58ba-450f-8342-f49a40bc2589.png"><br>可以清晰的看到，按值捕获的 a 可以正常输出打印。但是在按引用捕获的情形下，a已经成为一个悬空的引用了，在 cout 时，出现了未定义的行为。每次执行输出的 a 的值都是一个随机值。</p><p>为什么会出现这个问题呢？根本原因就在于按引用捕获！</p><p>在<code>Fn capture_by_ref();</code>函数中，<font color=red>Lambda 捕获了一个临时变量的引用，但是在函数 return 之后，临时变量 a 将被系统自动释放出栈，此时 a 的生命周期已经结束</font>。而 Lambda 中却仍然保存着该临时变量的引用，“这里我们可以暂时将其理解为闭包类中保存的是原临时变量 a 的地址，在函数<code>capture_by_ref</code> return 之后，该地址被释放，里面的内容自然变成了未定义的内容”，所以每次调用时程序所打印的内容都是未知的值。</p><p>这个例子很好的说明了按引用捕获存在着较高的引用悬空的风险，默认的引用捕获则更是加大了这种风险，因此尽量还是避免使用默认的按引用捕获。</p><p><code>Fn capture_by_val();</code>采用了按值捕获的方式，正确打印了被捕获的变量 a 的值，这也确实是解决被引用捕获的变量的生命周期短于 Lambda 导致引用悬空问题的一个正确方法。但是这并不代表着按值捕获不存在问题。按值捕获同样存在着依赖生命周期的问题。</p><p>再来看一个简单的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>  *a = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// Lambda 按值捕获指针变量 a，在闭包类中保存 a 的副本</span><br>  <span class="hljs-keyword">auto</span> f = [=]() &#123; cout &lt;&lt; *a &lt;&lt; endl; &#125;;<br>  <span class="hljs-comment">// 在外部调用 delete 释放指针变量 a</span><br>  <span class="hljs-keyword">delete</span> a;<br>  <span class="hljs-comment">// 调用 Lambda，运行时会提示 heap-used-after-free</span><br>  <span class="hljs-built_in">f</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// avoid_default_capture.cc</span><br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://user-images.githubusercontent.com/35327600/215921879-efb4fc60-68db-4e35-a1a8-53c75da3bc1b.png"></p><p>结果是显而易见的，尽管我们在 Lambda 中使用了按值捕获以获得指针变量 a 的副本，但是我们无法避免外部对这个指针变量的 delete 操作。在这个例子中，Lambda 表达式执行时，指针变量 a 已经成为一个未定义的内容，直接对其解引用操作自然也就存在严重错误了。</p><p>当然这个例子放在这里可能比较极端，但是在多线程的异步编程中，变量生命周期长短不同，需要大量线程同步的情况随处可见，因此不得不小心。更何况在多线程中，还存在着大量的异步读写，这也可能会导致 Lambda 对该变量存在脏读的可能。</p><p>如果只能使用C++11标准，那么对于这种特定的问题，可以<font color=red>通过给期望捕获的变量做一个局部副本，然后捕获该副本去解决</font>，比如像下面例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>  *a = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 期望捕获指针变量 a，用以获取 a 中存储的内容</span><br>  <span class="hljs-comment">// 声明一个 _a 变量，作为指针变量 a 的局部副本</span><br>  <span class="hljs-type">int</span> _a = *a;<br>  <span class="hljs-comment">// 通过按值捕获副本，避免出现依赖生命周期的问题</span><br>  <span class="hljs-keyword">auto</span> f = [_a]() &#123; cout &lt;&lt; _a &lt;&lt; endl; &#125;;<br>  <span class="hljs-comment">// 在外部调用 delete 释放指针变量 a</span><br>  <span class="hljs-keyword">delete</span> a;<br>  <span class="hljs-comment">// 此时调用函数 f()，就不再出现之前的“heap-used-after-free”问题</span><br>  <span class="hljs-built_in">f</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// avoid_default_capture.cc</span><br></code></pre></td></tr></table></figure><p><mark>如果你被允许使用C++14或者更高的标准，那么使用“初始化捕获”可能是更好的选择。</mark></p><p>默认捕获模式，还存在一个更大的隐患，在类的“non-static”成员函数中使用默认捕获。众所周知，在类的“non-static”成员函数中，都包含了一个隐式指针 “<strong>this</strong>”。这里直接展示《Effective Modern C++》中的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> FilterContainer =                     <span class="hljs-comment">//“using”参见条款9，</span><br>    std::vector&lt;std::function&lt;<span class="hljs-built_in">bool</span>(<span class="hljs-type">int</span>)&gt;&gt;;  <span class="hljs-comment">//std::function参见条款2</span><br><br>FilterContainer filters;                    <span class="hljs-comment">//过滤函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    …                       <span class="hljs-comment">//构造函数等</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addFilter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//向filters添加条目</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> divisor;            <span class="hljs-comment">//在Widget的过滤器使用</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::addFilter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    filters.<span class="hljs-built_in">emplace_back</span>(<br>        [=](<span class="hljs-type">int</span> value) &#123; <span class="hljs-keyword">return</span> value % divisor == <span class="hljs-number">0</span>; &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>在函数<code>void Widget::addFilter() const;</code>中，Lambda 中使用了一个变量 <code>divisor</code>。对于不熟悉 lambda 的开发者来说，可能不太能理解变量 divisor 是什么，从哪里来的。C++ 中类的“non-static”成员函数都包含一个隐式的参数——“<strong>this</strong>指针”，而在 lambda 的捕获子句中使用了默认按值捕获的模式，这也就意味着 lambda 捕获了这个类的“<strong>this</strong>”指针，因此可以在 lambda 体中直接访问该类的数据成员和成员函数。<font color=red>由于捕获只能应用与 lambda 被创建时所在作用域内的 “non-static” 局部变量（包括形参）</font>,因此直接显式地指定捕获 divisor 变量，或者删除默认捕获模式，都将导致该代码编译失败。</p><p>这也就是前面提到的，默认按值捕获，会诱骗开发者错误地认为当前闭包是独立的。对于这个缺点，《Effective Modern C++》中还给出了一个例子，让我们来简单看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addDivisorFilter</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> calc1 = <span class="hljs-built_in">computeSomeValue1</span>();    <span class="hljs-comment">//现在是static</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> calc2 = <span class="hljs-built_in">computeSomeValue2</span>();    <span class="hljs-comment">//现在是static</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> divisor =                       <span class="hljs-comment">//现在是static</span><br>    <span class="hljs-built_in">computeDivisor</span>(calc1, calc2);<br><br>    filters.<span class="hljs-built_in">emplace_back</span>(<br>        [=](<span class="hljs-type">int</span> value)                          <span class="hljs-comment">//什么也没捕获到！</span><br>        &#123; <span class="hljs-keyword">return</span> value % divisor == <span class="hljs-number">0</span>; &#125;        <span class="hljs-comment">//引用上面的static</span><br>    );<br><br>    ++divisor;                                  <span class="hljs-comment">//调整divisor</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还记得上面提到的一个 Lambda 表达值中 capture 子句的一个限制吗？<font color=red>捕获只能应用与 lambda 被创建时所在作用域内的 “non-static” 局部变量（包括形参）</font>。那么在这个例子中，如果开发者对这个限制不了解，那么可能会错误地理解此处 Lambda 体中对 divisor 变量的使用是基于按值捕获的，也就会错误地认为在 Lambda 体中，divisor 变量始终为初始化的值。</p><p><mark>正确的解释应该是这样。divisor 被声明为 static 类型，因此在 Lambda 体中不需要捕获该变量，即可直接引用。这也就意味着这个被添加的闭包依赖了外部的 divisor，所有的闭包会随着外部 divisor 的变化而变化。所以，这个闭包根本不是独立的！</mark></p><p>我们再回顾一下上面 Widget 的例子，通过默认捕获模式捕获 this 指针，然后在 lambda 中访问类的数据成员，就目前来看没有任何问题。但是其中隐含了一个依赖生命周期的问题。还是《Effective Modern C++》中的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomeWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> pw =                               <span class="hljs-comment">//创建Widget；std::make_unique</span><br>        std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;();         <span class="hljs-comment">//见条款21</span><br><br>    pw-&gt;<span class="hljs-built_in">addFilter</span>();                        <span class="hljs-comment">//添加使用Widget::divisor的过滤器</span><br><br>    …<br>&#125;                                           <span class="hljs-comment">//销毁Widget；filters现在持有悬空指针！</span><br></code></pre></td></tr></table></figure><p>在调用 <code>doSomeWork()</code> 时，通过 <code>std::make_unique</code> 构建了一个 Widget 的对象，并且该对象向全局的 filters 中添加了一个过滤器。但是该过滤器中依赖了 Widget 对象的 this 指针，因为在默认捕获模式下访问了对象的数据成员 divisor。但是在函数 <code>doSomeWork()</code> 结束时，基于智能指针 <code>std::unique_ptr</code> 的特性，Widget 对象将自动析构，这意味着 this 指针也将被销毁。但是我们在全局的 filters 中仍然保存一个依赖于 this 指针的过滤器，尽管这个指针已经悬空！</p><p>简单总结一下《Effective Modern C++》中条款31中对 Lambda 捕获变量过程中存在的限制和隐患：</p><ol><li>捕获只能应用与 lambda 被创建时所在作用域内的 “non-static” 局部变量（包括形参）。</li><li>静态存储生命周期的对象，这些对象定义在全局空间或者命名空间，或者在类、函数、文件中被声明为 <code>static</code> ，这些变量无法被 lambda捕获，但可以直接使用</li><li>无论是按值捕获，还是按引用捕获，都存在依赖生命周期的问题。其中按引用捕获可能会导致悬空引用，而按值捕获则对悬空指针很敏感（尤其是 this 指针），并且容易误导开发者产生 lambda 是独立的想法。</li></ol><p>基于上面的几点，《Effective Modern C++》建议尽可能避免使用默认捕获模式，显式地指定期望被捕获的变量可能是个更好的选择。</p><h3 id="条款32：使用初始化捕获来移动对象到闭包中"><a href="#条款32：使用初始化捕获来移动对象到闭包中" class="headerlink" title="条款32：使用初始化捕获来移动对象到闭包中"></a>条款32：使用初始化捕获来移动对象到闭包中</h3><p>Item 32: Use init capture to move objects into closures</p><p>根据作者的表述，C++14标准中增加“初始化捕获”的初衷，是为了解决C++11中无法移动捕获的缺陷，但是移动捕获只是该捕获机制中的一中执行技术。</p><p>为什么初始化捕获可以执行移动捕获？本质上是因为下面两点特性：</p><ol><li>可以指定从 lambda 生成的闭包类中的数据成员的名称；</li><li>可以指定初始化该成员的表达式；</li></ol><p>因此可以通过移动语句的表达式完成对成员的初始化，从而实现移动捕获。下面简单介绍一下在C++14标准下通过初始化捕获将特定内容移动到闭包的方法，以及C++11实现近似移动捕获的方法。</p><p>其实在C++14中，这显得非常简单，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;                          <span class="hljs-comment">//一些有用的类型</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidated</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isProcessed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isArchived</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    …<br>&#125;;<br><br><span class="hljs-keyword">auto</span> pw = std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;();   <span class="hljs-comment">//创建Widget；使用std::make_unique</span><br>                                        <span class="hljs-comment">//的有关信息参见条款21</span><br><br>…                                       <span class="hljs-comment">//设置*pw</span><br><br><span class="hljs-keyword">auto</span> func1 = [pw = std::<span class="hljs-built_in">move</span>(pw)]        <span class="hljs-comment">//使用std::move(pw)初始化闭包数据成员</span><br>            &#123; <span class="hljs-keyword">return</span> pw-&gt;<span class="hljs-built_in">isValidated</span>()<br>                     &amp;&amp; pw-&gt;<span class="hljs-built_in">isArchived</span>(); &#125;;<br><br></code></pre></td></tr></table></figure><p>在 capture 子句中，“&#x3D;” 的左侧是指定的数据成员，右侧则是初始化表达式。这里就是通过初始化捕获的方式，将一个 <code>std::unique_ptr</code> 移动到了闭包类中。关于“&#x3D;”左右两侧的作用域，我想应该不必多说，左侧既然是闭包类的数据成员，那么其作用域必然仅仅在闭包类之内，而右侧则是一个外部变量，那么其作用域必然和当前的 lambda 享有同样的作用域。</p><p>倘若上述例子中，不需要要设置 *pw 那么可以再度简化 lambda 的捕获语句，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> func1 = [pw = std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;()]<br>            &#123; <span class="hljs-keyword">return</span> pw-&gt;<span class="hljs-built_in">isValidated</span>()<br>                     &amp;&amp; pw-&gt;<span class="hljs-built_in">isArchived</span>(); &#125;;<br></code></pre></td></tr></table></figure><p>因此，在C++14标准下，通过初始化捕获模式完成移动捕获是一件非常简单和便捷的事。但是这并不代表在C++11标准下，移动捕获是不可实现的。</p><p>对于在C++11下实现移动捕获，《Effective Modern C++》中给出了两种方式来模拟初始化捕获。</p><p>第一种，手写“闭包类”。<font color=red>Lambda 表达式只是生成一个类和创建该类型对象的一种简单方式</font>，因此通过手写实现这个类，同样可以模拟实现初始化捕获。直接看例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IsValAndArch</span> &#123;                            <span class="hljs-comment">//“is validated and archived”</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = std::unique_ptr&lt;Widget&gt;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">IsValAndArch</span><span class="hljs-params">(DataType&amp;&amp; ptr)</span>       <span class="hljs-comment">//条款25解释了std::move的使用</span></span><br><span class="hljs-function">    : pw(std::move(ptr)) &#123;</span>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> pw-&gt;<span class="hljs-built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="hljs-built_in">isArchived</span>(); &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    DataType pw;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> func2 = <span class="hljs-built_in">IsValAndArch</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;()); <span class="hljs-comment">// func 的真实类型是什么？ IsValAndArch</span><br></code></pre></td></tr></table></figure><p>通过将构造函数的参数设置为右值引用类型，通过 <code>std::move</code> 完成对数据成员 pw 的初始化。并通过重载括号运算符 <code>()</code> ，使对象可以通过 <code>()</code> 直接获取 Widget 对象 pw 的状态。虽然此处 func2 的使用方式和上文中的 func1 看起来一致，都形如 <code>func()</code>，但是两个 func 在本质上存在着差异，func1 实际为一个闭包对象，可以通过 <code>std::function</code> 进行包装，而 fun2 本质上只是普通类 IsValAndArch 的一个实例对象而已！</p><p>第二种模拟初始化捕获的方式，则是使用 <code>std::bind</code>：</p><ol><li>将要捕获的对象移动到由 <code>std::bind</code> 产生的函数对象中；</li><li>将“被捕获的”对象的引用赋予给 lambda 表达式。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">double</span>&gt; data;               <span class="hljs-comment">//要移动进闭包的对象</span><br><br>…                                       <span class="hljs-comment">//填充data</span><br><br><span class="hljs-keyword">auto</span> func = [data = std::<span class="hljs-built_in">move</span>(data)]    <span class="hljs-comment">//C++14初始化捕获</span><br>            &#123; <span class="hljs-comment">/*使用data*/</span> &#125;;<br><br><span class="hljs-keyword">auto</span> func_cpp11 =<br>    std::<span class="hljs-built_in">bind</span>(                              <span class="hljs-comment">//C++11模拟初始化捕获</span><br>        [](<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data) <span class="hljs-comment">//译者注：本行高亮</span><br>        &#123; <span class="hljs-comment">/*使用data*/</span> &#125;,<br>        std::<span class="hljs-built_in">move</span>(data)                     <span class="hljs-comment">//译者注：本行高亮</span><br>    );<br><br></code></pre></td></tr></table></figure>当然上面两个func不能写到同一处，因为在初始化捕获时，data已经将其内容移动到 func 这个闭包对象的数据成员 data 中了，在 func_cpp11 中再次进行 move 自然是无效移动了。</li></ol><p><font color=red>在默认情况下，从 lambda 生成的闭包类中的 operator() 成员函数为 const 的，这能将闭包中的所有数据成员渲染为 const 的效果</font>。<mark>而 std::bind 对象内部的移动构造的 data 副本不是 const的</mark>，因此为了避免 lambda 内部对该副本产生修改，此处形参声明为 reference-to-const 是必要的。</p><p>下面是《Effective Modern C++》中对此节内容的总结，一起看一下：</p><ul><li>无法移动构造一个对象到C++11闭包，但是可以将对象移动构造进C++11的bind对象。</li><li>在C++11中模拟移动捕获包括将对象移动构造进bind对象，然后通过传引用将移动构造的对象传递给lambda。</li><li>由于bind对象的生命周期与闭包对象的生命周期相同，因此可以将bind对象中的对象视为闭包中的对象。</li></ul><h3 id="条款33：对auto-amp-amp-形参使用decltype用以std-forward（完美转发）它们"><a href="#条款33：对auto-amp-amp-形参使用decltype用以std-forward（完美转发）它们" class="headerlink" title="条款33：对auto&amp;&amp;形参使用decltype用以std::forward（完美转发）它们"></a>条款33：对auto&amp;&amp;形参使用decltype用以std::forward（完美转发）它们</h3><p>Item 33: Use decltype on auto&amp;&amp; parameters to std::forward them</p><blockquote><p>由于完美转发掌握的有限，后续在进行补充</p></blockquote><h3 id="条款34：考虑lambda而非std-bind"><a href="#条款34：考虑lambda而非std-bind" class="headerlink" title="条款34：考虑lambda而非std::bind"></a>条款34：考虑lambda而非std::bind</h3><p>Item 34: Prefer lambdas to std::bind</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">C++ 中的 Lambda 表达式（https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170）</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://c.biancheng.net/view/3741.html">C++11 lambda表达式精讲（http://c.biancheng.net/view/3741.html）</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>lambda</tag>
      
      <tag>Linux编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unraid下虚拟DSM7.1，并开启相册人脸识别</title>
    <link href="/2023/02/17/Unraid%E4%B8%8B%E8%99%9A%E6%8B%9FDSM7-1%EF%BC%8C%E5%B9%B6%E5%BC%80%E5%90%AF%E7%9B%B8%E5%86%8C%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <url>/2023/02/17/Unraid%E4%B8%8B%E8%99%9A%E6%8B%9FDSM7-1%EF%BC%8C%E5%B9%B6%E5%BC%80%E5%90%AF%E7%9B%B8%E5%86%8C%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Unraid下虚拟DSM7-1，并开启相册人脸识别"><a href="#Unraid下虚拟DSM7-1，并开启相册人脸识别" class="headerlink" title="Unraid下虚拟DSM7.1，并开启相册人脸识别"></a>Unraid下虚拟DSM7.1，并开启相册人脸识别</h1><p><strong><font color="red">风险提示！！！请勿直接应用于生产环境或者单一数据存储环境，当前仅为测试版本！！！数据无价，请务必做好数据备份！！！</font></strong></p><p><strong><font color="red">风险提示！！！请勿直接应用于生产环境或者单一数据存储环境，当前仅为测试版本！！！数据无价，请务必做好数据备份！！！</font></strong></p><p><strong><font color="red">风险提示！！！请勿直接应用于生产环境或者单一数据存储环境，当前仅为测试版本！！！数据无价，请务必做好数据备份！！！</font></strong></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>由于主机换新，之前的旧设备闲置也是闲置，于是参考 <a href="https://space.bilibili.com/28457/">Unraid 教父——司波图</a>一系列教程搭建了一台 Unraid 系统的 NAS。之前四盘位的 J3455 蜗牛星际也快满了，并且性能远远低于换代下来的 i5 8500，正好将内容迁移到 Unraid 上。但是群晖的相册套件说实话简单上手好用，还自带人脸识别，所以还是打算在 Unraid 上虚拟一个黑群晖，专门用于相册的备份和维护。废话不多说，下面开始干货。</p><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><table><thead><tr><th align="left"></th><th align="right"></th></tr></thead><tbody><tr><td align="left">sys</td><td align="right">Unraid 6.10.3</td></tr><tr><td align="left">cpu</td><td align="right">Intel® Core™ i5-8500 CPU @ 3.00GHz</td></tr><tr><td align="left">主板</td><td align="right">Gigabyte Technology Co., Ltd. B360M AORUS Gaming 3-CF</td></tr><tr><td align="left">内存</td><td align="right">DDR4 -  24G 普条</td></tr><tr><td align="left">硬盘</td><td align="right">希捷 ST18000NM013J_ZR56YQB9 - 18 TB<br />西数 SN570 -1TB</td></tr></tbody></table><p>基本配置如上，其中西数的 SN570 作为 cache 使用，无校验盘。“亡命之徒”本徒了。</p><p><strong><font color="red">注意：如果需要添加校验盘，则校验盘容量必须大于等于阵列中单硬盘最大容量，以上配置就需要一个 18T 的硬盘作为校验盘。没有校验盘时，重要资料务必多地备份！</font></strong></p><h2 id="三、准备事项"><a href="#三、准备事项" class="headerlink" title="三、准备事项"></a>三、准备事项</h2><p><strong>以下内容都是基于 DSM918+ 7.1.0 展开，其余设备型号或者版本因精力有限未做尝试！</strong></p><ol><li>准备一个 tinycore-redpill 的基础镜像（tinycore-redpill-uefi.v0.8.0.0.img）：<a href="https://github.com/pocopico/tinycore-redpill">https://github.com/pocopico/tinycore-redpill</a></li><li>准备 DSM918+ 7.1.0patch 文件：<a href="https://cndl.synology.cn/download/DSM/release/7.1/42661-1/DSM_DS918%2B_42661.pat">https://cndl.synology.cn/download/DSM/release/7.1/42661-1/DSM_DS918%2B_42661.pat</a></li><li>主板 bios 打开核显（安装过程中发现，核显被设置为自动，当有独显时，核显默认不开，会导致 Unraid 无法获取核显信息，<strong>Intel GVT-g</strong> 插件无法使用）</li><li>ssh 工具，如 xshell，putty，MobaXterm 等</li></ol><h2 id="四、创建虚拟-DSM-流程"><a href="#四、创建虚拟-DSM-流程" class="headerlink" title="四、创建虚拟 DSM 流程"></a>四、创建虚拟 DSM 流程</h2><p><mark><font color="red">再次提醒！！！务必做好数据备份，在无需担心数据损失的前提下进行以下操作！！！</font></mark></p><p><mark><font color="red">再次提醒！！！务必做好数据备份，在无需担心数据损失的前提下进行以下操作！！！</font></mark></p><p><mark><font color="red">再次提醒！！！务必做好数据备份，在无需担心数据损失的前提下进行以下操作！！！</font></mark></p><h3 id="1、创建虚拟机"><a href="#1、创建虚拟机" class="headerlink" title="1、创建虚拟机"></a>1、创建虚拟机</h3><p>创建虚拟机的基本步骤请参考——<a href="https://www.bilibili.com/video/BV1R7411s7gP?spm_id_from=333.999.0.0">unRaid 下黑群晖，Freenas，OMV 的安装方法——司波图 UNRAID 陪玩教程 05</a>。</p><p>最新的创建参数和大佬的有些差别：</p><ol><li>Machine：Q35-6.2</li><li>BIOS：OVMF（tinycore 选择 UEFI 镜像）</li><li>USB Controller：3.0(qemu XHCI)</li><li>Primary vDisk 选择我们事先拷贝到 isos 目录下的镜像文件（tinycore-redpill-uefi.v0.8.0.0.img），并选择 USB 模式</li><li>添加第二块 vDisk，此处设置为 sata 模式，其余按需设置即可</li><li>网卡设置为 e1000</li><li>取消勾选“Start VM after creation”</li></ol><p>此时已基本完成虚拟机相关设置，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/180962087-4ce99534-f44e-4cf7-bb9e-26dc5148f248.png"></p><p>创建后，重新编辑虚拟机，打开 xml 模式，修改以下红框内划线处 <code>controller = &quot;0&quot;</code> 为 <code>controller = &quot;1&quot;</code>。</p><p><img src="https://user-images.githubusercontent.com/35327600/180955218-2dc76d15-879c-4f12-b029-1f90cf0ca5b8.png"></p><p>本人在尝试了无数次卡重新安装 pat 的死循环后，最终在 xp 论坛上找到了解决方案。就是这个 sata disk 的 controller 索引错误导致无法找到 sata 磁盘控制信息，从而卡在安装 pat 文件错误的死循环中。原贴链接：<a href="https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607">https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607</a></p><p>整体安装 DSM 的流程也可参考原贴。</p><h3 id="2、创建完整引导镜像"><a href="#2、创建完整引导镜像" class="headerlink" title="2、创建完整引导镜像"></a>2、创建完整引导镜像</h3><ol><li><p>开启虚拟机，并开启 VNC，看到如下界面：</p><p><img src="https://user-images.githubusercontent.com/35327600/180959772-e0ea5062-238d-4e65-a9f0-db37e77e379e.png"></p><p>按照图片中描述操作，获取当前虚拟机 ip 地址</p></li><li><p>通过 ssh 工具进行连接虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh tc@192.168.2.191<br>&lt;输入密码：P@ssw0rd&gt;<br><br>Connecting to 192.168.2.191:22...<br>Connection established.<br>To escape to local shell, press &#x27;Ctrl+Alt+]&#x27;.<br><br>WARNING! The remote SSH server rejected X11 forwarding request.<br>   ( &#x27;&gt;&#x27;)<br>  /) TC (\   Core is distributed with ABSOLUTELY NO WARRANTY.<br> (/-_--_-\)           www.tinycorelinux.net<br><br>tc@box:~$ <br></code></pre></td></tr></table></figure></li><li><p>依次无脑执行以下命令，命令执行过程中会有部分内容需要手动确定，有 yY 输 y，无 yY 直接回车</p><ul><li><code>./rploader.sh update now</code></li><li><code>./rploader.sh fullupgrade now</code></li><li><code>./rploader.sh serialgen DS918+</code></li><li><code>./rploader.sh satamap now</code></li><li><code>./rploader.sh identifyusb now</code></li><li><code>./rploader.sh ext apollolake-7.1.0-42661 add https://raw.githubusercontent.com/pocopico/rp-ext/master/e1000/rpext-index.json</code></li><li><code>./rploader.sh build apollolake-7.1.0-42661</code></li></ul><p>执行最后一个命令时，可能会有红色日志提示，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[!] Extension is already added (index exists at /home/tc/redpill-load/custom/extensions/pocopico.e1000/pocopico.e1000.json). For more info use &quot;ext-manager.sh info pocopico.e1000&quot;<br>*** Process will exit ***<br></code></pre></td></tr></table></figure><p>该提示目前使用下来无影响，出现如下打印，表示镜像构建成功：</p><p><img src="https://user-images.githubusercontent.com/35327600/180965299-4c8231d4-a541-4275-b167-0ba521330ab8.png"></p></li><li><p>关闭虚拟机，打开 xml 编辑，查看之前修改的 <code>controller = &quot;1&quot;</code> 是否又变回默认值 <code>&quot;0&quot;</code>。如果发生改变，请再一次手动更改为 <code>&quot;1&quot;</code>，否则将无法正确安装 pat 文件。</p></li></ol><h3 id="3、创建-DSM7-1"><a href="#3、创建-DSM7-1" class="headerlink" title="3、创建 DSM7.1"></a>3、创建 DSM7.1</h3><p>启动虚拟机，并在 VNC 中手动选择 USB 引导。（起始界面还有一个 SATA 引导，未进行测试，喜欢折腾可以试试）</p><p>后续就和常规安装群晖一样，使用浏览器访问 <a href="https://finds.synology.com/%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%96%B0%E5%AE%89%E8%A3%85%E7%9A%84">https://finds.synology.com/，获取新安装的</a> DSM 信息，上传 pat 文件进行安装。</p><p><img src="https://user-images.githubusercontent.com/35327600/180968642-5e580051-e9a7-4e82-be03-267eadf2e1b0.png"></p><p>恭喜，DSM 7.1 至此已完成完整的安装！接下来的基本操作就不在赘述了，按照指引正常处理就行。</p><h2 id="五、开启相册人脸识别"><a href="#五、开启相册人脸识别" class="headerlink" title="五、开启相册人脸识别"></a>五、开启相册人脸识别</h2><p>按照上述流程创建的群晖是无法开启相册套件中的人脸识别功能，因为核显没有直通给群晖，导致群晖无法调用核显进行人脸识别。我们需要借助“<strong>Intel GVT-g</strong>”插件虚拟化核显，并配置给我们的群晖虚拟机。</p><ol><li><p>配置好群晖后，关闭虚拟机</p></li><li><p>在 Unraid APP 市场中安装插件 <strong>Intel GVT-g</strong></p></li><li><p>在 PLUGINS 界面中打开 <strong>Intel GVT-g</strong> 配置</p></li><li><p>根据当前虚拟显存的模式，分配给群晖虚拟机，确定后点击 “ASSIGN VM”</p><p><img src="https://user-images.githubusercontent.com/35327600/180971454-d802c4c7-6050-452f-b954-d1bc4e8a3375.png"></p></li><li><p>回到虚拟机的 xml 配置进行修改，安装时的 <code>controller = &quot;1&quot;</code> 还是需要注意的地方。其余部分按下图进行修改：</p><p><img src="https://user-images.githubusercontent.com/35327600/180977569-0c9566b4-8ab8-4232-89d8-a39959387c5a.png"></p><p>找到 xml 中新增的 &lt;hostdev&gt;，将其中的 <code>bus = &#39;0x01&#39; slot=&#39;0x00&#39;</code> 修改为 <code>bus = &#39;0x00&#39; slot=&#39;0x02&#39;</code>，这是因为虚拟化后核显的地址默认为 <code>0000:00:02.0</code></p><p>由于我们将虚拟化核显的总线（bus）和设备号（slot）修改了，和 xml 中部分原有配置产生冲突，因此需要将其余 <code>bus = &#39;0x00&#39; slot=&#39;0x02&#39;</code> 所在的行删除，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/180977611-5185c30b-d8d6-43d6-94c8-b6dfc9714bfd.png"></p></li><li><p>修改完成后，重启群晖虚拟机，在 <code>控制面板-&gt;终端机和SNMP</code> 中打开 ssh 功能。使用 ssh 工具进行连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">输入：ls /dev/dri<br>显示：card0  renderD128<br></code></pre></td></tr></table></figure></li></ol><p>如果能正常显示上述内容，如果不是设备特殊，此时应该已经能进行人脸识别，我们测试一下</p><h2 id="六、人脸识别功能测试"><a href="#六、人脸识别功能测试" class="headerlink" title="六、人脸识别功能测试"></a>六、人脸识别功能测试</h2><p>在套件中心搜索关键词“photo”，下载安装完成后打开，点击右上角用户图标，在设置中“启用个人空间人物相册”</p><p><img src="https://user-images.githubusercontent.com/35327600/180982129-913020e6-c84d-4f68-9292-c982bc34b2c2.png"></p><p>找几张图上传，等一段时间后，查看一下人物相册，是否根据人脸识别自动创建了对应的相册，如果正确创建了，那么恭喜！</p><p><img src="https://user-images.githubusercontent.com/35327600/181008438-89e5df3b-ec6e-4bad-ab56-56d63161810a.png"></p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li>pocopico 大佬的 github：<a href="https://github.com/pocopico/tinycore-redpill">https://github.com/pocopico/tinycore-redpill</a></li><li>xpenology 论坛：<a href="https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607">https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607</a></li><li>Jinlife 大佬博客：<a href="https://blog.jinlife.com/index.php/archives/49/">https://blog.jinlife.com/index.php/archives/49/</a></li><li>张大妈：<a href="https://post.smzdm.com/p/a5dl2808/">https://post.smzdm.com/p/a5dl2808/</a></li><li>司波图 B 站教程视频：<a href="https://space.bilibili.com/28457/channel/seriesdetail?sid=896368">https://space.bilibili.com/28457/channel/seriesdetail?sid=896368</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>DSM7.1</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
