<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Emby Notifier 项目说明</title>
    <link href="/2024/04/29/Emby%20Notifier%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/"/>
    <url>/2024/04/29/Emby%20Notifier%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="Emby-Notifier"><a href="#Emby-Notifier" class="headerlink" title="Emby Notifier"></a>Emby Notifier</h1><blockquote><p>这是另一个项目 <a href="https://github.com/Ccccx159/watchdog_for_Emby/tree/main">watchdog_for_Emby</a> 的最新优化版本，取消了 nfo 文件的监视依赖，该版本不再需要手动设置媒体库路径，对通过网盘挂载生成的媒体库更加友好~</p></blockquote><h2 id="Emby-Server-版本-重要！！！"><a href="#Emby-Server-版本-重要！！！" class="headerlink" title="Emby Server 版本 (重要！！！)"></a>Emby Server 版本 (重要！！！)</h2><p><font color=red><strong>4.8.0.80 及更新版本的 Emby Server！！！</strong></font></p><p>本项目是基于 Emby Server 官方插件 Webhooks 实现的，在 4.8.0.80 版本以前需要激活 Emby Premiere 才能使用 Webhooks 插件。</p><p>在 4.8.0.80 版本，Webhooks 被集成到控制台 “通知” 功能中，免费用户也可使用，因此建议使用本项目的朋友更新 Emby Server 到指定版本。</p><p><mark>需要注意的是，群晖套件中心的 Emby Server 最新在线版本为 4.7.14.0，因此需要 Emby 官方网站下载相应平台的安装包进行手动安装。</mark></p><h2 id="修订版本"><a href="#修订版本" class="headerlink" title="修订版本"></a>修订版本</h2><table><thead><tr><th>版本</th><th>日期</th><th>修订说明</th></tr></thead><tbody><tr><td>v1.0.0</td><td>2024.04.29</td><td><li>新增项目</li></td></tr></tbody></table><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Emby Notifier</strong> 是一个基于 Emby Server Webhooks 实现的自动通知工具。Emby Server 通过 Webhooks 插件，可以在影片刮削完成后，自动推送事件到指定的 URL。本项目通过监听 Emby Server 推送的 Webhooks 事件，获取影片的基本信息，通过 TMDB 的 API 查询影片的详细信息，然后通过 Telegram Bot 推送至指定频道。</p><h2 id="环境变量和服务端口"><a href="#环境变量和服务端口" class="headerlink" title="环境变量和服务端口"></a>环境变量和服务端口</h2><p>端口：8000</p><table><thead><tr><th>参数</th><th>要求</th><th>说明</th></tr></thead><tbody><tr><td>TMDB_API_TOKEN</td><td>必须</td><td>Your TMDB API Token</td></tr><tr><td>TVDB_API_KEY</td><td>必须</td><td>Your TVDB API Key</td></tr><tr><td>TG_BOT_TOKEN</td><td>必须</td><td>Your Telegram Bot Tokne</td></tr><tr><td>TG_CHAT_ID</td><td>必须</td><td>Your Telegram Channel’s Chat ID</td></tr><tr><td>LOG_LEVEL</td><td>可选</td><td>日志等级 [DEBUG, INFO, WARNING] 三个等级，默认 WARNING</td></tr><tr><td>LOG_EXPORT</td><td>可选</td><td>日志写文件标志 [True, False] 是否将日志输出到文件，默认 False</td></tr><tr><td>LOG_PATH</td><td>可选</td><td>日志文件保存路径，默认 &#x2F;var&#x2F;tmp&#x2F;emby_notifier_tg</td></tr></tbody></table><h2 id="docker-Run"><a href="#docker-Run" class="headerlink" title="docker Run"></a>docker Run</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=emby-notifier-tg --restart=unless-stopped \<br>    -e TMDB_API_TOKEN=Your_TMDB_API_Token \<br>    -e TVDB_API_KEY=Your_TVDB_API_Key \<br>    -e TG_BOT_TOKEN=Your_Telegram_Bot_Token \<br>    -e TG_CHAT_ID=Your_Telegram_Chat_ID \<br>    -p 8000:8000 \<br>    b1gfac3c4t/emby_notifier_tg:latest<br>  <br></code></pre></td></tr></table></figure><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">emby_notifier_tg:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">.</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">dockerfile</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">b1gfac3c4t/emby_notifier_tg:latest</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>      <span class="hljs-comment"># 这里所有的环境变量都不要使用引号</span><br>      <span class="hljs-comment"># 必填参数</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TMDB_API_TOKEN=&lt;Your</span> <span class="hljs-string">TMDB</span> <span class="hljs-string">API</span> <span class="hljs-string">Token&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TVDB_API_KEY=&lt;Your</span> <span class="hljs-string">TVDB</span> <span class="hljs-string">API</span> <span class="hljs-string">Key&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TG_BOT_TOKEN=&lt;Your</span> <span class="hljs-string">Telegram</span> <span class="hljs-string">Bot</span> <span class="hljs-string">Tokne&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TG_CHAT_ID=&lt;Your</span> <span class="hljs-string">Telegram</span> <span class="hljs-string">Channel&#x27;s</span> <span class="hljs-string">Chat</span> <span class="hljs-string">ID&gt;</span><br>      <span class="hljs-comment"># 可选参数</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LOG_LEVEL=WARNING</span> <span class="hljs-comment"># [DEBUG, INFO, WARNING] 三个等级，默认 WARNING</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LOG_EXPORT=False</span> <span class="hljs-comment"># [True, False0] 是否将日志输出到文件，默认 False</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LOG_PATH=/var/tmp/emby_notifier_tg/</span> <span class="hljs-comment"># 默认 /var/tmp/emby_notifier_tg/</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;bridge&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8000:8000&quot;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="Emby-Server-设置"><a href="#Emby-Server-设置" class="headerlink" title="Emby Server 设置"></a>Emby Server 设置</h2><ol><li><p>打开 Emby Server 控制台，点击左侧菜单栏的 “设置” -&gt; “通知” -&gt; “添加 Webhooks”</p><p> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/emby-telegram-notification/-/raw/main/doc/%E6%B7%BB%E5%8A%A0%E9%80%9A%E7%9F%A5.png" alt="添加通知"></p><p> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/emby-telegram-notification/-/raw/main/doc/%E6%B7%BB%E5%8A%A0webhooks.png" alt="添加Webhooks"></p></li><li><p>在弹出的对话框中，填写 Webhooks 的 URL，例如：<code>http://192.168.1.100:8000</code>，选择数据类型为 <code>application/json</code></p><p> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/emby-telegram-notification/-/raw/main/doc/%E9%85%8D%E7%BD%AEnotifier.png" alt="配置Webhooks"></p></li><li><p>点击 “发送测试通知” 按钮，观察 Notifier 的日志输出，如果输出了测试通知的信息，说明 Webhooks 设置成功</p><p> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/emby-telegram-notification/-/raw/main/doc/%E6%8E%A5%E5%8F%97%E6%B5%8B%E8%AF%95%E6%B6%88%E6%81%AF.png" alt="接收测试事件通知"></p><p> Notifier 日志中出现以下信息，说明 Webhooks 设置成功</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[WARNING] : Unsupported event type: system.notificationtest<br></code></pre></td></tr></table></figure></li><li><p>选择通知事件：媒体库 -&gt; 新媒体已添加，点击保存</p><p> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/emby-telegram-notification/-/raw/main/doc/%E9%80%89%E6%8B%A9%E4%BA%8B%E4%BB%B6.png" alt="选择通知事件"></p></li></ol><h2 id="媒体信息检索流程"><a href="#媒体信息检索流程" class="headerlink" title="媒体信息检索流程"></a>媒体信息检索流程</h2><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/emby-telegram-notification/-/raw/main/doc/Emby_Notifier.drawio.png"></p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>Emby Server 的新媒体添加事件的触发时机受限于对新增文件的监视方式和扫描媒体库的频率，如果 Emby Server 触发新媒体添加事件，则 Notifier 也就无法推送通知。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>电影：</p><p><img src="https://user-images.githubusercontent.com/35327600/209752390-4e45180b-d8cc-4378-bd98-c489638f7cb7.png"></p><p>剧集：</p><p><img src="https://user-images.githubusercontent.com/35327600/209752275-bad230b0-97a7-47e5-9a77-081afae7d6cf.png"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li>tmdb api 文档：<a href="https://developers.themoviedb.org/3">https://developers.themoviedb.org/3</a></li><li>telegram bot api 文档：<a href="https://core.telegram.org/bots/api">https://core.telegram.org/bots/api</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Emby</tag>
      
      <tag>Notification</tag>
      
      <tag>Webhook</tag>
      
      <tag>Telegram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个“size_type”引发的Bug</title>
    <link href="/2024/04/25/ELF%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%A2%AB%E8%AF%86%E5%88%AB%E4%B8%BA%E5%85%B1%E4%BA%AB%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/"/>
    <url>/2024/04/25/ELF%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%A2%AB%E8%AF%86%E5%88%AB%E4%B8%BA%E5%85%B1%E4%BA%AB%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="ELF-可执行文件被识别为共享目标文件"><a href="#ELF-可执行文件被识别为共享目标文件" class="headerlink" title="ELF 可执行文件被识别为共享目标文件"></a>ELF 可执行文件被识别为共享目标文件</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>个人项目中有一个解析 ELF 文件类型的功能，在测试过程中，错误地将可执行文件 (ET_EXEC) 识别为共享目标文件 (ET_DYN)。</p><p>如下图所示，exec_test 必然是一个可执行文件：</p><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/43dad8fbc3f5c70f79ab0c2d3724eefe/2024-04-25_155005.png"></p><p>但是当我无论使用 <code>readelf -h</code> 查看 exec_test 的头部信息，还是使用 <code>file</code> 命令查看文件类型，都显示这是一个共享目标文件：</p><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/371fe11454fc9e9404b2ee5e147c24a7/2024-04-25_155806.png"></p><p>通过上面第一张图片中的编译指令，可以看到仅仅使用了最常规的 <code>-g -O0 -o</code> 选项，并没有使用额外的编译或者链接选项。</p><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul><li>OS: Ubuntu 20.04.6 LTS x86_64</li><li>Compiler: g++ (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0</li></ul><h2 id="ELF-文件简单介绍"><a href="#ELF-文件简单介绍" class="headerlink" title="ELF 文件简单介绍"></a>ELF 文件简单介绍</h2><p>一般来说，ELF 文件有 4 种：</p><ul><li>可重定位文件 (ET_REL)</li><li>可执行文件 (ET_EXEC)</li><li>共享目标文件 (ET_DYN)</li><li>核心转储文件 (ET_CORE)</li></ul><table><thead><tr><th align="left">文件类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">可重定位文件 (ET_REL)</td><td align="left"><li>待重定位文件是由编译器产生的中间文件，包含了程序的机器代码、符号表、重定位信息等。</li><li>它是源代码编译后生成的目标文件，但还没有链接成可执行文件或共享目标文件。</li><li>待重定位文件中的地址信息仍然是相对地址，需要在链接时进行地址重定位。</li></td></tr><tr><td align="left">可执行文件 (ET_EXEC)</td><td align="left"><li>可执行文件包含了可以直接在操作系统上运行的程序代码和数据。</li><li>它可以被操作系统加载到内存中，并执行其中的指令。</li><li>在Unix&#x2F;Linux系统中，可执行文件通常没有文件扩展名，但是在Windows系统中通常使用 .exe 扩展名。</li></td></tr><tr><td align="left">共享目标文件 (ET_DYN)</td><td align="left"><li>共享目标文件是包含了可重用代码和数据的文件，可以被多个可执行文件动态链接和共享使用。</li><li>它以一种与操作系统和其他程序共享的形式存在，可以在程序运行时动态加载到内存中。</li><li>共享目标文件通常具有文件扩展名 .so（Unix&#x2F;Linux）或 .dll（Windows）。</li></td></tr><tr><td align="left">核心转储文件 (ET_CORE)</td><td align="left"><li>Core 文件是在程序崩溃或异常退出时由操作系统自动生成的一种文件。</li><li>它包含了程序崩溃时的内存快照信息，包括堆栈信息、寄存器状态等。</li><li>Core 文件通常用于调试程序崩溃的原因，可以通过调试工具分析其内容以定位问题。</li></td></tr></tbody></table><p>也可见下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bab723b24d954cd39cf89370b95a1cdf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"></p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>在查找了资料后，得知是由于高版本 gcc&#x2F;g++ 默认使用 <code>-pie</code> 选项，导致生成的可执行文件被识别为共享目标文件。</p><p><code>-pie</code> 选项是 Position Independent Executable 的缩写，即生成位置无关可执行文件。这种可执行文件可以被加载到任意地址运行，而不需要进行地址重定位。这样可以提高程序的安全性，防止恶意程序利用地址重定位漏洞进行攻击。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决方法有两种：</p><ol><li>使用 <code>-no-pie</code> 选项，禁用生成位置无关可执行文件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -g -O0 -no-pie -o exec_test test.cc<br></code></pre></td></tr></table></figure><ol start="2"><li>使用 <code>-fno-pie</code> 选项，禁用生成位置无关可执行文件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ -g -O0 -fno-pie -o exec_test test.cc<br></code></pre></td></tr></table></figure><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/d79f24ba7a2a8e259a4011aad40cafb8/2024-04-25_163212.png"></p><p>可以看到，在添加了 <code>-no-pie</code> 选项后，exec_test 被正确识别为可执行文件。</p>]]></content>
    
    
    <categories>
      
      <category>踩坑日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>ELF</tag>
      
      <tag>gcc</tag>
      
      <tag>共享目标文件</tag>
      
      <tag>链接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19. 删除链表的倒数第 N 个结点</title>
    <link href="/2024/04/18/leetcode/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2024/04/18/leetcode/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：head = [1], n = 1<br>输出：[]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：head = [1,2], n = 1<br>输出：[1]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中结点的数目为 sz</li><li>1 &lt;&#x3D; sz &lt;&#x3D; 30</li><li>0 &lt;&#x3D; Node.val &lt;&#x3D; 100</li><li>1 &lt;&#x3D; n &lt;&#x3D; sz</li></ul><p>进阶：你能尝试使用一趟扫描实现吗？</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：遍历-哈希表"><a href="#解法一：遍历-哈希表" class="headerlink" title="解法一：遍历 + 哈希表"></a>解法一：遍历 + 哈希表</h3><p>常规思路，基于单链表的性质只能<strong>从头到尾</strong>逐个遍历，因此倒数第 n 个节点，首先需要知道一共有几个节点即链表长度 sz，然后找到倒数第 n 个节点前驱节点，即倒数第 n+1 个节点，才能删除倒数第 n 个节点。</p><p>因此，我们可以遍历一遍链表，并使用哈希表来存储节点索引和节点地址，最后索引为 sz - n 的节点即为倒数第 n 个节点的前驱节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>  std::unordered_map&lt;<span class="hljs-type">int</span>, ListNode*&gt; <span class="hljs-type">hash_t</span>;<br>  <span class="hljs-type">int</span> sz = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(head-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>    sz++;<br>    <span class="hljs-type">hash_t</span>[sz] = head;<br>    head = head-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-type">hash_t</span>.<span class="hljs-built_in">size</span>() - n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-type">hash_t</span>[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">hash_t</span>[<span class="hljs-type">hash_t</span>.<span class="hljs-built_in">size</span>() - n]-&gt;next = <span class="hljs-type">hash_t</span>[<span class="hljs-type">hash_t</span>.<span class="hljs-built_in">size</span>() - n]-&gt;next-&gt;next;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">hash_t</span>[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>当链表长度很长时，用于额外存储的哈希表也会占用较大一部分内存。</p><h3 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h3><p>双指针法，使用两个指针 <code>fast</code> 和 <code>slow</code>，<code>fast</code> 先走 n 步，然后 <code>fast</code> 和 <code>slow</code> 同时走，当 <code>fast</code> 走到链表尾部时，<code>slow</code> 指向的节点即为倒数第 n 个节点的前驱节点。</p><p>为了避免删除头结点的特殊情况，可以在头结点前加一个哑结点 dummy。这样无论删除的是头节点还是其余子节点，都可以用 <code>dummy-&gt;next</code> 统一表达。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>  ListNode _Dummy(<span class="hljs-number">0</span>, head);<br>  <span class="hljs-keyword">auto</span> slow = &amp;_Dummy, fast = &amp;_Dummy;<br>  <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;<br>    fast = fast-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">while</span>(fast-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>    slow = slow-&gt;next;<br>    fast = fast-&gt;next;<br>  &#125;<br>  slow-&gt;next = slow-&gt;next-&gt;next;<br>  <span class="hljs-keyword">return</span> _Dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>链表特性：只能从头到尾遍历，无法回溯；删除某个节点，需要找到待删除节点的前驱节点；</li><li>删除子节点和删除头节点的操作不一致，可使用增加一个虚假头节点进行统一处理，简化逻辑；</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>单链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18. 四数之和</title>
    <link href="/2024/04/17/leetcode/18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/04/17/leetcode/18.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按<strong>任意顺序</strong>返回答案 。</p><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：nums = [1,0,-1,0,-2,2], target = 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：nums = [2,2,2,2,2], target = 8<br>输出：[[2,2,2,2]]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</li><li>$-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9$</li><li>$-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序 + 双指针"></a>排序 + 双指针</h3><p>解题思路同 <a href="./15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.md">15. 三数之和</a>。</p><p>固定元素由 1 个变成 2 个，然后另外两个双指针和三数之和的解法一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] + nums[<span class="hljs-number">3</span>] &gt; target) <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">3</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (j &gt; i+<span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> m = j + <span class="hljs-number">1</span>, n = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> max_ = (<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[n] + nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span> min_ = (<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[m] + nums[m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (target &gt; max_) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; min_) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">while</span> (m &lt; n) &#123;<br>            <span class="hljs-type">long</span> sum = (<span class="hljs-type">long</span>)nums[i] + nums[j] + nums[m] + nums[n];<br>            <span class="hljs-keyword">if</span> (sum == target) &#123;<br>              res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[m], nums[n]&#125;);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sum &lt;= target) &#123;<br>              <span class="hljs-type">int</span> x = nums[m];<br>              <span class="hljs-keyword">while</span> (x == nums[++m] &amp;&amp; m &lt; n);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-type">int</span> x = nums[n];<br>              <span class="hljs-keyword">while</span> (x == nums[--n] &amp;&amp; m &lt; n);<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>元素最大值可能溢出，需要转换为 <code>long</code> 类型；</li><li>可计算当前 i 和 j 对应的最大值和最小值进行优化剪枝，提前结束循环；s’s’s</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>整数溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17. 电话号码的字母组合</title>
    <link href="/2024/04/17/leetcode/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2024/04/17/leetcode/17.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：digits = &quot;23&quot;<br>输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：digits = &quot;&quot;<br>输出：[]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：digits = &quot;2&quot;<br>输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; digits.length &lt;&#x3D; 4</li><li>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：迭代"><a href="#解法一：迭代" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h3><p>将问题转化为：每增加一个数字，就在之前的结果集中的每个字符串后面加上这个数字对应的字母。</p><p>例如 digits &#x3D; “23”：</p><ol><li>当 digits[0] &#x3D;&#x3D; ‘2’ 时，res &#x3D; [“a”, “b”, “c”]</li><li>当 digits[1] &#x3D;&#x3D; ‘3’ 时，向res中追加 “def”，得到新的 res’ &#x3D; [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(std::string digits)</span> </span>&#123;<br>    std::vector&lt;std::string&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> dig : digits) &#123;<br>      res = <span class="hljs-built_in">letComb</span>(dig, res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">letComb</span><span class="hljs-params">(<span class="hljs-type">char</span> dig,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  std::vector&lt;std::string&gt;&amp; last_res)</span> </span>&#123;<br>    std::vector&lt;std::string&gt; res;<br>    <span class="hljs-comment">// 遍历当前数字对应的字母</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : cell_map[dig]) &#123;<br>      <span class="hljs-comment">// 向上一次结果进行追加，并将追加结果填充到当前的新结果中</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> str : last_res) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(str + ch);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (last_res.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, ch));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br>  std::unordered_map&lt;<span class="hljs-type">char</span>, std::string&gt; cell_map = &#123;<br>      &#123;<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;edf&quot;</span>&#125;,  &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>      &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxzy&quot;</span>&#125;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：回溯"><a href="#解法二：回溯" class="headerlink" title="解法二：回溯"></a>解法二：回溯</h3><p>这是一个典型的<strong>回溯穷举问题</strong>。</p><p>每次递归时，将当前数字对应的字母依次加入到当前字符串中，当字符串长度等于 digits 时，将当前字符串加入到结果集中，然后回溯，将当前字符串的最后一个字符删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(std::string digits)</span> </span>&#123;<br>    std::vector&lt;std::string&gt; res;<br>    <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">letComb</span>(res, <span class="hljs-number">0</span>, digits);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<span class="hljs-function">s</span><br><span class="hljs-function">  <span class="hljs-type">int</span> <span class="hljs-title">letComb</span><span class="hljs-params">(std::vector&lt;std::string&gt;&amp; res, <span class="hljs-type">int</span> idx, std::string &amp; digits)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (idx == digits.<span class="hljs-built_in">size</span>()) &#123;<br>      res.<span class="hljs-built_in">push_back</span>(comb);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      std::string str = cell_map[digits[idx]];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : str) &#123;<br>        comb.<span class="hljs-built_in">push_back</span>(ch);<br>        <span class="hljs-built_in">letComb</span>(res, idx+<span class="hljs-number">1</span>, digits);<br>        comb.<span class="hljs-built_in">pop_back</span>();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  std::string comb;<br><br>  std::unordered_map&lt;<span class="hljs-type">char</span>, std::string&gt; cell_map = &#123;<br>      &#123;<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;edf&quot;</span>&#125;,  &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>&#125;,<br>      &#123;<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>&#125;, &#123;<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxzy&quot;</span>&#125;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>迭代法注意在遍历完当前 digits[i] 后，需更新原始结果集，在下一次 i+1 迭代中需要使用更新后的结果集进行追加字符；</li><li>回溯条件：idx &#x3D;&#x3D; digits.size()，将当前字符串加入到结果集中。</li><li>在将字符串加入结果集后进行回溯，即将字符串的最后一位删除，并加上下一个字符；</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16. 最接近的三数之和</title>
    <link href="/2024/04/17/leetcode/16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/04/17/leetcode/16.%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p><p>返回这三个数的和。</p><p>假定每组输入只存在恰好一个解。</p><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：nums = [-1,2,1,-4], target = 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：nums = [0,0,0], target = 1<br>输出：0<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>3 &lt;&#x3D; nums.length &lt;&#x3D; 1000</li><li>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li><li>-10^4 &lt;&#x3D; target &lt;&#x3D; 10^4</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序 + 双指针"></a>排序 + 双指针</h3><p>解题思路同 <a href="./15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.md">15. 三数之和</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> dis = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-type">int</span> m = i + <span class="hljs-number">1</span>, n = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (m &lt; n) &#123;<br>        <span class="hljs-type">int</span> sum = nums[i]+nums[m]+nums[n];<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>          <span class="hljs-keyword">return</span> target;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(target - sum) &lt; <span class="hljs-built_in">abs</span>(dis)) dis = target - sum;<br>          <span class="hljs-type">int</span> x = nums[m];<br>          <span class="hljs-keyword">while</span>(x == nums[++m] &amp;&amp; m &lt; n);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(target - sum) &lt; <span class="hljs-built_in">abs</span>(dis)) dis = target - sum;<br>          <span class="hljs-type">int</span> x = nums[n];<br>          <span class="hljs-keyword">while</span>(x == nums[--n] &amp;&amp; m &lt; n);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target - dis;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>使用 INT_MAX 初始化三元组和与 target 的差值，然后在遍历过程中不断更新这个差值；</li><li>三元组与 target 的插值 dis 类型为 int，存储真实差值，避免正负差异，dis &#x3D; target - sum；</li><li>与 target 最接近的和即为 target - dis；</li><li>当 sum &#x3D;&#x3D; target 时，直接返回 target，可以降低耗时，避免冗余枚举；</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15. 三数之和</title>
    <link href="/2024/04/17/leetcode/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/04/17/leetcode/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。</p><p>请你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：nums = [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：nums = [0,0,0]<br>输出：[[0,0,0]]<br>解释：唯一可能的三元组和为 0 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>3 &lt;&#x3D; nums.length &lt;&#x3D; 3000</li><li>-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：暴力枚举-去重"><a href="#解法一：暴力枚举-去重" class="headerlink" title="解法一：暴力枚举 + 去重"></a>解法一：暴力枚举 + 去重</h3><p>最容易想到的方法，直接枚举三个数的组合，当和为 0 时，将当前组合排序，然后遍历结果集，如果当前结果集中没有这个组合则加入结果集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>  std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>  <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j + <span class="hljs-number">1</span>; k &lt; nums.<span class="hljs-built_in">size</span>(); k++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>) &#123;<br>          res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是时间复杂度为 $O(n^3)$，提交后显示超时。</p><h3 id="解法二：排序-双指针"><a href="#解法二：排序-双指针" class="headerlink" title="解法二：排序 + 双指针"></a>解法二：排序 + 双指针</h3><p>解法一在去重过程需要先排序，不妨在最开始先进行排序。</p><p>当排序后，我们在遍历三元组时，当下标移动时遇到相同元组，直接跳过即可，避免了每次向结果集查找去重的操作。</p><p>遍历三元组时，必然先固定一个元素，nums[i]，然后继续向后遍历 nums[j] 和 nums[k]。但是这样一次枚举就会导致时间复杂度过高。</p><blockquote><p>可以发现，如果我们固定了前两重循环枚举到的元素 a 和 b，那么只有唯一的 c 满足 <code>a+b+c=0</code>。当第二重循环往后枚举一个元素 b′ 时，由于 b′&gt;b，那么满足 a+b′+c′&#x3D;0 的 c′ 一定有 <code>c′ &lt; c</code> ，即 c′ 在数组中一定出现在 c 的左侧。也就是说，我们可以从小到大枚举 b，同时从大到小枚举 c，即第二重循环和第三重循环实际上是并列的关系。</p><p>有了这样的发现，我们就可以保持第二重循环不变，而将第三重循环变成一个从数组最右端开始向左移动的指针。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>  std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>  <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-type">int</span> m = i + <span class="hljs-number">1</span>, n = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (m &lt; n) &#123;<br>      <span class="hljs-keyword">if</span> (nums[n] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">if</span> (nums[i]+nums[m]+nums[n] == <span class="hljs-number">0</span>) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[m], nums[n]&#125;);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (nums[i]+nums[m]+nums[n] &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> x = nums[m];<br>        <span class="hljs-keyword">while</span>(x == nums[++m] &amp;&amp; m &lt; n);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> x = nums[n];<br>        <span class="hljs-keyword">while</span>(x == nums[--n] &amp;&amp; m &lt; n);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>双指针，优化第二个数和第三个数遍历过程，将第三个数遍历过程变成一个从数组最右端开始向左移动的指针；</li><li>排序时间复杂度为 $O(n\log n)$，双指针时间复杂度为 $O(n^2)$，总时间复杂度为 $O(n^2)$。</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14. 最长公共前缀</title>
    <link href="/2024/04/17/leetcode/14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/2024/04/17/leetcode/14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]<br>输出：&quot;fl&quot;<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]<br>输出：&quot;&quot;<br>解释：输入不存在公共前缀。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; strs.length &lt;&#x3D; 200</li><li>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 200</li><li>strs[i] 仅由小写英文字母组成</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最长公共前缀，表明这个 prefix 在每个 str 中都存在，因此只需要将 strs 中随便取一个 str 作为基准，逐位去和剩余的 str 进行比较即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(std::vector&lt;std::string&gt;&amp; strs)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); i++) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; strs.<span class="hljs-built_in">size</span>(); j++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= strs[j].<span class="hljs-built_in">size</span>() || strs[<span class="hljs-number">0</span>][i] != strs[j][i]) &#123;<br>          <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>逐位比较</li><li>边界条件：i &gt;&#x3D; strs[j].size() 或 strs[0][i] !&#x3D; strs[j][i] 时，返回结果</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11. 盛最多水的容器</title>
    <link href="/2024/04/17/leetcode/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2024/04/17/leetcode/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：[1,8,6,2,5,4,8,3,7]<br>输出：49 <br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：height = [1,1]<br>输出：1<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>n &#x3D;&#x3D; height.length</li><li>2 &lt;&#x3D; n &lt;&#x3D; 10^5</li><li>0 &lt;&#x3D; height[i] &lt;&#x3D; 10^4</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>算法正确性的证明见官方题解原文： <a href="https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/">盛最多水的容器</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt;= j;) &#123;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j-i));<br>            <span class="hljs-keyword">if</span> (height[i] &gt; height[j]) &#123;<br>                j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>双指针</li><li>移动较小的指针，缩小问题规模</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10. 正则表达式匹配</title>
    <link href="/2024/04/14/leetcode/10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <url>/2024/04/14/leetcode/10.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元素</li><li>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</li></ul><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：s = &quot;aa&quot;, p = &quot;a&quot;<br>输出：false<br>解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：s = &quot;aa&quot;, p = &quot;a*&quot;<br>输出：true<br>解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：s = &quot;ab&quot;, p = &quot;.*&quot;<br>输出：true<br>解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 20</li><li>1 &lt;&#x3D; p.length &lt;&#x3D; 20</li><li>s 只包含从 a-z 的小写字母。</li><li>p 只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><blockquote><p>以下题解思路和图片，引用自：</p><p>作者：笨猪爆破组</p><p>链接：<a href="https://leetcode.cn/problems/regular-expression-matching/solutions/1/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/">https://leetcode.cn/problems/regular-expression-matching/solutions/1/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/</a></p></blockquote><h4 id="从左往右扫的话"><a href="#从左往右扫的话" class="headerlink" title="从左往右扫的话"></a>从左往右扫的话</h4><ul><li>字符后面是否跟着星号会影响结果，分析起来有点复杂。<br><img src="https://pic.leetcode-cn.com/073085fa67286871f76e8e9daa162bdb291a101b4314666c75379a7b0441cad6-image.png"></li></ul><h4 id="选择从右往左扫描"><a href="#选择从右往左扫描" class="headerlink" title="选择从右往左扫描"></a>选择从右往左扫描</h4><ul><li><p>星号的前面肯定有一个字符，星号也只影响这一个字符，它就像一个拷贝器。<br><img src="https://pic.leetcode-cn.com/5e7b1748039a2a779d7378bebc4926ef3e584e88cc22b67f3a4e18c0590bcc55-image.png"></p></li><li><p>s、p 串是否匹配，取决于：最右端是否匹配、剩余的子串是否匹配。</p></li><li><p>只是最右端可能是特殊符号，需要分情况讨论而已。</p></li></ul><h4 id="通用地表示出子问题"><a href="#通用地表示出子问题" class="headerlink" title="通用地表示出子问题"></a>通用地表示出子问题</h4><ul><li>大子串是否匹配，和剩余子串是否匹配，是规模不一样的同一问题。<br><img src="https://pic.leetcode-cn.com/e1bcac2ad07a3a5c959bf0fe5c8ceea9bbd033c3066e7ec7f384aedd98cd95aa-image.png"></li></ul><h5 id="情况1：s-i−1-和-p-j−1-是匹配的"><a href="#情况1：s-i−1-和-p-j−1-是匹配的" class="headerlink" title="情况1：s[i−1] 和 p[j−1] 是匹配的"></a>情况1：s[i−1] 和 p[j−1] 是匹配的</h5><ul><li>最右端的字符是匹配的，那么，大问题的答案 &#x3D; 剩余子串是否匹配。<br><img src="https://pic.leetcode-cn.com/f817caaa40b0c39fc3ddabfa1383a8218ab364b8e49b30e5ce85cb30a3cdc503-image.png"></li></ul><h5 id="情况2：s-i−1-和-p-j−1-是不匹配的"><a href="#情况2：s-i−1-和-p-j−1-是不匹配的" class="headerlink" title="情况2：s[i−1] 和 p[j−1] 是不匹配的"></a>情况2：s[i−1] 和 p[j−1] 是不匹配的</h5><ul><li>右端不匹配，还不能判死刑——可能是 p[j−1] 为星号造成的不匹配，星号不是真实字符，它不匹配不算数。</li><li>如果 p[j−1]p[j-1]p[j−1] 不是星号，那就真的不匹配了。<br><img src="https://pic.leetcode-cn.com/fe763378879a0a52e9f17171e3bc1db18cfc83bf59f14efcd31ec9edb37adfac-image.png"></li></ul><ol><li>p[j−1]&#x3D;&#x3D;”∗”，且 s[i−1] 和 p[j−2] 匹配<ul><li>p[j−1] 是星号，并且 s[i−1] 和 p[j−2] 匹配，要考虑三种情况：<ul><li>p[j−1] 星号可以让 p[j−2] 在 p 串中消失、出现 1 次、出现 &gt;&#x3D;2 次。</li><li>只要其中一种使得剩余子串能匹配，那就能匹配，见下图 a1、a2、a3。<br>  <img src="https://pic.leetcode-cn.com/a1cc0caf806f7d7f5419d820e0e7be7a364c96656a98ca4d7f351661d6a62aa6-image.png"></li><li>a3 情况：假设 s 的右端是一个 a，p 的右端是 a * ，* 让 a 重复 &gt;&#x3D; 2 次<ul><li>星号不是真实字符，s、p是否匹配，要看 s 去掉末尾的 a，p 去掉末尾一个 a，剩下的是否匹配。</li><li>星号拷贝了 &gt;&#x3D;2 个 a，拿掉一个，剩下 &gt;&#x3D;1 个a，p 末端依旧是 a* 没变。</li><li>s 末尾的 a 被抵消了，继续考察 s(0,i-2) 和 p(0,i-1) 是否匹配。</li></ul></li></ul></li></ul></li><li>p[j−1]&#x3D;&#x3D;”∗”，但 s[i−1] 和 p[j−2] 不匹配<ul><li>s[i−1] 和 p[j−2] 不匹配，还有救，p[j−1] 星号可以干掉 p[j−2]，继续考察 s(0,i−1) 和 p(0,j−3)。<br> <img src="https://pic.leetcode-cn.com/dabf2195c460052e2719340de8f2d22f791694d4443424478201be3b5d601fe1-image.png"></li></ul></li></ol><h4 id="base-case"><a href="#base-case" class="headerlink" title="base case"></a>base case</h4><ul><li>p 为空串，s 不为空串，肯定不匹配。</li><li>s 为空串，但 p 不为空串，要想匹配，只可能是右端是星号，它干掉一个字符后，把 p 变为空串。</li><li>s、p 都为空串，肯定匹配。</li></ul><p><img src="https://pic.leetcode-cn.com/140597adfd5f03dd481e136163d98e7160cce4761c7cb8227010d828f24b7498-image.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(std::string s, std::string p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> s_len = s.<span class="hljs-built_in">size</span>(), p_len = p.<span class="hljs-built_in">size</span>(), i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (s_len &gt; <span class="hljs-number">0</span> &amp;&amp; p_len &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 申请 dp</span><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s_len + <span class="hljs-number">1</span>,<br>                                      std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(p_len + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-comment">// 边界</span><br>    <span class="hljs-comment">// 1. s, p 均为空串</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 2. s 为空串，p 不为空，则 p 必须以 * 结尾</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= p_len; j++) &#123;<br>      <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-comment">// 3. s 不为空，p 为空，初始化时默认已经全部设为false了</span><br><br>    <span class="hljs-comment">// 状态转移，i 和 j 表示的时长度，并非真实下标</span><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= p_len; j++) &#123;<br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= s_len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-1</span>] || p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;      <span class="hljs-comment">// 当 s[i-1] 和 p[j-1] 匹配，则状态转移为 dp[i-1][j-1]</span><br>          dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;                   <span class="hljs-comment">// 当 s[i-1] 和 p[j-1] 不匹配时，考虑 p[j-1] 为 * 号</span><br>          <span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>] == p[j<span class="hljs-number">-2</span>] || p[j<span class="hljs-number">-2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 当 s[i-1] 和 p[j-2] 匹配，则考虑 * 抵消 0 次，1 次和 多次</span><br>            <span class="hljs-comment">// 0   次：i 不变，j-2</span><br>            <span class="hljs-comment">// 1   次：i-1, j-2</span><br>            <span class="hljs-comment">// &gt;=2 次：i-1，j 不变</span><br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-2</span>] || dp[i<span class="hljs-number">-1</span>][j] || dp[i][j<span class="hljs-number">-2</span>];<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当 s[i-1] 和 p[j-2] 不匹配时，由于 * 号可表示前置字符出现0次，因此 p 中去除这两个字符 j - 2 后继续匹配</span><br>            dp[i][j] = dp[i][j<span class="hljs-number">-2</span>];<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s_len][p_len];<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>逆序思考问题，从右往左扫描，可以简化问题；</li><li>状态转移方程的推导，需要考虑多种情况，包括星号的作用；</li><li>边界条件的处理，需要考虑 s、p 为空串的情况；</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09. 回文数</title>
    <link href="/2024/04/14/leetcode/09.%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2024/04/14/leetcode/09.%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="09-回文数"><a href="#09-回文数" class="headerlink" title="09. 回文数"></a>09. 回文数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>例如，121 是回文，而 123 不是。</p><p>示例 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入：x = <span class="hljs-number">121</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入：x = <span class="hljs-number">-121</span><br>输出：<span class="hljs-literal">false</span><br>解释：从左向右读, 为 <span class="hljs-number">-121</span> 。 从右向左读, 为 <span class="hljs-number">121</span>- 。因此它不是一个回文数。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">输入：x = <span class="hljs-number">10</span><br>输出：<span class="hljs-literal">false</span><br>解释：从右向左读, 为 <span class="hljs-number">01</span> 。因此它不是一个回文数。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>-2^31 &lt;&#x3D; x &lt;&#x3D; 2^31 - 1</li></ul><p>进阶：你能不将整数转为字符串来解决这个问题吗？</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据题干可知：</p><ol><li>当 x 为负数时，由于负号的存在，必定不为回文数；</li><li>当 x 为非负个位整数时，必定是回文数；</li></ol><p>所以可以直接通过简单判断，将这两种情况直接返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= <span class="hljs-number">9</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>对于剩余 x &gt;&#x3D; 10 的情况，比较好理解的方法就是将 x 转换为字符串，然后判断字符串是否为回文串即可。</p><h3 id="解法一：字符串为回文串"><a href="#解法一：字符串为回文串" class="headerlink" title="解法一：字符串为回文串"></a>解法一：字符串为回文串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= <span class="hljs-number">9</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        std::string tmp = std::<span class="hljs-built_in">to_string</span>(x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tmp.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (tmp[i] != tmp[tmp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> - i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：-反转一半数字"><a href="#解法二：-反转一半数字" class="headerlink" title="解法二： 反转一半数字"></a>解法二： 反转一半数字</h3><p>官方题解给出另一个解法，通过比较翻转数字，比较翻转结果和原始数字是否相等来判断是否为回文数。</p><p>但是官方也提到，这种解法存在部分数字反转后溢出的问题。不过换个角度想，根据回文数的定义，反转后应该等于这个数本身，这也就意味着，由于输入必然不会溢出，那么如果反转后数字出现溢出，那么这个数必然不是回文数。</p><p>即使进行逻辑优化，判断反转结果是否溢出仍然是不可避免的，并且并没有对时间复杂度产生优化。因此官方基于反转数字提出了一种更优化的解法，即<strong>反转一半数字</strong>。</p><p>根据回文数的特征，将后半部分的数字进行反转，应该要和前半部分数字相等（当数字位数为奇数时，这个逻辑仍然成立，只需去除中间位即可）。</p><p>这个解法的关键在于：<mark>如何判断当前已经反转了一半的数字</mark>。</p><blockquote><p>由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || (x != <span class="hljs-number">0</span> &amp;&amp; x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= <span class="hljs-number">9</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x &gt; y) &#123;<br>      y = y * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>      x = x / <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (x == y || x == y / <span class="hljs-number">10</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>通过回文数特征，提取出 x &lt; 0 ，0 &lt;&#x3D; x &lt;&#x3D; 9，以及 x 为 10 的倍数这几种特殊情况，快速判断返回；</li><li>将 x 是否为回文数问题，转换为 x 这个字符串是否为回文串问题；</li><li>根据回文数特征，回文数反转后等于数字本身，但是需注意直接反转存在溢出问题；</li><li>回文数后半部分反转后等于前半部分，通过判断 x &lt;&#x3D; 反转结果 y, 得到此时已经反转一半数字；</li><li>当数字为奇数位时，只需去除中间位，判断剩余部分 x &#x3D;&#x3D; y &#x2F; 10 即可；</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整数溢出</tag>
      
      <tag>回文字符串</tag>
      
      <tag>整数反转</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08. 字符串转换整数 (atoi)</title>
    <link href="/2024/04/14/leetcode/08.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"/>
    <url>/2024/04/14/leetcode/08.%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="08-字符串转换整数-atoi"><a href="#08-字符串转换整数-atoi" class="headerlink" title="08. 字符串转换整数 (atoi)"></a>08. 字符串转换整数 (atoi)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 atoi 函数）。</p><p>函数 myAtoi(string s) 的算法如下：</p><ol><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。</li><li>返回整数作为最终结果。</li></ol><p>注意：</p><p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong>任何其他字符。</p><p>示例 1：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：s = &quot;42&quot;<br>输出：42<br>解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。<br>第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）<br>         ^<br>第 3 步：&quot;42&quot;（读入 &quot;42&quot;）<br>           ^<br>解析得到整数 42 。<br>由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：s = &quot;   -42&quot;<br>输出：-42<br>解释：<br>第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）<br>            ^<br>第 2 步：&quot;   -42&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）<br>             ^<br>第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）<br>               ^<br>解析得到整数 -42 。<br>由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：s = &quot;4193 with words&quot;<br>输出：4193<br>解释：<br>第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）<br>         ^<br>第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）<br>             ^<br>解析得到整数 4193 。<br>由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; s.length &lt;&#x3D; 200</li><li>s 由英文字母（大写和小写）、数字（0-9）、’ ‘、’+’、’-‘ 和 ‘.’ 组成</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>stoi 和 regex 秒了 0.0 只想偷懒……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>  <span class="hljs-function">std::regex <span class="hljs-title">re</span><span class="hljs-params">(<span class="hljs-string">&quot;^ *([\\+\\-]?[0-9]+)&quot;</span>)</span></span>;<br>  std::smatch m;<br>  std::string sub;<br><br>  <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">regex_search</span>(s, m, re) &amp;&amp; m.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>    sub = m[<span class="hljs-number">1</span>].<span class="hljs-built_in">str</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (sub.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (sub[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> -std::<span class="hljs-built_in">stoi</span>(sub.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stoi</span>(sub);<br>    &#125;<br>  &#125; <span class="hljs-built_in">catch</span> (std::exception&amp;) &#123;<br>    <span class="hljs-keyword">return</span> sub[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> ? INT_MIN : INT_MAX;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>题干意义不明，很多用例在题干理解错误的情况下，无法理解为什么会这样……例如 “word and 987” 正确结果为 0，再例如 “+-12” 正确结果为 0;</li><li>题干解析：<ul><li>字符串开头可以由若干个 “ “ 空格;</li><li>去除开头若干个空格后只能有 1 个或 0 个 “+” 或 “-“；</li><li>正负号后必须是数字，数字可以是多个 0 开头</li><li>其余任意情况均为非法字符串</li></ul></li><li>第一眼直接正则秒了，可惜效率和内存并不好，无所谓，AC 就行</li><li>正负溢出靠捕获 <code>stoi</code> 异常解决</li></ol><p>搞清楚题干意思后，遍历字符串也很方便，判断溢出条件可以通过比较字符串，或者在 INT_MAX &#x2F; 10 和 INT_MIN &#x2F; 10 之前进行比较判断，避免溢出</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFA</tag>
      
      <tag>整数溢出</tag>
      
      <tag>正则表达式</tag>
      
      <tag>确定性有限状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07. 整数反转</title>
    <link href="/2024/04/14/leetcode/07.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2024/04/14/leetcode/07.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="07-整数反转"><a href="#07-整数反转" class="headerlink" title="07. 整数反转"></a>07. 整数反转</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：x = 123<br>输出：321<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：x = -123<br>输出：-321<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：x = 120<br>输出：21<br></code></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：x = 0<br>输出：0<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>-2^31 &lt;&#x3D; x &lt;&#x3D; 2^31 - 1</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>数学计算令人头秃，选择字符串反转 T_T</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> smb = x &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>  string s = <span class="hljs-built_in">to_string</span>(x).<span class="hljs-built_in">substr</span>(smb);<br>  string s_re;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    s_re += s[i];<br>  &#125;<br>  string max = <span class="hljs-built_in">to_string</span>(INT_MAX);<br>  s_re = <span class="hljs-built_in">string</span>(max.<span class="hljs-built_in">size</span>() - s_re.<span class="hljs-built_in">size</span>(), <span class="hljs-string">&#x27;0&#x27;</span>) + s_re;<br>  <span class="hljs-keyword">if</span> (s_re &gt;= max) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> z = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    z += (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> smb == <span class="hljs-number">1</span> ? -z : z;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>字符串翻转，遍历字符串 (s[i] - ‘0’) * 10 ^ i 计算结果；</li><li>判断溢出问题，去除符号位后，将判断条件优化为字符串 s_rev &gt; INT_MIN 和 s_rev &gt; INT_MAX</li><li><mark>根据题目限制，输入 x 的取值范围 [-2^31, 2^31 - 1]，因此不存在两个数在翻转后可以等于边界值，所以优化溢出判断，仅需要判断 s_rev &lt; INT_MAX 即可；</mark></li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整数溢出</tag>
      
      <tag>字符串反转</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06. Z 字形变换</title>
    <link href="/2024/04/14/leetcode/06.Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <url>/2024/04/14/leetcode/06.Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="06-Z-字形变换"><a href="#06-Z-字形变换" class="headerlink" title="06. Z 字形变换"></a>06. Z 字形变换</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">P   A   H   N<br>A P L S I I G<br>Y   I   R<br></code></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：<code>string convert(string s, int numRows);</code></p><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3<br>输出：&quot;PAHNAPLSIIGYIR&quot;<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4<br>输出：&quot;PINALSIGYAHRPI&quot;<br>解释：<br>P     I    N<br>A   L S  I G<br>Y A   H R<br>P     I<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：s = &quot;A&quot;, numRows = 1<br>输出：&quot;A&quot;<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 1000</li><li>s 由英文字母（小写和大写）、’,’ 和 ‘.’ 组成</li><li>1 &lt;&#x3D; numRows &lt;&#x3D; 1000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：矩阵模拟"><a href="#解法一：矩阵模拟" class="headerlink" title="解法一：矩阵模拟"></a>解法一：矩阵模拟</h3><p>若模拟矩阵类型为 <code>vector&lt;vector&lt;char&gt;&gt;</code> 则需要先计算矩阵列数 col。根据 Z 字形填充规则，得到填充周期为 (row+row-2) 个字符，一个周期为 (row - 1) 列，因此列数为 <code>(s.size() / (row + row - 2) + 1) * (row -1)</code>。由于字符数不一定是周期的整数倍，计算周期数是需要向上取整，将最后一个周期视作完整周期。</p><p>另外设置一个填充次数 cnt，每当填充 (row - 1) 个字符时，填充方向改变，cnt++ ，填充方向由 cnt 奇偶性进行判断，奇数时填充方向为向下，偶数时填充方向为向上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">convert2</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span> || numRows == <span class="hljs-number">1</span> || s.<span class="hljs-built_in">size</span>() &lt;= numRows) <span class="hljs-keyword">return</span> s;<br>  <span class="hljs-type">int</span> col = s.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span> + numRows - <span class="hljs-number">1</span>;<br>  vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">mat</span>(col, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(numRows, <span class="hljs-string">&#x27;\0&#x27;</span>));<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    mat[x][y] = s[i];<br>    <span class="hljs-keyword">if</span> (i % (numRows - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; i != <span class="hljs-number">0</span>) &#123;<br>      cnt++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>      x++;<br>      y--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      y++;<br>    &#125;<br><br>  &#125;<br>  x = y = <span class="hljs-number">0</span>;<br>  std::string res;<br>  <span class="hljs-keyword">for</span>(y = <span class="hljs-number">0</span>; y &lt; numRows; y++) &#123;<br>    <span class="hljs-keyword">for</span>(x = <span class="hljs-number">0</span>; x &lt; col; x++) &#123;<br>      <span class="hljs-keyword">if</span> (mat[x][y] != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        res += mat[x][y];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法二：压缩矩阵"><a href="#解法二：压缩矩阵" class="headerlink" title="解法二：压缩矩阵"></a>解法二：压缩矩阵</h3><p>当 numRows 较大时，解法一存在大量的冗余空间，且使用 <code>vector&lt;vector&lt;char&gt;&gt;</code> 需优先计算列数 col。</p><p>因此在解法二中，使用 <code>vector&lt;string&gt;</code> 按行申请空间。由于最终读取时忽略空白字符，所以直接将当前行字符追加到字符串尾部即可，消除冗余的空白空间。</p><p><mark>由于不需要计算列数，因此在填充时仅需要记录当前行数 row 即可，当 row &#x3D;&#x3D; 0 或 row &#x3D;&#x3D; numRows - 1 时，填充方向翻转。翻转的方法极为巧妙：每次填充字符时，行数 row 存在两种情况，+1 或者 -1，所以设置一个标记 k &#x3D; 1，在 row 符合翻转条件时，将 k 取反，即 k &#x3D; -k，此时 只需要 <code>row += k</code> 即可完成行号的更新。</mark></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span> || numRows == <span class="hljs-number">1</span> || s.<span class="hljs-built_in">size</span>() &lt;= numRows) <span class="hljs-keyword">return</span> s;<br>  <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">mat</span><span class="hljs-params">(numRows, <span class="hljs-string">&quot;&quot;</span>)</span></span>;<br>  <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>, k = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s) &#123;<br>    mat[row] += c;<br>    row += k;<br>    <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span> || row == numRows - <span class="hljs-number">1</span>) &#123;<br>      k = -k;<br>    &#125;<br>  &#125;<br>  string res;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;t:mat) &#123;<br>    res += t;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>矩阵模拟，计算填充模式下的周期，和找到坐标更新模式的拐点；</li><li>根据题意无视空白字符，因此可直接按行追加字符，无需留出空白位置，压缩矩阵，节省空间</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵模拟</tag>
      
      <tag>压缩矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05. 最长回文子串</title>
    <link href="/2024/04/13/leetcode/05.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2024/04/13/leetcode/05.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="05-最长回文子串"><a href="#05-最长回文子串" class="headerlink" title="05. 最长回文子串"></a>05. 最长回文子串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给<br>你一个字符串 s，找到 s 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p>示例 1：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：s = &quot;babad&quot;<br>输出：&quot;bab&quot;<br>解释：&quot;aba&quot; 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：s = &quot;cbbd&quot;<br>输出：&quot;bb&quot;<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 1000</li><li>s 仅由数字和英文字母组成</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：暴力枚举"><a href="#解法一：暴力枚举" class="headerlink" title="解法一：暴力枚举"></a>解法一：暴力枚举</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string s)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; i++, j--) &#123;<br>    <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">longestPalindrome2</span><span class="hljs-params">(string s)</span> </span>&#123;<br>  string sub;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); j++) &#123;<br>      std::string temp = s.<span class="hljs-built_in">substr</span>(i, j - i + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(temp)) &#123;<br>        sub = sub.<span class="hljs-built_in">size</span>() &gt; temp.<span class="hljs-built_in">size</span>() ? sub : temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sub;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>根据回文串的特点，s[i][j] 为回文串，则 s[i+1][j-1] 也为回文串。因此我们得到状态转移方程：</p>  <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">dp[i][j] = dp[i+1][j-1] &amp;&amp; s[i] == s[j]<br></code></pre></td></tr></table></figure><p>官方给出的动态规划解法，根据子串长度 len 进行遍历，右移左边界 i ，并根据 len 和 i 倒推右边界 j。此时存在额外需要处理的两处逻辑边界：</p><ol><li>当 len &lt; 3 时， dp[i+1][j-1] 出现翻转，手动设置 dp[i][j] 为 true;</li><li>j &#x3D; i + len - 1 存在下标溢出，需额外判断停止循环;</li></ol><p>此处给出优化解法，使用左右边界进行遍历，由于dp[i][j] 依赖于 dp[i+1][j-1]，因此左边界 i 应该从大到小，右边界 j 从小到大，我们从右下角开始遍历，即从左边界开始遍历，右边界逐渐右移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">longestPalindrome3</span><span class="hljs-params">(string s)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>  <span class="hljs-type">int</span> maxl = s.<span class="hljs-built_in">size</span>(), start = <span class="hljs-number">0</span>, len = <span class="hljs-number">1</span>;<br>  vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(maxl, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(maxl, <span class="hljs-literal">true</span>));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxl - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; maxl; j++) &#123;<br>      dp[i][j] = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>        dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; len &lt; j - i + <span class="hljs-number">1</span>) &#123;<br>          start = i;<br>          len = j - i + <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start,len);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法三：中心扩展"><a href="#解法三：中心扩展" class="headerlink" title="解法三：中心扩展"></a>解法三：中心扩展</h3><p>枚举回文字符串中心点，由于回文字符串长度可能为奇数 1 个中心点或偶数 2 个中心点，因此我们将中心点统一扩展为 2 个，奇数时两个中心点相同，遍历过程中每次都需计算奇偶两种情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, mx = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) &#123;<br>                l--, r++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> r - l - <span class="hljs-number">1</span>;<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> a = <span class="hljs-built_in">f</span>(i, i);<br>            <span class="hljs-type">int</span> b = <span class="hljs-built_in">f</span>(i, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">max</span>(a, b);<br>            <span class="hljs-keyword">if</span> (mx &lt; t) &#123;<br>                mx = t;<br>                start = i - (t - <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start, mx);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>暴力枚举可解，但是时间复杂度为 O(n^3)，部分超长用例存在超时问题；</li><li>动态规划，找到状态转移方程，回文字符串形式为关键点；</li><li>动态规划解法中，根据状态转移方程优化遍历条件和顺序，减少边界判断；</li><li>中心扩展算法，奇偶差异性如何统一，减少冗余计算</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>中心扩展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04. 寻找两个正序数组的中位数</title>
    <link href="/2024/04/13/leetcode/04.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2024/04/13/leetcode/04.%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="04-寻找两个正序数组的中位数"><a href="#04-寻找两个正序数组的中位数" class="headerlink" title="04. 寻找两个正序数组的中位数"></a>04. 寻找两个正序数组的中位数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><p>示例 1：<br>输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]<br>输出：2.00000<br>解释：合并数组 &#x3D; [1,2,3] ，中位数 2</p><p>示例 2：<br>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]<br>输出：2.50000<br>解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>提示：<br>nums1.length &#x3D;&#x3D; m<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m &lt;&#x3D; 1000<br>0 &lt;&#x3D; n &lt;&#x3D; 1000<br>1 &lt;&#x3D; m + n &lt;&#x3D; 2000<br>-106 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 106</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：分别从两个数组中按照升序不断取元素，直到取到-m-n-x2F-2-个元素，然后取中位数"><a href="#解法一：分别从两个数组中按照升序不断取元素，直到取到-m-n-x2F-2-个元素，然后取中位数" class="headerlink" title="解法一：分别从两个数组中按照升序不断取元素，直到取到 m+n&#x2F;2 个元素，然后取中位数"></a>解法一：分别从两个数组中按照升序不断取元素，直到取到 m+n&#x2F;2 个元素，然后取中位数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>(), m = nums2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> total = n + m;<br>    <span class="hljs-type">int</span> target1 = (total + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, target2 = (total + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> median1 = <span class="hljs-number">0</span>, median2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt; n || j &lt; m) &#123;<br>      <span class="hljs-type">int</span> num;<br>      <span class="hljs-keyword">if</span> (i &lt; n &amp;&amp; (j &gt;= m || nums1[i] &lt; nums2[j])) &#123;<br>        num = nums1[i++];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        num = nums2[j++];<br>      &#125;<br>      cnt++;<br>      <span class="hljs-keyword">if</span> (cnt == target1) &#123;<br>        median1 = num;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (cnt == target2) &#123;<br>        median2 = num;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (median1 + median2) / <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：归并排序"><a href="#解法二：归并排序" class="headerlink" title="解法二：归并排序"></a>解法二：归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    解题思路：</span><br><span class="hljs-comment">        合并两数组，并利用std::sort进行排序，</span><br><span class="hljs-comment">        对合并后的有序数组进行中位数求解，分两种情况：</span><br><span class="hljs-comment">        1.数组元素个数为奇数，则直接取下标为【(n+1)/2】的元素为结果；</span><br><span class="hljs-comment">        2.数组元素个数为偶数，则取下标为【len/2-1】和【len/2】元素的平均值作为结果</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">double</span> midNum = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums2.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            nums1.<span class="hljs-built_in">push_back</span>(nums2[i]);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> len = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == len%<span class="hljs-number">2</span>)&#123;<br>            len = len/<span class="hljs-number">2</span>;<br>            midNum = (nums1[len<span class="hljs-number">-1</span>] + nums1[len]) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            midNum = nums1[len/<span class="hljs-number">2</span>]/<span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> midNum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：二分查找-分治"><a href="#解法三：二分查找-分治" class="headerlink" title="解法三：二分查找 (分治)"></a>解法三：二分查找 (分治)</h3><p>解法一、二的时间复杂度均为 O(m+n)，尽管能 AC，但是并不满足题目要求。题目要求时间复杂度为 O(log(m+n))，因此需要使用<strong>二分查找</strong>进行降低时间复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>(), n = nums2.<span class="hljs-built_in">size</span>();<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= m) &#123;<br>                <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &gt;= n) &#123;<br>                <span class="hljs-keyword">return</span> nums1[i + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[i], nums2[j]);<br>            &#125;<br>            <span class="hljs-type">int</span> p = k / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> x = i + p - <span class="hljs-number">1</span> &lt; m ? nums1[i + p - <span class="hljs-number">1</span>] : <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>            <span class="hljs-type">int</span> y = j + p - <span class="hljs-number">1</span> &lt; n ? nums2[j + p - <span class="hljs-number">1</span>] : <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>            <span class="hljs-keyword">return</span> x &lt; y ? <span class="hljs-built_in">f</span>(i + p, j, k - p) : <span class="hljs-built_in">f</span>(i, j + p, k - p);<br>        &#125;;<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> b = <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (m + n + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> (a + b) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：两个升序数组求中位数，简化问题为求第 (m+n+1)&#x2F;2 和第 (m+n+2)&#x2F;2 个数的平均值，即找到两个正序序列的第 (m+n+1)&#x2F;2 小的数和第 (m+n+2)&#x2F;2 小的数。此时问题可归纳为：两个正序序列，如何找到第 k 小的数。二分法查找，每个数组中各取 k&#x2F;2 的元素比较大小，较小部分的元素必然不是第 k 小的数，因此移动较小部分的指针，递归继续。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>第一直觉：归并排序，解法一和二本质相同，但时间复杂度无法满足题解要求</li><li>关键点：O(log(m+n))，二分查找</li><li>简化问题模型，根据中位数特性，将问题转化为求第 k 小的数，二分查找迭代计算</li><li>解法三使用lambda表达式，以及函数递归调用，会导致耗时和内存消耗增加，提交测试耗时和内存同解法一相似，可简化为普通函数和循环计算，避免递归次数过多导致栈溢出</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
      <tag>分治</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03. 无重复字符的最长子串</title>
    <link href="/2024/04/13/leetcode/03.%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
    <url>/2024/04/13/leetcode/03.%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="03-无重复字符的最长子串"><a href="#03-无重复字符的最长子串" class="headerlink" title="03. 无重复字符的最长子串"></a>03. 无重复字符的最长子串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:<br>输入: <code>s = &quot;abcabcbb&quot;</code><br>输出: <code>3</code><br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>示例 2:<br>输入: <code>s = &quot;bbbbb&quot;</code><br>输出: <code>1</code><br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>示例 3:<br>输入: <code>s = &quot;pwwkew&quot;</code><br>输出: <code>3</code><br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>提示：<br>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>s 由英文字母、数字、符号和空格组成</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; s.<span class="hljs-built_in">size</span>(); n++) &#123;<br>            <span class="hljs-keyword">auto</span> pos = s.<span class="hljs-built_in">substr</span>(m, n - m).<span class="hljs-built_in">find</span>(s[n]);<br>            <span class="hljs-keyword">if</span> (pos == std::string::npos) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = <span class="hljs-built_in">max</span>(l, (n - m));<br>                m += (pos + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l, (n - m));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>解决关键词：滑动窗口，双指针</li><li>右侧边界 n 滑动，从当前窗口 substr(m, n - m) 中查找 s[n],如果找到，则将左侧边界 m 滑动至 pos + 1，不断重复</li><li>对 std::string::substr 使用 find 方法时，需要额外加上 substr 在原始字符串的起始位置</li><li>substr 和 find 方法并非最优解，使用表存储字符出现的位置，查找时间复杂度为 O(n)。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx[<span class="hljs-number">128</span>];<br>        <span class="hljs-built_in">memset</span>(idx, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(idx));<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>; n &lt; s.<span class="hljs-built_in">size</span>(); n++) &#123;<br>            <span class="hljs-comment">// idx[s[n]] + 1 当前字符上一次出现的索引值 + 1</span><br>            <span class="hljs-comment">// 确保 m 左侧边界已经越过重复字符 s[n]，始终保持滑动窗口为 [m,n] 的闭区间</span><br>            <span class="hljs-comment">// 即确保子串 s[m,n] 中没有重复字符</span><br>            m = <span class="hljs-built_in">max</span>(m, idx[s[n]] + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 因此子串长度为 n - m + 1</span><br>            l = <span class="hljs-built_in">max</span>(l, n - m + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 记录当前字符 s[n] 的索引值</span><br>            idx[s[n]] = n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02.两数相加</title>
    <link href="/2024/04/13/leetcode/02.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2024/04/13/leetcode/02.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="02-两数相加"><a href="#02-两数相加" class="headerlink" title="02.两数相加"></a>02.两数相加</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><p>输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 &#x3D; 807.<br>示例 2：</p><p>输入：l1 &#x3D; [0], l2 &#x3D; [0]<br>输出：[0]<br>示例 3：</p><p>输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p><p>提示：</p><p>每个链表中的节点数在范围 [1, 100] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9<br>题目数据保证列表表示的数字不含前导零</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode* p = h;<br>        ListNode* m = l1;<br>        ListNode* n = l2;<br>        <span class="hljs-type">int</span> z = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (m != <span class="hljs-literal">nullptr</span> || n != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">nullptr</span>) &#123;<br>                x = m-&gt;val;<br>                m = m-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (n != <span class="hljs-literal">nullptr</span>) &#123;<br>                y = n-&gt;val;<br>                n = n-&gt;next;<br>            &#125;<br>            z = x + y + p-&gt;val;<br>            p-&gt;val = z % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (z &lt; <span class="hljs-number">10</span> &amp;&amp; m == <span class="hljs-literal">nullptr</span> &amp;&amp; n == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">break</span>;<br>            p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(z &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>第一直觉提取链表元素组装为两个整数，相加后转换为字符串再填充链表，但是<font color=red>存在数据溢出问题</font>，题目提示已给出了每个链表中的节点数在范围 [1, 100] 内，意味着单个链表表示最大的整数为 10^101 -1</li><li>关键 <strong>链表逆序排列</strong>，模拟加法从低到高逐位计算过程，同步遍历两个链表</li><li><strong>进位</strong>问题</li><li>优化点：较短链表处理完后，根据进位条件，将较长链表剩余部分直接拼接到结果链表上，减少循环次数</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单链表</tag>
      
      <tag>加法模拟</tag>
      
      <tag>整数溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.两数之和</title>
    <link href="/2024/04/13/leetcode/01.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/04/13/leetcode/01.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="01-两数之和"><a href="#01-两数之和" class="headerlink" title="01.两数之和"></a>01.两数之和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>       std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash_map;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (hash_map.<span class="hljs-built_in">find</span>(target - nums[i]) != hash_map.<span class="hljs-built_in">end</span>()) &#123;<br>          <span class="hljs-keyword">return</span> &#123;hash_map[target - nums[i]], i&#125;;<br>        &#125;<br>        hash_map[nums[i]] = i;<br>       &#125;<br>       <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><ol><li>双循环暴力枚举可解，但是时间复杂度为O(n^2)。</li><li>空间换时间思路，基于<mark><strong>哈希表</strong>查找时间复杂度为O(1)</mark>，将遍历过的元素存入哈希表，将问题转换为：查找哈希表中是否存在 value 是否等于 target - nums[i] 的元素。</li><li>哈希表 key 为数组元素，value 为数组下标。</li><li>C++ 中典型的哈希表实现为 <code>std::unordered_map</code> 和 <code>std::unordered_set</code>，查找元素时间复杂度为 O(1)。</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13. 罗马数字转整数</title>
    <link href="/2024/04/12/leetcode/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <url>/2024/04/12/leetcode/13.%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>规则同题【12.整数转罗马数字】，只是转换方向相反，由罗马数字转换为整数。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：从小到大遍历"><a href="#解法一：从小到大遍历" class="headerlink" title="解法一：从小到大遍历"></a>解法一：从小到大遍历</h3><p>由于罗马数字中，”V”、”X”、”L”、”C”、”D”、”M” 这几个字符可能存在前缀，因此当遇到这几个字符时，需要额外判断前一位是否为对应的前缀。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;I&#x27;</span>) &#123;<br>        x += <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;V&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;I&#x27;</span>) &#123;<br>          x += <span class="hljs-number">4</span>;<br>          i--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          x += <span class="hljs-number">5</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>         <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;I&#x27;</span>) &#123;<br>          x += <span class="hljs-number">9</span>;<br>          i--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          x += <span class="hljs-number">10</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;L&#x27;</span>) &#123;<br>         <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>          x += <span class="hljs-number">40</span>;<br>          i--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          x += <span class="hljs-number">50</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;C&#x27;</span>) &#123;<br>         <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>          x += <span class="hljs-number">90</span>;<br>          i--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          x += <span class="hljs-number">100</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;D&#x27;</span>) &#123;<br>         <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;C&#x27;</span>) &#123;<br>          x += <span class="hljs-number">400</span>;<br>          i--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          x += <span class="hljs-number">500</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;M&#x27;</span>) &#123;<br>         <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;C&#x27;</span>) &#123;<br>          x += <span class="hljs-number">900</span>;<br>          i--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          x += <span class="hljs-number">1000</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>硬编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12. 整数转罗马数字</title>
    <link href="/2024/04/12/leetcode/12.%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <url>/2024/04/12/leetcode/12.%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><table><thead><tr><th align="left">字符</th><th align="left">数值</th></tr></thead><tbody><tr><td align="left">I</td><td align="left">1</td></tr><tr><td align="left">V</td><td align="left">5</td></tr><tr><td align="left">X</td><td align="left">10</td></tr><tr><td align="left">L</td><td align="left">50</td></tr><tr><td align="left">C</td><td align="left">100</td></tr><tr><td align="left">D</td><td align="left">500</td></tr><tr><td align="left">M</td><td align="left">1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给你一个整数，将其转为罗马数字。</p><p>示例 1:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入: num = 3<br>输出: &quot;III&quot;<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入: num = 4<br>输出: &quot;IV&quot;<br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入: num = 9<br>输出: &quot;IX&quot;<br></code></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入: num = 58<br>输出: &quot;LVIII&quot;<br>解释: L = 50, V = 5, III = 3.<br></code></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入: num = 1994<br>输出: &quot;MCMXCIV&quot;<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; num &lt;&#x3D; 3999</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="解法一：-贪心算法"><a href="#解法一：-贪心算法" class="headerlink" title="解法一： 贪心算法"></a>解法一： 贪心算法</h3><p>根据题意，罗马数字存在固定的组合，我们只需要从大到小枚举所有的组合即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  std::string Roman[<span class="hljs-number">13</span>] = &#123;<span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;CM&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;IX&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>&#125;; <br>  <span class="hljs-type">int</span> Value[<span class="hljs-number">13</span>] = &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">900</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::string <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    std::string res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>      <span class="hljs-keyword">while</span> (num &gt;= Value[i]) &#123;<br>        num -= Value[i];<br>        res += Roman[i];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用 if-else 优化速度和内存消耗：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>  std::string res;<br>  <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (num - <span class="hljs-number">1000</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">1000</span>;<br>      res += <span class="hljs-string">&#x27;M&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">900</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">900</span>;<br>      res += <span class="hljs-string">&quot;CM&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">500</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">500</span>;<br>      res += <span class="hljs-string">&quot;D&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">400</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">400</span>;<br>      res += <span class="hljs-string">&quot;CD&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">100</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">100</span>;<br>      res += <span class="hljs-string">&quot;C&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">90</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">90</span>;<br>      res += <span class="hljs-string">&quot;XC&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">50</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">50</span>;<br>      res += <span class="hljs-string">&quot;L&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">40</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">40</span>;<br>      res += <span class="hljs-string">&quot;XL&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">10</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">10</span>;<br>      res += <span class="hljs-string">&quot;X&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">9</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">9</span>;<br>      res += <span class="hljs-string">&quot;IX&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">5</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">5</span>;<br>      res += <span class="hljs-string">&quot;V&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">4</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">4</span>;<br>      res += <span class="hljs-string">&quot;IV&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>      num -= <span class="hljs-number">1</span>;<br>      res += <span class="hljs-string">&quot;I&quot;</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法二：硬编码"><a href="#解法二：硬编码" class="headerlink" title="解法二：硬编码"></a>解法二：硬编码</h3><p>官方题解给出了 <strong>硬编码</strong> 的解法，根据罗马数字的特点，可以将 13 个符号分成千位，百位，十位和个位，将每个位的所有情况硬编码成一个映射表，然后根据数字的每一位去查找对应 Roman 数字。</p><p><img src="https://assets.leetcode-cn.com/solution-static/12/3.png" alt="硬编码表"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> string thousands[] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;MM&quot;</span>, <span class="hljs-string">&quot;MMM&quot;</span>&#125;;<br><span class="hljs-type">const</span> string hundreds[]  = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;CC&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;CD&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;DC&quot;</span>, <span class="hljs-string">&quot;DCC&quot;</span>, <span class="hljs-string">&quot;DCCC&quot;</span>, <span class="hljs-string">&quot;CM&quot;</span>&#125;;<br><span class="hljs-type">const</span> string tens[]      = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XX&quot;</span>, <span class="hljs-string">&quot;XXX&quot;</span>, <span class="hljs-string">&quot;XL&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>, <span class="hljs-string">&quot;LX&quot;</span>, <span class="hljs-string">&quot;LXX&quot;</span>, <span class="hljs-string">&quot;LXXX&quot;</span>, <span class="hljs-string">&quot;XC&quot;</span>&#125;;<br><span class="hljs-type">const</span> string ones[]      = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;II&quot;</span>, <span class="hljs-string">&quot;III&quot;</span>, <span class="hljs-string">&quot;IV&quot;</span>, <span class="hljs-string">&quot;V&quot;</span>, <span class="hljs-string">&quot;VI&quot;</span>, <span class="hljs-string">&quot;VII&quot;</span>, <span class="hljs-string">&quot;VIII&quot;</span>, <span class="hljs-string">&quot;IX&quot;</span>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> thousands[num / <span class="hljs-number">1000</span>] + hundreds[num % <span class="hljs-number">1000</span> / <span class="hljs-number">100</span>] + tens[num % <span class="hljs-number">100</span> / <span class="hljs-number">10</span>] + ones[num % <span class="hljs-number">10</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>罗马数字组合有限且确定，从大到小逐位枚举即可；</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>硬编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于字符串转换整数 (atoi) 的思考</title>
    <link href="/2024/04/11/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2024/04/11/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="关于字符串转换整数-atoi-的思考"><a href="#关于字符串转换整数-atoi-的思考" class="headerlink" title="关于字符串转换整数 (atoi) 的思考"></a>关于字符串转换整数 (atoi) 的思考</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近解了一道 LeetCode 中的算法题: <em>8.字符串转换整数 (atoi)</em> ，描述如下:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。<br><br>函数 myAtoi(string s) 的算法如下：<br><br>1. 读入字符串并丢弃无用的前导空格<br>2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>4. 将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>5. 如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。<br>6. 返回整数作为最终结果。<br></code></pre></td></tr></table></figure><p>在 AC 后，看了官方和其他人的题解，了解到了一个不曾涉及到过的知识点:有限状态机 (Finite State Automaton) 和确定性有限自动机 (Deterministic Finite Automaton, DFA)。</p><p>因此在这里记录一下解决这个题目，并学习这个新知识点的过程。</p><h2 id="解法一、正则表达式-“-0-9-”"><a href="#解法一、正则表达式-“-0-9-”" class="headerlink" title="解法一、正则表达式 “^ *([\\-\\+]?[0-9]+)”"></a>解法一、正则表达式 “^ *([\\-\\+]?[0-9]+)”</h2><h3 id="提取有效整数字符串"><a href="#提取有效整数字符串" class="headerlink" title="提取有效整数字符串"></a>提取有效整数字符串</h3><p>在最开始看到这个题目的时候，厘清题干对数字有效性的要求后，可以将这个特征提取为以下正则表达式: </p><p><code>^ *([\\-\\+]?[0-9]+)</code></p><p>根据题干的第一点，我们可知，字符串可能存在前导空格，因此我们这里用 <code>^ *</code> 来匹配字符串起始位置的 0 个或多个 ‘ ‘ 空格。</p><p>然后题干第 2 点表明，可能存在正负符号，用于解释当前待转换字符串整数的正负性。这里需要注意，**’+&#x2F;-‘ 符号只能为 0 个或 1 个**。因为根据第 3 点的描述，在读入正负号后，下一个字符如果为非数字字符，则剩余部分会被全部忽略。所以我们使用 <code>[\\-\\+]?</code> 来匹配 0 个或 1 个 ‘-‘ 或 ‘+’ 符号。</p><p>在去掉前导空格和读取正负符号后，只能是数字字符，并且应该是** 1 个或多个**时，当前数字才有效。所以用 <code>[0-9]+</code> 来匹配 1 个或多个数字字符。</p><p>通过这个正则表达式即可判断当前字符串是否能被转换为有效的整数，并且使用 <code>()</code> 的子表达式方法可以直接提取出整数的有效部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用正则表达式和 std::stoi </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>        <span class="hljs-function">std::regex <span class="hljs-title">re</span><span class="hljs-params">(<span class="hljs-string">&quot;^ *([\\+\\-]?[0-9]+)&quot;</span>)</span></span>;<br>        std::smatch m;<br>        std::string sub;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">regex_search</span>(s, m, re)) &#123;<br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>                sub = m[<span class="hljs-number">1</span>].<span class="hljs-built_in">str</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sub.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stoi</span>(sub.<span class="hljs-built_in">c_str</span>());<br>            &#125; <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>                <span class="hljs-keyword">return</span> sub[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> ? INT_MIN : INT_MAX;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然要转换成数字还有一个 signed int 类型的溢出问题。</p><h3 id="signed-int-溢出判断"><a href="#signed-int-溢出判断" class="headerlink" title="signed int 溢出判断"></a>signed int 溢出判断</h3><blockquote><p>溢出判断时每个解法都需要考虑的问题，后续几种解法中的溢出判断也都是这一章节中所提到的，因此在后续解法中不在重复描述。</p></blockquote><h4 id="std-stoi-和-out-of-range"><a href="#std-stoi-和-out-of-range" class="headerlink" title="std::stoi 和 out of range"></a>std::stoi 和 out of range</h4><p>最开始的时候，为了方便，直接使用 <code>std::stoi</code> 来进行转换，这个函数能直接转换带 ‘+’ 和 ‘-‘ 的整数，并且在溢出时会抛出 “out of range” 的异常，因此只要一个 <code>try-catch</code> 就可以解决，具体应用可见上一节中给出的代码示例。</p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>如果说使用 <code>std::stoi</code> 也太犯规了，那么换种思路，通过整数字符串 s 和 INT_MIN (-2147483648), INT_MAX (2147483647) 的字符串进行比较，也是一种判断溢出的方法。并且该方法在判断完成后再转换为 int 类型，一定不会造成溢出问题。</p><p>使用字符串比较需要注意两个点:</p><ol><li>整数字符串可能存在 ‘+&#x2F;-‘ 符号，比较前需要统一，即两个字符串要么都有符号，要么都没有符号；</li><li>比较过程中需保持整数字符串 s 和 INT_MIN, INT_MAX 字符串长度一致，较短字符串前部追加 ‘0’ 字符；</li></ol><h4 id="乘法判断"><a href="#乘法判断" class="headerlink" title="乘法判断"></a>乘法判断</h4><p>由于 string 转换成 int 是必经之路，因此我们在逐位转换过程中直接比较乘法结果是否溢出即可。</p><p>一个整数字符串 s 转换成整数 (不考虑符号，因为不考虑符号的情况下判断溢出，永远只需要判断 ‘&gt;’ 即可，可有效减少判断条件数量) 的过程，只需要重复计算 <code>num = num * 10 + s[i] - &#39;0&#39;</code>，这里我们限制只能使用 int 类型存储 res，因此我们需要在每次计算之前就进行判断，否则在计算过程中会提示溢出错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (溢出) &#123;<br>  <span class="hljs-keyword">return</span> (符号 == <span class="hljs-string">&#x27;-&#x27;</span>) ? INT_MIN : INT_MAX;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  num = num * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>会溢出的情况有以下几种：</p><ol><li>当前为负数，且 num &gt;  INT_MAX &#x2F; 10 (为什么是 INT_MAX &#x2F; 10？因为此时的 num 不考虑符号，那么 INT_MAX &#x2F; 10 和 -INT_MIN &#x2F; 10 结果是一样的，都等于 ‘214748364’)；</li><li>当前为负数，且 num &#x3D;&#x3D; INT_MAX &#x2F; 10 且 s[i] &gt; ‘8’;</li><li>当前为正数，且 num &gt;  INT_MAX &#x2F; 10;</li><li>当前为正数，且 num &#x3D;&#x3D; INT_MAX &#x2F; 10 且 s[i] &gt; ‘7’;</li></ol><p>看似有 4 种情况，但是实际上，我们可以将问题优化为 2 种情况：</p><ol><li>num &gt; INT_MAX &#x2F; 10;</li><li>num &#x3D;&#x3D; INT_MAX &#x2F; 10 且 s[i] &gt; ‘7’;</li></ol><p>为什么正数和负数的情况下，一个是 <code>s[i] &gt; &#39;7&#39;</code>，一个是 <code>s[i] &gt; &#39;8&#39;</code> 可以统一为 <code>s[i] &gt; 7</code> 呢？</p><p>这是因为当负数 num &#x3D;&#x3D; INT_MAX &#x2F; 10 且 s[i] &#x3D;&#x3D; ‘8’ 时，我们假定此时已经溢出直接返回 INT_MIN ，和未溢出继续计算 <code>num = num * 10 + s[i] - &#39;0&#39;</code> 的结果都是 INT_MIN。</p><p>但是继续计算的话，由于我们在此前将 num 符号去除了，也就意味着 num 作为一个非负数始终应该小于 INT_MAX，但是当 num &#x3D;&#x3D; INT_MAX &#x2F; 10 且 s[i] &#x3D;&#x3D; ‘8 时，结果已经溢出了。</p><p>所以我们不妨将这种情况也视为已溢出，将溢出条件极大的简化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (num &gt; INT_MAX / <span class="hljs-number">10</span> || (num == INT_MAX / <span class="hljs-number">10</span> &amp;&amp; s[i] &gt; <span class="hljs-string">&#x27;7&#x27;</span>)) &#123;<br>  <span class="hljs-keyword">return</span> (符号 == <span class="hljs-string">&#x27;-&#x27;</span>) ? INT_MIN : INT_MAX;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  num = num * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二、确定性有限状态机-DFA"><a href="#解法二、确定性有限状态机-DFA" class="headerlink" title="解法二、确定性有限状态机 (DFA)"></a>解法二、确定性有限状态机 (DFA)</h2><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p><strong>状态机（State Machine）</strong>是一种抽象的计算模型，用于描述一个系统或算法在不同状态之间的转换和行为。它可以被用来建模各种问题，从简单的逻辑控制到复杂的软件系统。状态机通常由以下几个部分组成：</p><ol><li><p><strong>状态（State）：</strong> 系统可能处于的不同状态。每个状态代表系统的某种特定行为或情况。例如，自动售货机可以处于”待命”、”投币”、”出售”等状态。</p></li><li><p><strong>事件（Event）：</strong> 引起状态转换的外部或内部事件。当事件发生时，系统可以从当前状态转移到新的状态。例如，自动售货机可能会接收到”投币”、”选择商品”等事件。</p></li><li><p><strong>转移（Transition）：</strong> 从一个状态到另一个状态的过渡，通常与事件相关联。转移描述了当某个特定事件发生时系统如何从一个状态切换到另一个状态。</p></li><li><p><strong>动作（Action）：</strong> 在状态转换时执行的操作或行为。动作可以是更新内部状态、输出信息、执行计算等。例如，当自动售货机从”投币”状态转移到”出售”状态时，会扣除相应金额并输出商品。</p></li><li><p><strong>初始状态（Initial State）：</strong> 系统在开始时所处的状态。</p></li><li><p><strong>终止状态（Final State）：</strong> 系统的终止状态，表示系统已经完成了某个任务或达到了某个目标。</p></li></ol><p>状态机可以分为有限状态机（Finite State Machine，FSM）和无限状态机（Infinite State Machine）。在有限状态机中，状态的数量是有限的，状态之间的转换也是有限的；而在无限状态机中，状态的数量是无限的，状态之间的转换也可以是无限的。</p><p>状态机在计算机科学领域有着广泛的应用，例如在编译器设计、网络协议分析、游戏开发等方面都能看到它的身影。</p><h3 id="确定性有限状态机（Deterministic-Finite-Automaton，DFA）"><a href="#确定性有限状态机（Deterministic-Finite-Automaton，DFA）" class="headerlink" title="确定性有限状态机（Deterministic Finite Automaton，DFA）"></a>确定性有限状态机（Deterministic Finite Automaton，DFA）</h3><p>确定性有限状态机（Deterministic Finite Automaton，DFA）是有限状态机（Finite State Machine，FSM）的一个子集。DFA 是一种特殊类型的有限状态机，其特点是在给定状态和输入字符的情况下，只有一种确定的状态转移路径。</p><p>与一般的有限状态机相比，确定性状态机具有以下不同之处：</p><ol><li><p><strong>确定性：</strong> DFA 在任何给定时刻都有一个唯一的状态，且从当前状态和输入字符出发只能转移到一个确定的下一个状态。这种确定性使得 DFA 在状态转移和行为方面更加可预测和简单。</p></li><li><p><strong>状态转移表：</strong> DFA 可以使用状态转移表来描述状态之间的转移关系。在状态转移表中，每一行代表一个状态，每一列代表一个输入字符，表格中的每个元素表示从当前状态经过对应输入字符转移到的下一个状态。这种表格形式的表示使得 DFA 的状态转移过程变得直观和易于理解。</p></li><li><p><strong>非确定性：</strong> 与非确定性有限状态机（Non-deterministic Finite Automaton，NFA）相比，DFA 不允许存在一个状态在给定输入字符的情况下具有多个可能的转移路径。这种特性使得 DFA 在状态转移和行为方面更加确定和可靠。</p></li></ol><p>总的来说，确定性状态机是有限状态机中的一种特殊形式，它的确定性和简单性使得它在许多实际应用中得到了广泛的应用，例如在编译器设计、字符串匹配算法、网络协议分析等领域。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>这里直接引用 LeetCode 官方题解中的图示，方便理解。</p></blockquote><h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><p>根据题干，我们可以定义这几个状态：</p><ol><li><strong>起始空格状态 (start)：</strong> 从起始位置开始的空格状态；</li><li><strong>符号位状态 (signed)：</strong> 正负号位状态；</li><li><strong>数字状态 (in_number)：</strong> 数字状态；</li><li><strong>结束状态 (end)：</strong> 结束状态；</li></ol><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>在这个算法题中，事件即<strong>读取一个字符</strong>。</p><h4 id="状态转移表"><a href="#状态转移表" class="headerlink" title="状态转移表"></a>状态转移表</h4><p><img src="https://assets.leetcode-cn.com/solution-static/8/fig1.png" alt="状态转移图"></p><p>可以看出，每读取一个字符，对应的状态均是唯一确定的，因此根据上图，我们可以得到以下状态转移表：</p><table><thead><tr><th align="center">state</th><th align="center">‘ ‘</th><th align="center">+&#x2F;-</th><th align="center">number</th><th align="center">other</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">start</td><td align="center">signed</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">signed</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">in_number</td><td align="center">end</td><td align="center">end</td><td align="center">in_number</td><td align="center">end</td></tr><tr><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td></tr></tbody></table><p>我们可以直接使用一个 <code>std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt;</code> 来表示这个状态转移表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; stat_tb = &#123;<br>  &#123;<span class="hljs-string">&quot;start&quot;</span>, &#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>  &#123;<span class="hljs-string">&quot;signed&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>  &#123;<span class="hljs-string">&quot;in_number&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>  &#123;<span class="hljs-string">&quot;end&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>有了上面的状态转移表，我们只需要每读取一个字符，然后判断状态，并转移状态，在转换整数时结合上一章节中提到的溢出判断，即可完成字符串到整数的转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 利用 DFA (确定性有限自动机) 解决该问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 设置状态转移表</span><br>  std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; stat_tb = &#123;<br>    &#123;<span class="hljs-string">&quot;start&quot;</span>, &#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;sign&quot;</span>, <span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>    &#123;<span class="hljs-string">&quot;sign&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>    &#123;<span class="hljs-string">&quot;num&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>    &#123;<span class="hljs-string">&quot;end&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>  &#125;;<br><br>  <span class="hljs-comment">// 根据当前输入字符，获取状态</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getch</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>, sign = <span class="hljs-number">1</span>, lim_a = INT_MAX / <span class="hljs-number">10</span>, lim_b = INT_MAX % <span class="hljs-number">10</span>;<br>    std::string stat = <span class="hljs-string">&quot;start&quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>      <span class="hljs-comment">// 此处使用下标的方式读取当前字符输入状态转移结果，极大简化了判断条件</span><br>      stat = stat_tb[stat][<span class="hljs-built_in">getch</span>(c)];<br>      <span class="hljs-keyword">if</span> (stat == <span class="hljs-string">&quot;sign&quot;</span>) &#123;<br>        sign = c == <span class="hljs-string">&#x27;-&#x27;</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (stat == <span class="hljs-string">&quot;num&quot;</span>) &#123;<br>        <span class="hljs-comment">// 溢出判断</span><br>        <span class="hljs-keyword">if</span> (num &gt; lim_a || (num == lim_a &amp;&amp; c - <span class="hljs-string">&#x27;0&#x27;</span> &gt; lim_b)) &#123;<br>          <span class="hljs-keyword">return</span> sign == <span class="hljs-number">-1</span> ? INT_MIN : INT_MAX;<br>        &#125;<br>        num = num * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (stat == <span class="hljs-string">&quot;end&quot;</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num * sign;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>官方题解中使用 map 和 vector 的组合来存储状态转移表，并且通过下标的方式读取输入字符后状态转移的结果，这一设计非常巧妙，值得学习。</p><p>当然我们单纯使用 <code>if-else</code> 完成判断并转移状态，也是可以的，只不过代码会相对长一些，这也是我在了解状态机后手搓的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123; Start, Signed, Number, End &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(std::string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> stat_ = Start, num_ = <span class="hljs-number">0</span>, sig_ = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> lim_a = INT_MAX / <span class="hljs-number">10</span>, lim_b = INT_MAX % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s) &#123;<br>            <span class="hljs-keyword">switch</span> (stat_) &#123;<br>            <span class="hljs-keyword">case</span> Start: &#123;<br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                    stat_ = Start;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;+&#x27;</span> || ch == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                    stat_ = Signed;<br>                    sig_ = (ch == <span class="hljs-string">&#x27;-&#x27;</span>) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(ch)) &#123;<br>                    stat_ = Number;<br>                    num_ = num_ * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    stat_ = End;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> Signed: &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(ch)) &#123;<br>                    stat_ = Number;<br>                    num_ = num_ * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    stat_ = End;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> Number: &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(ch)) &#123;<br>                    <span class="hljs-keyword">if</span> (num_ &gt; lim_a || (num_ == lim_a &amp;&amp; ch - <span class="hljs-string">&#x27;0&#x27;</span> &gt; lim_b)) &#123;<br>                        <span class="hljs-keyword">return</span> sig_ == <span class="hljs-number">-1</span> ? INT_MIN : INT_MAX;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        num_ = num_ * <span class="hljs-number">10</span> + (ch - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    stat_ = End;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> End: &#123;<br>                <span class="hljs-keyword">return</span> num_ * sig_;<br>            &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num_ * sig_;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>吐槽一句，使用 <code>std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt;</code> 的代码看起来简洁很多，但是在实际运行时，和 使用 <code>if-else</code> 的代码相比，性能差距大的不是一点半点…使用上面第二种我手搓的代码，AC 显示耗时 0ms，但是官方题解需要 11 ms…所以也不能一味的追求代码的简短 囧。。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>在工作业务中，如果并非追求极致的造轮子，合理应用<strong>正则表达式</strong>和标准库函数来解决业务问题，也不失为一种好的选择；</li><li><strong>溢出边界的判断条件</strong>优化，是简化代码的关键；</li><li>使用<strong>确定性有限状态机</strong>解决这类问题（有输入，根据输入可确定唯一状态），是一种非常清晰好理解，并且简洁的解决方案；</li></ol>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>leetcode</tag>
      
      <tag>确定有限状态机</tag>
      
      <tag>DFA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Media-Download-Helper 项目说明</title>
    <link href="/2024/03/08/Media-Download-Helper%20%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/"/>
    <url>/2024/03/08/Media-Download-Helper%20%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="Media-Download-Helper"><a href="#Media-Download-Helper" class="headerlink" title="Media-Download-Helper"></a>Media-Download-Helper</h1><p>完整部署教程请参考：<a href="https://github.com/Ccccx159/Media-Download-Helper/blob/v2.0.0/doc/Media-Download-Helper%20%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B.md">Media-Download-Helper 完整部署教程</a></p><h2 id="V2-0-0-版本说明"><a href="#V2-0-0-版本说明" class="headerlink" title="V2.0.0 版本说明"></a>V2.0.0 版本说明</h2><blockquote><p>鉴于公网 IP 难以获取，而且将内部服务直接暴露到公网环境，安全系数较低，部署难度较大等几个原因，因此在 v2.0.0 版本中，取消了 http server 模块，由 media download helper 直接向 Google Apps Script 主动发起 get 请求进行轮询获取磁力链接信息。去除了公网 ip 的依赖，提高安全性的同时也增加了部署的便利性。</p><p>当然，v2.0.0 并非完美的方案，它同样存在着弊端，就是轮询请求 Google Apps Script 部署的在线 Web 应用的间隔不好把控。目前版本设置的轮询间隔为 1 分钟，这也就意味着 Google Apps Script 的 web 应用一天需要相应 1440 次请求，如果可以，请考虑使用更长的轮询间隔，避免薅羊毛过狠导致后期不可用的情况出现。</p><p>还有一点，v2.0.0 版本中，Google Apps Script 仅仅通过脚本属性字段来缓存接收到的 post 数据，这里也存在着未知的风险。</p><p>如果条件允许的情况下，还是推举使用 v1.x.x 版本，由 google apps script 响应 post 请求时，直接将数据推送到 Media Download Helper 内置的 http server，避免了缓存和并发的问题。</p><p>当然，轻度使用场景下，v2.0.0 版本也是可以接受的。</p></blockquote><h2 id="开发目的"><a href="#开发目的" class="headerlink" title="开发目的"></a>开发目的</h2><p>玩个人影视服务器的朋友，应该都知道 Jeckett，Sonarr，Radarr 这些自动下载工具，只要我添加了对应的 PT 站，它们就能根据提交的请求进行检索下载。但是部分资源可能不在 PT 站，尤其是部分生肉，外网的磁力链接发布的更快一些，例如 TG 上的一些频道。Radarr 和 Sonarr 不支持直接使用磁力链接进行下载，在外也不方便使用这些内网的服务。</p><p>再者有部分朋友也不想弄 PT 和上面说的那些服务，只是偶尔有部分资源想下载下来观看一下，完整部署自动化追剧工具就显得有点大材小用了。</p><p>所以才想开发一个小工具，借助免费的工具就可以实现在外远程进行下载，同时还可以在下载完成后通过电报机器人推送影片信息，方便查看下载信息。</p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p><strong>“Media Download Helper”</strong> 是一个基于电报机器人，Google Apps Script 和 qbittorrent 的多媒体下载助手。</p><p>用户可通过向 tg bot 发送影片的磁力链接，通过部署的 Google Apps Script 在线 web 应用转发至 Media Download Helper。Media Download Helper 将通过 qbittorrent web API 下载该磁力链接，并支持查重功能，根据磁链中的 hash 值判重，如果 qbittorrent 中已存在该 hash 值的 torrent，则不再重复下载，通过 tg bot 返回 “xxxxxx 已存在，请勿重复下载”给用户。</p><p>除了提供下载功能以外，Media Download Helper 还支持在下载完成后，根据磁力链接中的文件名，对 TMDB 数据库进行检索，将检索到的影片信息通过 tg bot 返回给用户，具体效果图可见<a href="#%E6%95%88%E6%9E%9C%E5%9B%BE">下方章节</a>。( 说句题外话，这个推送的效果，本来是用在我另一个辅助 Emby 私人服务器针对入库影片进行推送发布消息的，感兴趣的朋友也可以试用一下，给点建议，项目地址：<a href="https://github.com/Ccccx159/watchdog_for_Emby">https://github.com/Ccccx159/watchdog_for_Emby</a> )</p><h2 id="各模块交互图"><a href="#各模块交互图" class="headerlink" title="各模块交互图"></a>各模块交互图</h2><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/module.png" alt="模块交互图"></p><h2 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h2><p>仅在 Python 3.11 环境下测试通过：</p><ul><li>python 3.11 (External module: requests, python-qbittorrent, colorlog)</li><li>Telegram Bot and it’s Token (鉴于电报资源丰富，尤其 <a href="https://t.me/RarbgPro">@RarbgPro</a>  频道发布的公开磁链，以及强大的 bot 功能，因此将用户交互客户端选择为 Telegram)</li><li>Google Apps Script (构建在线脚本，并注册为电报机器人的 webhook)</li><li>Qbittorrent with WebUI (磁链下载工具)</li><li>TMDB API Token (影视资源数据库，用于下载完成后进行检索，并传递相关信息给用户)</li></ul><p><del>这里需要注意，<code>Simple Http Server</code> 是在局域网内部部署的服务，如果没有将其暴露到公网环境下，那么 <code>Google Apps Scrip</code> 的在线脚本则无法访问 <code>Simple Http Server</code> 。所以，在部署在线脚本时，需要将 <code>Simple Http Server</code> 暴露到公网环境下。（此处可能存在安全风险，建议使用 https 和 cdn 来提高安全系数）</del></p><p>完整部署教程请参考：<a href="https://github.com/Ccccx159/Media-Download-Helper/blob/v2.0.0/doc/Media-Download-Helper%20%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B.md">Media-Download-Helper 完整部署教程</a></p><h2 id="环境变量说明"><a href="#环境变量说明" class="headerlink" title="环境变量说明"></a>环境变量说明</h2><table><thead><tr><th align="center">环境变量</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><code>QBIT_HOST</code></td><td align="left">Qbittorrent WebUI host 地址</td></tr><tr><td align="center"><code>QBIT_USER</code></td><td align="left">Qbittorrent WebUI username 用户名</td></tr><tr><td align="center"><code>QBIT_PASS</code></td><td align="left">Qbittorrent WebUI password 密码</td></tr><tr><td align="center"><code>BOT_TOKEN</code></td><td align="left">Telegram Bot Token</td></tr><tr><td align="center"><code>TMDB_API_TOKEN</code></td><td align="left">TMDB API Token</td></tr><tr><td align="center"><code>GOOGLE_APPS_SCRIPT_URL</code></td><td align="left">Googel Apps Script 部署的在线 web 应用网址</td></tr><tr><td align="center"><code>LOG_LEVEL</code></td><td align="left">(可选) 日志等级，默认 WARNING</td></tr><tr><td align="center"><code>LOG_EXPORT</code></td><td align="left">(可选) 日志导出到文件，默认 False</td></tr><tr><td align="center"><code>LOG_PATH</code></td><td align="left">(可选) 日志导出路径，默认 <code>/var/tmp/media_dlhelper_logs/</code></td></tr></tbody></table><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/demo-suc.png" alt="效果图"></p><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/demo-fail.png" alt="效果图"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://core.telegram.org/bots/api">Telegram Bot API 说明</a></li><li><a href="https://python-qbittorrent.readthedocs.io/en/latest/modules/api.html">Python Qbittorrent 接口文档</a></li><li><a href="https://github.com/qbittorrent/qBittorrent/wiki/">Qbittorrent 官方 API 文档</a></li><li><a href="https://www.dengnz.com/2020/11/23/telegram-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B/">Telegram 机器人的申请和设置图文教程</a></li><li><a href="https://www.dengnz.com/2018/09/05/telegram-bot-%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%9b%9e%e5%a3%b0%e6%9c%ba%e5%99%a8%e4%ba%ba-%e4%bd%a0%e6%98%af%e6%b1%a4%e5%a7%86%e7%8c%ab%e5%90%a7%e7%ac%ac%e4%ba%8c%e9%9b%86/">Telegram Bot 第一个回声机器人 – 你是汤姆猫吧[第二集]</a></li><li><a href="https://developer.themoviedb.org/reference/intro/getting-started">TMDB API 说明文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Google Apps Script</tag>
      
      <tag>TMDB</tag>
      
      <tag>qbittorrent</tag>
      
      <tag>Telegram bot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Media-Download-Helper 完整部署教程</title>
    <link href="/2024/03/08/Media-Download-Helper%20%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/"/>
    <url>/2024/03/08/Media-Download-Helper%20%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Media-Download-Helper-完整部署说明"><a href="#Media-Download-Helper-完整部署说明" class="headerlink" title="Media-Download-Helper 完整部署说明"></a>Media-Download-Helper 完整部署说明</h1><blockquote><p>前排提示：由于使用到了 Telegram、Google 等服务，所以当前方案不建议国内用户使用！</p></blockquote><h2 id="基于-docker-安装-qbittorrent-WebUI"><a href="#基于-docker-安装-qbittorrent-WebUI" class="headerlink" title="基于 docker 安装 qbittorrent WebUI"></a>基于 docker 安装 qbittorrent WebUI</h2><p>使用 docker 安装 qbittorrent 非常简单，教程也非常非常多，而且能看到这篇教程的人，我估计大部分可能正在使用 qbittorrent，因此这里就不在赘述了。</p><p>这里提供一个参考链接：<a href="https://juejin.cn/s/n1%20docker%E5%AE%89%E8%A3%85qb">《n1 docker安装qb》</a>。</p><blockquote><p>如果对 docker，参考链接中的 docker compose 部分不熟悉的话，还是先去学习一下相关的基础知识吧。</p></blockquote><p>在安装完成后，我们会获得一个 WebUI 的地址，形如：<code>http://192.168.1.123:8080/</code>，我们记录下来，一同需要记录的还有登录的用户名 <code>QBIT_USERNAME</code> 和密码 <code>QBIT_PASSWORD</code>。</p><blockquote><p>安装完成后，可以先手动下载一个文件试试，验证一下是否能正常下载磁力链接，以及下载后的文件是否能正常获取和使用。避免后续出现下载问题，例如无法联网，无法解析磁力链接，下载无速度，找不到下载的文件等。</p></blockquote><h2 id="申请-Telegram-Bot-并获取对应-Token"><a href="#申请-Telegram-Bot-并获取对应-Token" class="headerlink" title="申请 Telegram Bot 并获取对应 Token"></a>申请 Telegram Bot 并获取对应 Token</h2><p>这一部分不做详细介绍，网上教程非常多，直接按照本章节标题进行 Google 即可。</p><p>如果懒得 Google，也可以参考这篇文章<a href="https://www.dengnz.com/2020/11/23/telegram-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B/">《Telegram 机器人的申请和设置图文教程》</a>，里面的教程非常详细，原作者也由对应的油管视频可供参考，只要按部就班抄作业即可。</p><p>在此章节中，我们获取到了一个 **”Bot_TOKEN”**，在后续的配置和部署中会使用到。</p><h2 id="部署-Google-Apps-Script-在线脚本"><a href="#部署-Google-Apps-Script-在线脚本" class="headerlink" title="部署 Google Apps Script 在线脚本"></a>部署 Google Apps Script 在线脚本</h2><p>默认情况下，我们发送给 Telegram Bot 的消息是直接发送给 Telegram 官方服务器的，在这种情况下，我们无法获取到 Bot 接收到的数据并做出相应的处理和相应。</p><p>但是 Telegram 给我们提供了一个为 bot 设置 webhook 的方法 <code>/setwebhook?url=xxxx</code>，这样我们就可以通过 webhook 获取到用户发送的消息。这里我们通过 <strong>Google Apps Script</strong> 来实现这个功能。</p><blockquote><p>这一部分也是受到<a href="https://www.dengnz.com/2020/11/23/telegram-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B/">《Telegram 机器人的申请和设置图文教程》</a>作者的系列教程<a href="https://www.dengnz.com/2018/09/05/telegram-bot-%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%9b%9e%e5%a3%b0%e6%9c%ba%e5%99%a8%e4%ba%ba-%e4%bd%a0%e6%98%af%e6%b1%a4%e5%a7%86%e7%8c%ab%e5%90%a7%e7%ac%ac%e4%ba%8c%e9%9b%86/">《Telegram Bot 第一个回声机器人 – 你是汤姆猫吧[第二集]》</a>启发。原文中作者通过 Google Apps Script 实现了一个简单的回声机器人，并且在后续的系列文章中，扩展了不少 Telegram bot 的高级用法，感兴趣朋友的也可以参考参考。</p></blockquote><h3 id="步骤-1、创建-Google-Apps-Script-项目"><a href="#步骤-1、创建-Google-Apps-Script-项目" class="headerlink" title="步骤 1、创建 Google Apps Script 项目"></a>步骤 1、创建 Google Apps Script 项目</h3><p>打开 Google Apps Script 的<a href="https://script.google.com/home/start">官网</a>，点击右上角的 <code>新建</code> 按钮，创建一个新的项目。</p><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.png" alt="新建项目"></p><h3 id="步骤-2、编辑脚本的代码"><a href="#步骤-2、编辑脚本的代码" class="headerlink" title="步骤 2、编辑脚本的代码"></a>步骤 2、编辑脚本的代码</h3><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E7%BC%96%E8%BE%91%E8%84%9A%E6%9C%AC%E4%BB%A3%E7%A0%81.png" alt="编写代码"></p><h3 id="步骤-3、部署项目"><a href="#步骤-3、部署项目" class="headerlink" title="步骤 3、部署项目"></a>步骤 3、部署项目</h3><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B21.png" alt="部署项目1"></p><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B22.png" alt="部署项目2"></p><blockquote><p>授权时可能会出现风险提示界面，估计是挂了代理的缘故，按下图操作继续即可。</p></blockquote><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B23.png" alt="部署项目3"></p><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B24.png" alt="部署项目4"></p><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B25.png" alt="部署项目5"></p><h3 id="步骤-4、获取-Webhook-URL"><a href="#步骤-4、获取-Webhook-URL" class="headerlink" title="步骤 4、获取 Webhook URL"></a>步骤 4、获取 Webhook URL</h3><p>在上一步中，我们最终获取了一个 Web 应用的网址，我们可以直接将这个网址粘贴到浏览器地址栏进行访问，来验证部署是否成功，当显示 <code>&#123;&quot;status&quot;:&quot;OK&quot;,&quot;magnet_urls&quot;:[]&#125;</code> 时，表明已部署成功。 如下图所示：</p><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F.png" alt="部署成功"></p><p>我们还需要对这个 Web Url 进行一些处理，打开这个 Url Encode 网站 <a href="https://www.urlencoder.org/">https://www.urlencoder.org/</a>，将这个 url 进行编码，然后将编码后的 url 保存下来，后续会用。按下图操作即可：</p><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E7%BC%96%E7%A0%81URL.png" alt="UrlEncode"></p><p>至此我们已经完成了 Google Apps Script 在线脚本的部署，我们在这里获得了一个 **”原始 URL”**，和一个 **”编码后 URL”**。</p><h2 id="步骤-5、注册-Telegram-bot-Webhook"><a href="#步骤-5、注册-Telegram-bot-Webhook" class="headerlink" title="步骤 5、注册 Telegram bot Webhook"></a>步骤 5、注册 Telegram bot Webhook</h2><p>在这一步中，我们需要将上一步中获取到的 <strong>“编码后 URL”</strong> 注册到我们的 Telegram Bot 中，这样我们就可以通过 webhook 获取到用户发送的消息。</p><p>我们通过 Telegram Bot 的 API 来实现这个功能，这里用到两个 API，一个是 <code>setWebhook</code>，一个是 <code>getWebhookInfo</code>。</p><h3 id="步骤-5-1、注册"><a href="#步骤-5-1、注册" class="headerlink" title="步骤 5.1、注册"></a>步骤 5.1、注册</h3><p>我们使用 <strong>“Bot TOKEN”<strong>、</strong>“编码后 URL”</strong> 两个参数，按照以下格式完成 API 的组装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将 &#123;Bot TOKEN&#125; 替换为你的 Bot TOKEN</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 &#123;编码后 URL&#125; 替换为你的 编码后 URL</span><br>https://api.telegram.org/bot&#123;Bot TOKEN&#125;/setWebhook?url=&#123;编码后 URL&#125;<br></code></pre></td></tr></table></figure><p>然后将这个组装后的 url 粘贴到浏览器地址栏中进行访问，如果返回 <code>&#123;&quot;ok&quot;:true,&quot;result&quot;:true,&quot;description&quot;:&quot;Webhook was set&quot;&#125;</code>，则表示注册成功。如下图所示：</p><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F.png" alt="注册成功"></p><h3 id="步骤-5-2、验证"><a href="#步骤-5-2、验证" class="headerlink" title="步骤 5.2、验证"></a>步骤 5.2、验证</h3><p>我们可以通过 <code>getWebhookInfo</code> API 来验证是否注册成功，组装后的 url 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将 &#123;Bot TOKEN&#125; 替换为你的 Bot TOKEN</span><br>https://api.telegram.org/bot&#123;Bot TOKEN&#125;/getWebhookInfo<br></code></pre></td></tr></table></figure><p>然后将这个组装后的 url 粘贴到浏览器地址栏中进行访问，可以在返回结果中看到注册的 url，如下图所示：</p><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/%E9%AA%8C%E8%AF%81%E6%88%90%E5%8A%9F.png" alt="验证成功"></p><p>可以将图中红框部分的 URL 与我们在 <strong>步骤 4</strong> 中获取到的 <strong>“原始 URL”</strong> 进行对比，如果一致，则表示注册成功。</p><h2 id="申请-TMDB-API-Token"><a href="#申请-TMDB-API-Token" class="headerlink" title="申请 TMDB API Token"></a>申请 TMDB API Token</h2><p>想要达到 README.md 中展示的效果，在下载完成后将详细的影片信息推送到 Tg bot，则还需要一个 TMDB 的 API Token。</p><p>这里也不做赘述了，推荐一个网上的教程吧：<a href="https://post.smzdm.com/p/a5op4w33/"> 《教程篇 篇三：影视刮削必备神器——TMDB API申请攻略》 </a>。虽然发布日期比较久远了，但是流程估计整体也差不多，作者写的也比较详细，可以参考一下。</p><p>最终我们会获得下图中的 <strong>“API 密钥 (API Key)”</strong> 和 **”API 读访问令牌 (API Read Access Token)”**，在最新的<a href="https://developer.themoviedb.org/reference/intro/getting-started">官方 API 手册</a>中，官方推荐的是使用后者进行查询操作。</p><p><img src="https://github.com/Ccccx159/Media-Download-Helper/raw/v2.0.0/doc/.assert_Media-Download-Helper-%E5%AE%8C%E6%95%B4%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/TMDB_API_Token.png" alt="TMDB API Token"></p><p>因此我们将这个 **”API 读访问令牌”**保存下来即可，这个 Token 有点长，一定复制全，记得注意保护敏感数据哦 ~</p><h2 id="基于-docker-部署-Media-Download-Helper"><a href="#基于-docker-部署-Media-Download-Helper" class="headerlink" title="基于 docker 部署 Media-Download-Helper"></a>基于 docker 部署 Media-Download-Helper</h2><blockquote><p>本项目不是一定需要 docker 才能部署，使用 docker 只是为了保证环境的一致性，想必对 Python 比较熟悉的朋友也是对 Python 版本和各种依赖包的版本管理比较头疼的，使用 docker 可以很好的解决这个问题。</p><p>不过在最后我还是会补充一个脚本，方便部分朋友直接运行或者调试 ^ ^</p></blockquote><h3 id="docker-compose-部署"><a href="#docker-compose-部署" class="headerlink" title="docker-compose 部署"></a>docker-compose 部署</h3><p>如果有 docker-compose 的环境，则可以很方便使用仓库中 dockerfile&#x2F;docker-compose.yml 文件进行部署。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">media_dlhelper:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">.</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">dockerfile</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">b1gfac3c4t/media_dlhelper:v2.0.0</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>      <span class="hljs-comment"># 这里所有的环境变量都不要使用引号</span><br>      <span class="hljs-comment"># 必填参数</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">QBIT_HOST=&lt;your</span> <span class="hljs-string">qbittorrent</span> <span class="hljs-string">WebUI</span> <span class="hljs-string">base</span> <span class="hljs-string">API&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">QBIT_USER=&lt;your</span> <span class="hljs-string">qbittorrent</span> <span class="hljs-string">username&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">QBIT_PASS=&lt;your</span> <span class="hljs-string">qbittorrent</span> <span class="hljs-string">password&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">BOT_TOKEN=&lt;your</span> <span class="hljs-string">telegram</span> <span class="hljs-string">bot</span> <span class="hljs-string">token&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TMDB_API_TOKEN=&lt;your</span> <span class="hljs-string">TMDB</span> <span class="hljs-string">API</span> <span class="hljs-string">token&gt;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GOOGLE_APPS_SCRIPT_URL=</span> <span class="hljs-string">&lt;google</span> <span class="hljs-string">apps</span> <span class="hljs-string">scrip</span> <span class="hljs-string">部署后的原始web应用网址&gt;</span><br>      <span class="hljs-comment"># 可选参数</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LOG_LEVEL=INFO</span> <span class="hljs-comment"># [DEBUG, INFO, WARNING] 三个等级，默认 WARNING</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LOG_EXPORT=True</span> <span class="hljs-comment"># [True, False0] 是否将日志输出到文件，默认 False</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LOG_PATH=/var/tmp/media_dlhelper_logs/</span> <span class="hljs-comment"># 默认 /var/tmp/media_dlhelper_logs/</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">&quot;bridge&quot;</span><br></code></pre></td></tr></table></figure><p>只需要将上面的环境变量替换为自己的即可，然后执行 <code>docker-compose up -d</code> 即可完成部署。</p><h3 id="docker-run-部署"><a href="#docker-run-部署" class="headerlink" title="docker run 部署"></a>docker run 部署</h3><p>如果没有 docker-compose 的环境，也可以使用 docker run 的方式进行部署。直接执行下面的命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull b1gfac3c4t/media_dlhelper:v2.0.0<br>docker run -d \<br>  --name media_dlhelper \<br>  -e TZ=Asia/Shanghai \<br>  -e QBIT_HOST=&lt;your qbittorrent WebUI base API&gt; \<br>  -e QBIT_USER=&lt;your qbittorrent username&gt; \<br>  -e QBIT_PASS=&lt;your qbittorrent password&gt; \<br>  -e BOT_TOKEN=&lt;your telegram bot token&gt; \<br>  -e TMDB_API_TOKEN=&lt;your TMDB API token&gt; \<br>  -e GOOGLE_APPS_SCRIPT_URL=&lt;google apps scrip 部署后的原始web应用网址&gt; \<br>  -e LOG_LEVEL=INFO \<br>  -e LOG_EXPORT=True \<br>  -e LOG_PATH=/var/tmp/media_dlhelper_logs/ \<br>  --network=bridge \<br>  --restart=always \<br>  b1gfac3c4t/media_dlhelper:v2.0.0<br></code></pre></td></tr></table></figure><h3 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h3><p>如果不想使用 docker，也可以直接运行项目中的 main.py 文件，为了方便，这里提供了一个运行脚本，只要在项目的根目录下创建一个 run.sh 文件，然后将下面的内容复制进去，替换环境变量的值即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">export</span> QBIT_HOST=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-built_in">export</span> QBIT_USER=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-built_in">export</span> QBIT_PASS=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-built_in">export</span> BOT_TOKEN=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-built_in">export</span> TMDB_API_TOKEN=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-built_in">export</span> GOOGLE_APPS_SCRIPT_URL=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-built_in">export</span> LOG_LEVEL=<span class="hljs-string">&#x27;DEBUG&#x27;</span><br><span class="hljs-built_in">export</span> LOG_EXPORT=<span class="hljs-string">&#x27;True&#x27;</span><br><span class="hljs-built_in">export</span> LOG_PATH=<span class="hljs-string">&#x27;./log&#x27;</span><br><br><span class="hljs-built_in">nohup</span> python3 main.py &gt; /dev/null 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>保存后，直接运行 <code>sh run.sh</code> 即可。</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Google Apps Script</tag>
      
      <tag>TMDB</tag>
      
      <tag>qbittorrent</tag>
      
      <tag>Telegram bot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Moonlight Stream 和 SteamLink 远程串流失败问题解决</title>
    <link href="/2024/02/22/Moonlight%20Stream%20%E5%92%8C%20SteamLink%20%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <url>/2024/02/22/Moonlight%20Stream%20%E5%92%8C%20SteamLink%20%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Moonlight-Stream-和-SteamLink-远程串流失败问题解决"><a href="#Moonlight-Stream-和-SteamLink-远程串流失败问题解决" class="headerlink" title="Moonlight Stream 和 SteamLink 远程串流失败问题解决"></a>Moonlight Stream 和 SteamLink 远程串流失败问题解决</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用 Moonlight Stream 或者 SteamLink 进行远程串流时，如果远程 PC 重启，或者被其他设备使用远程桌面 (mstsc, rdp) 登录过，则会出现串流失败的问题:</p><ul><li><strong>SteamLink</strong>: 锁屏界面卡弹窗</li><li><strong>Moonlight Stream</strong>: 远程PC显示感叹号</li></ul><p>如下图所示：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/e79aa91c00f14e723488789aa484904b/1.png" alt="steamlink 连接失败"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/659e88a7a79c52a7b3ce62ea0225ceb3/4.jpg" alt="Moonlight 无法连接"></p><p>其实问题原因是重启或者远程登录都会导致远程 PC 被锁定，串流软件不具备解锁功能，换句话说，串流软件只能在远程 PC 处于解锁状态下才能正常工作。通俗点讲就是你需要在远程 PC 上输入锁屏密码解锁后，才能正常使用串流软件。</p><p>但是远程串流的场景大多情况下不具备手动解锁 PC 的条件，所以我们需要一种可以远程解锁的方法来解决这个问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决方法非常简单，本质上只需要借助 Windows 自带的一个命令 <code>tscon</code> 来注销当前的远程登录即可，先上代码：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bat">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-comment">@REM 获取当前会话的名称</span><br><span class="hljs-built_in">setlocal</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">@REM 获取对应的会话ID</span><br><span class="hljs-keyword">for</span> /f &quot;tokens=<span class="hljs-number">3</span>&quot; <span class="hljs-variable">%%i</span> <span class="hljs-keyword">in</span> (&#x27;query session ^| <span class="hljs-built_in">findstr</span> &quot;&gt;&quot;&#x27;) <span class="hljs-keyword">do</span> <span class="hljs-built_in">set</span> &quot;sessionid=<span class="hljs-variable">%%i</span>&quot;<br><span class="hljs-comment">@REM echo %sessionid%</span><br><span class="hljs-comment">@REM 如果会话ID存在，则关闭对应的会话</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">defined</span> sessionid (<br>    @<span class="hljs-variable">%windir%</span>\System32\tscon.exe <span class="hljs-variable">%sessionid%</span> /dest:console<br>) <span class="hljs-keyword">else</span> (<br>    <span class="hljs-built_in">echo</span> No session found <span class="hljs-keyword">for</span> <span class="hljs-variable">%sessionname%</span><br>)<br><span class="hljs-built_in">endlocal</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：鉴于会话 id 是动态的，所以我们需要通过 <code>query session</code> 命令来获取当前所有会话信息，并通过当前会话名称中包含 ‘&gt;’ 字符这一特征匹配来获取当前的会话 id，然后再通过 <code>tscon</code> 命令来关闭对应的会话。</p></blockquote><p>看不懂没关系，按照下面的操作步骤来操作即可：</p><ol><li>手机端使用 RDP 软件登录远程 PC</li><li>在桌面新建记事本，复制上面的代码到记事本中，然后保存为 <code>unlock.bat</code> 文件</li><li>右键 <code>unlock.bat</code> 文件，选择以管理员身份运行，此时会自动注销并退出当前远程连接，这是正常的，如果没有退出，则说明有问题需要检查</li><li>使用手机，平板等设备打开串流软件，连接远程 PC 即可</li></ol><p><mark>第三步中，如果远程连接没有退出，则说明注销当前会话失败了，此时仍然无法正常进行远程串流。</mark></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>如果你无法通过远程连接来注销会话并解锁 PC，则仍然无法解决问题。如果你想获取更多关于远程连接 PC 的内容，包括如何在公网环境下远程连接家里的 PC 等，可以参考我的另一篇文章，<a href="https://ccccx159.github.io/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/">《使用公网IPv6远程访问内网设备》</a>。</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>mstsc</tag>
      
      <tag>Moonlight Stream</tag>
      
      <tag>SteamLink</tag>
      
      <tag>bat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于TelegramBot和Qbittorrent打造下载机器人</title>
    <link href="/2024/02/22/%E5%9F%BA%E4%BA%8ETelegramBot%E5%92%8CQbittorrent%E6%89%93%E9%80%A0%E4%B8%8B%E8%BD%BD%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <url>/2024/02/22/%E5%9F%BA%E4%BA%8ETelegramBot%E5%92%8CQbittorrent%E6%89%93%E9%80%A0%E4%B8%8B%E8%BD%BD%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="基于-TelegramBot-和-Qbittorrent-打造下载机器人"><a href="#基于-TelegramBot-和-Qbittorrent-打造下载机器人" class="headerlink" title="基于 TelegramBot 和 Qbittorrent 打造下载机器人"></a>基于 TelegramBot 和 Qbittorrent 打造下载机器人</h1><p>[] 创建 telegram bot<br>[] 编写 Google apps script<br>[] bot 注册 webhook<br>[] 本地搭建 http server<br>[] 调用 qbittorrent web API 下载并监控<br>[] 下载完成后根据文件名向TMDB查询信息，并通过bot发送至telegram</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>TelegramBot</tag>
      
      <tag>qbittoorrent</tag>
      
      <tag>Google Apps Script</tag>
      
      <tag>TMDB</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次 UnRaid U盘损坏修复的过程</title>
    <link href="/2023/12/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%20UnRaid%20U%E7%9B%98%E6%8D%9F%E5%9D%8F%E4%BF%AE%E5%A4%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82%E3%80%82%E3%80%82/"/>
    <url>/2023/12/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%20UnRaid%20U%E7%9B%98%E6%8D%9F%E5%9D%8F%E4%BF%AE%E5%A4%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82%E3%80%82%E3%80%82/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次-unRaid-U盘损坏修复的过程。。。"><a href="#记一次-unRaid-U盘损坏修复的过程。。。" class="headerlink" title="记一次 unRaid U盘损坏修复的过程。。。"></a>记一次 unRaid U盘损坏修复的过程。。。</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间 unRAID 系统提示 flash 写失败了，没当回事，以为只是偶发的一次写错误，应该问题不大。</p><p>过了几天之后，在整理磁盘空间的时候，突然发现备份目录下有大概十几个的 boot 目录备份包，然而这些备份的压缩包本不应该出现在这里，而且这些压缩包的大小也存在异常，这就意味着 unRAID 已经有超过10天备份失败了。</p><p>这里说一下我预设的定时备份任务：每天凌晨 3 点自动打包 &#x2F;boot 目录，然后通过 rclone 将阿里云盘挂载到本地，通过文件名中的时间戳判断并删除 7 天之前的备份文件，之后将新的备份文件上传到阿里云盘上。</p><p>出现了这样的问题，不想折腾都不行了。。。</p><h2 id="尝试修复过程"><a href="#尝试修复过程" class="headerlink" title="尝试修复过程"></a>尝试修复过程</h2><h3 id="尝试-1-——-手动打包"><a href="#尝试-1-——-手动打包" class="headerlink" title="尝试 1 —— 手动打包"></a>尝试 1 —— 手动打包</h3><p>因为之前周末电工师傅来换空开，直接拉闸断电了，怀疑会不会是这个导致了异常，于是尝试手动拷贝 &#x2F;boot 目录，并进行手动打包。</p><p>拷贝倒是成功了，flash 中的 &#x2F;boot 目录直接能拷贝到硬盘的共享目录中，但是打包同样失败了，提示文件损坏，而且文件名是乱码。。。</p><h3 id="尝试-2-——-删除-Nvidia-Drive-Plugin"><a href="#尝试-2-——-删除-Nvidia-Drive-Plugin" class="headerlink" title="尝试 2 —— 删除 Nvidia Drive Plugin"></a>尝试 2 —— 删除 Nvidia Drive Plugin</h3><p>上次重启后，英伟达驱动莫名其妙掉了，然后尝试重新下载也提示下载失败，然而本来也是闲置的功能，而且本着能不折腾就不折腾的主旨，也是放任没管。</p><p>猜测打包失败会不会和 Nvidia Drive Plugin 下载驱动失败导致的问题，ssh 进入后台后查看 &#x2F;boot&#x2F;config&#x2F;plugin 中这个插件的目录，确实发现了几个大小异常的驱动包，和几个乱码的文件。</p><p><code>rm ./* -rf</code> 回车一敲，以为此次修复完美谢幕。删除后确实打包成功了，但是尝试重启后，直接无法启动了！出现了一堆错误日志，并且 web gui 无法启动，设置了自动挂载的阵列也没有挂载，docker 无法和 docker.sock 通信。。。什么鬼啊！</p><h3 id="尝试-3-——-重新制作-U-盘"><a href="#尝试-3-——-重新制作-U-盘" class="headerlink" title="尝试 3 —— 重新制作 U 盘"></a>尝试 3 —— 重新制作 U 盘</h3><p>排查错误不如我直接重做 U 盘，又快又不用动脑子，结果上官网一看 6.10.3 的下载链接已经从官网上下架了。。。我特意存储的备份系统镜像也在 unRaid 的阵列中。。。</p><p>翻箱倒柜找，终于在回收站里找到了之前下载的官方进行包。下载写盘器、写 U 盘、拷贝config、插 U 盘、开机，一气呵成。我嘞个豆。。。怎么还全是 ERROR 啊！！！</p><h3 id="尝试-4-——-解决-ERROR"><a href="#尝试-4-——-解决-ERROR" class="headerlink" title="尝试 4 —— 解决 ERROR"></a>尝试 4 —— 解决 ERROR</h3><p>不得已，只能解决 ERROR 了。</p><p>还好 unRAID 提示的还算清楚，仔细一看，嗨，这不是 docker 容器配置的 xml 解析失败了么，提示有格式错误。打开 U盘 中的 xml 检查了一下，确实有几个文件内容中出现了随机乱码的情况，导致格式错误。</p><p>将之前阿里云网盘上正确备份的文件下载下来，检查无误后替换错误文件，重启，这下总算是正常启动了。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>虽然系统正常了，但是问题的根本原因其实并没有找到。</p><p>目前仍然不清楚导致 docker 容器配置 xml 文件内容出现随机乱码的原因，怀疑的方向有几个：一是每天读 flash 进行备份，增大了 flash 出错的风险可能，毕竟 flash 不像硬盘那样耐*；二是拉闸断电导致的异常，不过这个我也没敢尝试复现，真出问题了，代价不小；三是 Nvidia Drive Plugin 出错，导致备份时出错，异常情况下导致 xml 出错。</p><p>由于之前备份都失败了，所以并不能确定 xml 出错的时间。几个猜测的点都是比较难去重现的，只能说后续使用上尽量谨慎一些吧。</p><p>Nvidia 的驱动插件，本来也是闲置的，所以不考虑重新安装了，而且万一后续有虚拟机直通显卡的需求，还得卸载。</p><p>备份策略也做了一定的修改，由原来的直接 tar 命令压缩 &#x2F;boot 目录，修改为将 &#x2F;boot&#x2F;config 目录拷贝至硬盘后再进行压缩备份。备份间隔也从每天，修改为每周。当有较大更新时，则手动触发备份。</p><h2 id="折腾"><a href="#折腾" class="headerlink" title="折腾"></a>折腾</h2><p>中国有句古话，“来都来了”。</p><p>嘿嘿，来都来了，不折腾一下，那不得抓耳挠腮，浑身奇痒难耐啊。所以去老毛子的论坛翻了翻，正好有 6.12.6 的包和 hack 文件。于是乎直接下载，替换，完美启动（老脸一红）！</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>flash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git —— Issue 模板</title>
    <link href="/2023/12/27/Git%20%E2%80%94%E2%80%94%20Issue%20%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/12/27/Git%20%E2%80%94%E2%80%94%20Issue%20%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-——-Issue-模板"><a href="#Git-——-Issue-模板" class="headerlink" title="Git —— Issue 模板"></a>Git —— Issue 模板</h1><h2 id="1-什么是-Issue-模板"><a href="#1-什么是-Issue-模板" class="headerlink" title="1. 什么是 Issue 模板"></a>1. 什么是 Issue 模板</h2><p>Issue 模板是在创建 Issue 时，预先填写好的内容，可以是一些提示性的文字，也可以是一些表单，用户在创建 Issue 时，可以根据模板填写内容，这样可以让 Issue 的内容更加规范，也方便了 Issue 的管理。</p><h2 id="2-如何使用-Issue-模板"><a href="#2-如何使用-Issue-模板" class="headerlink" title="2. 如何使用 Issue 模板"></a>2. 如何使用 Issue 模板</h2><h3 id="2-1-创建-Issue-模板"><a href="#2-1-创建-Issue-模板" class="headerlink" title="2.1 创建 Issue 模板"></a>2.1 创建 Issue 模板</h3><p>在项目的根目录下创建一个名为 <code>.gitlab</code> 的文件夹，然后在 <code>.gitlab</code> 文件夹下创建一个名为 <code>issue_templates</code> 的文件夹，然后在 <code>issue_templates</code> 文件夹下创建一个名为 <code>bug_report.md</code> 的文件，这个文件就是 Issue 模板了。</p><h3 id="2-2-编写-Issue-模板"><a href="#2-2-编写-Issue-模板" class="headerlink" title="2.2 编写 Issue 模板"></a>2.2 编写 Issue 模板</h3><p>在 <code>bug_report.md</code> 文件中，可以写一些提示性的文字，也可以写一些表单，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>name: Bug report<br>about: Create a report to help us improve<br>title: &#x27;&#x27;<br>labels: &#x27;&#x27;<br>assignees: &#x27;&#x27;<br><br>---<br><span class="hljs-section"># 🐞 Bug Reporter</span><br><br><span class="hljs-section">## 📋 Pre-Check</span><br><br><span class="hljs-bullet">-</span> [<span class="hljs-string"> </span>] I have searched the [<span class="hljs-string">issues</span>](<span class="hljs-link">https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/sample-gitlab/-/issuess</span>) of this repository and believe that this is not a duplicate.<br><br><span class="hljs-section">## 🐛 Bug Summary</span><br><br><span class="hljs-quote">&gt; A clear and concise description of what the bug is.</span><br><br><br><span class="hljs-section">## 🐛 Bug Reproduce</span><br><br><span class="hljs-quote">&gt; Steps to reproduce the behavior:</span><br><br><span class="hljs-bullet">1.</span> Go to &#x27;...&#x27;<br><span class="hljs-bullet">2.</span> Click on &#x27;....&#x27;<br><span class="hljs-bullet">3.</span> Scroll down to &#x27;....&#x27;<br><span class="hljs-bullet">4.</span> See error<br><br><span class="hljs-section">## 🐛 Expected Behavior</span><br><br><span class="hljs-quote">&gt; A clear and concise description of what you expected to happen.</span><br><br><span class="hljs-section">## 🐛 Possible Solution</span><br><br><span class="hljs-quote">&gt; Describe the solution you thought of.</span><br><br><span class="hljs-section">## 🐛 Context</span><br><br><span class="hljs-quote">&gt; How has this issue affected you? What are you trying to accomplish? Providing context helps us come up with a solution that is most useful in the real world.</span><br><br><span class="hljs-section">## 🐛 Your Environment</span><br><br><span class="hljs-quote">&gt; Include as many relevant details about the environment you experienced the bug in.</span><br><br>|                  |             |<br>| ---------------- | ----------- |<br>| OS               | x86?        |<br>| Compiler         | gcc-4.8.5 ? |<br>| Lib Ver(s)       |             |<br>| Lib Url          |             |<br>| Other Dependency |             |<br><br><span class="hljs-section">## 🐛 Additional context</span><br><br><span class="hljs-quote">&gt; Add any other context about the problem here.</span><br><br><br></code></pre></td></tr></table></figure><h3 id="2-3-使用-Issue-模板"><a href="#2-3-使用-Issue-模板" class="headerlink" title="2.3 使用 Issue 模板"></a>2.3 使用 Issue 模板</h3><p>在项目的 Issues 页面，点击 New issue 按钮，就可以看到 Issue 模板了，用户在创建 Issue 时，可以根据模板填写内容，这样可以让 Issue 的内容更加规范，也方便了 Issue 的管理。</p><h2 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3. 参考资料"></a>3. 参考资料</h2><ul><li><a href="https://docs.github.com/en/free-pro-team@latest/github/building-a-strong-community/creating-issue-templates-for-your-repository">Creating issue templates for your repository</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git —— Commit Message 规范介绍</title>
    <link href="/2023/12/26/Git%20%E2%80%94%E2%80%94%20Commit%20Message%20%E8%A7%84%E8%8C%83%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/12/26/Git%20%E2%80%94%E2%80%94%20Commit%20Message%20%E8%A7%84%E8%8C%83%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-——-Commit-Message-规范介绍"><a href="#Git-——-Commit-Message-规范介绍" class="headerlink" title="Git —— Commit Message 规范介绍"></a>Git —— Commit Message 规范介绍</h1><h2 id="为什么要规范-Commit-Message"><a href="#为什么要规范-Commit-Message" class="headerlink" title="为什么要规范 Commit Message"></a>为什么要规范 Commit Message</h2><p>日常开发中，我们经常会使用到 Git 进行代码管理，而 Git 中最常用的命令就是 <code>git commit</code>，我们通过 commit 命令将修改后的代码提交到本地仓库，然后再通过 <code>git push</code> 命令将本地仓库的代码推送到远程仓库。</p><p>git 规定提交时必须要写提交信息，作为改动说明，保存在 commit 历史中，方便回溯。规范的 log 不仅有助于他人 review, 还可以有效的输出 CHANGELOG，甚至对于项目的研发质量都有很大的提升，尤其是一些长期持续迭代维护，且多版本长期并存的项目。</p><p>优秀的规范化 Commit Message 应该具备以下优点：</p><ol><li><p>清晰明了：commit message 应该清晰明了，说明本次提交的目的，具体做了什么操作。这样可以让团队成员更好地理解每次提交的内容。</p></li><li><p>便于追溯：规范的 commit message 可以帮助程序员对提交历史进行追溯，了解发生了什么情况。</p></li><li><p>提高研发效率：一旦约束了 commit message，意味着我们将慎重的进行每一次提交，不能再一股脑的把各种各样的改动都放在一个 git commit 里面，这样一来整个代码改动的历史也将更加清晰。</p></li><li><p>自动化工具的友好性：规范的 commit message 可以被自动化工具用于生成发布日志或自动化版本号管理。</p></li><li><p>降低代码维护成本：如果 commit message 写得不清楚，例如使用 “fix bug” 这样笼统的描述，可能会导致后续代码维护成本特别大，有时自己都不知道自己的 “fix bug” 修复的是什么问题</p></li></ol><p>因此，规范化的 commit message 对于团队协作和项目管理是非常重要的。</p><h2 id="Commit-Message-规范"><a href="#Commit-Message-规范" class="headerlink" title="Commit Message 规范"></a>Commit Message 规范</h2><p>在 Git 中 Commit Message 的规范又很多种，其中比较受欢迎的有以下这些：</p><ol><li><p>Angular 规范：这是目前使用最广的写法，比较合理和系统化，并且有配套工具可以辅助生成（VS CODE 插件：git-commit-plugin）。</p></li><li><p>Conventional Commits 规范：这是一个基于语义化版本 (semver) 和简单的消息格式的轻量级约定，一传达代码更改的意图。</p></li></ol><p>这里我们着重介绍一下 Angular 规范。</p><h3 id="Angular-规范"><a href="#Angular-规范" class="headerlink" title="Angular 规范"></a>Angular 规范</h3><p>Angular 规范是一种广泛应用于软件开发中的提交信息（commit message）规范，其目的在于提供一种统一、清晰的提交信息格式，以便于开发者和维护者理解代码的变动情况。</p><p>Angular 规范将提交信息分为三个部分：Header、Body 和 Footer。</p><ol><li><p><strong>Header</strong>：Header 是提交信息的头部，包含三个字段：type、scope 和 subject。</p><ul><li><strong>type</strong>：type 字段用于指明<mark>本次提交的类型</mark>，例如：feat（新功能）、fix（修补bug）、docs（文档）、style（格式）、refactor（重构）、perf（性能优化）、test（增加测试）、chore（构建过程或辅助工具的变动）等。</li><li><strong>scope</strong>：scope 字段用于指明<mark>本次提交影响的范围</mark>，例如：数据层、控制层、视图层等。这个字段是可选的。</li><li><strong>subject</strong>：subject 字段是对<mark>本次提交目的的简短描述</mark>，不超过50个字符。</li></ul></li><li><p><strong>Body</strong>：Body 是提交信息的主体部分，用于<mark>详细描述本次提交的内容和原因</mark>。这个部分是可选的。</p></li><li><p><strong>Footer</strong>：Footer 是提交信息的尾部，通常用于<mark>记录不兼容变动和关闭 Issue</mark>。这个部分也是可选的。</p></li></ol><p>Angular 规范的提交信息格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>): <span class="hljs-tag">&lt;<span class="hljs-name">subject</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BLANK</span> <span class="hljs-attr">LINE</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BLANK</span> <span class="hljs-attr">LINE</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上就是 Angular 规范的基本内容。遵循这种规范可以帮助我们更好地管理代码提交的内容，使得每次提交的目的和主要改动都能清晰地体现在 Commit Message 中，便于后续的代码维护和版本管理。具体的规范可能会因团队和项目的不同而有所差异。所以，虽然 Git 本身没有强制的 Commit Message 规范，但在实际使用中，我们通常会根据实际需求来约定一些规范，以提高代码的可读性和维护性。</p><h2 id="Commit-Message-规范工具"><a href="#Commit-Message-规范工具" class="headerlink" title="Commit Message 规范工具"></a>Commit Message 规范工具</h2><p>在实际开发中，我们通常会使用一些工具来帮助我们规范 Commit Message，这样可以避免我们手动编写 Commit Message，提高开发效率。</p><p>这里介绍一个 VS Code 插件：<strong>git-commit-plugin</strong>，它可以帮助我们快速生成符合 Angular 规范的 Commit Message。这是它的仓库地址：<a href="https://github.com/RedJue/git-commit-plugin">https://github.com/RedJue/git-commit-plugin</a>。我们也可以直接在 VS Code 的扩展商店中直接下载安装。</p><blockquote><p>注意：商店中有两个名为 git-commit-plugin 的插件，我们选择作者为 redjue 的那一个。另一个为fork的版本，已经不再维护。</p></blockquote><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/0cd57b334faac82c88858d17cb3ff3e3/1703558434900.png" alt="git-commit-plugin"></p><p>安装完成后，我们点击 VS Code 左侧面板的存储库图标，可以看到存储库的右边出现了一个 git 图标，点击它就可以打开 git-commit-plugin 的界面。</p><ol><li><p>打开 git-commit-plugin 界面：</p><p>   <img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/153afa2bf93c4a55d9e4c5420aa43ee0/1703558938449.png"></p></li><li><p>选择提交类型，这里以 fix 为例：</p><p>   <img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/1ec1f6e85b71bd74e244632584d64eb3/1703559027194.png"></p></li><li><p>按照 Angular 规范依次完成 scope，subject，body 和 footer 字段</p><p>   <img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/45e369bb0b664b9ee79ae550bc0524cb/1703559610753.png"></p></li><li><p>完成每项内容的填写后，点击 Complete，插件会将填写的内容，按照规范自动生成在左侧源代码管理面板中的提交信息中：</p><p>   <img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/cd6eb2280db4b9e0e125bc83329c0bd6/1703559528891.png"></p><p>   <img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/df8e94be63ac8bdc9528e84a2bf2cd83/1703559648902.png"></p><p>   注意此处 VS Code 会提示“当前行比72超出39个字符”，这是因为 VS Code 限制了提交消息每行的最大长度。我们在上一步编辑 Body 时，受限于插件的界面，将所有内容都写在了一行中，因此在这里我们需要将 Body 部分的内容进行换行，达到美观和规范的目的。</p></li><li><p>最后我们点击提交按钮将本次修改提交到本地仓库，再点击同步就可以将本地仓库的提交记录推送到远程仓库了。</p></li></ol><h2 id="Commit-Message-模板的配置和使用"><a href="#Commit-Message-模板的配置和使用" class="headerlink" title="Commit Message 模板的配置和使用"></a>Commit Message 模板的配置和使用</h2><p>在某些环境下，可能仅有的就是一个命令行终端，我们需要在命令行中手动输入 Commit Message。这时候我们就需要一个 Commit Message 模板来帮助我们快速生成符合规范的 Commit Message。</p><p>以 Linux 端为例，git 提供了一个 commit.template 的配置项，用来指定期望使用的 Commit Message 模板。</p><ol><li><p>首先我们在项目的根目录创建一个 .gitmessage 文件，用来存放 Commit Message 模板：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> .gitmessage<br></code></pre></td></tr></table></figure></li><li><p>然后我们编辑 .gitmessage 文件，将以下内容复制到 .gitmessage 文件中：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># head: &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="hljs-comment"># - type: ✨ feat, 🐞 fix, 📃 docs, 🌈 style, 🦄 refactor, 🎈 perf, 🧪 test, 🔧 build, 🐎 ci, 🐳 chore, ↩ revert</span><br><span class="hljs-comment"># - scope: can be empty (eg. if the change is a global or difficult to assign to a single component)</span><br><span class="hljs-comment"># - subject: start with verb (such as &#x27;change&#x27;), 50-character line</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-comment"># body: 72-character wrapped. This should answer:</span><br><span class="hljs-comment"># * Why was this change necessary?</span><br><span class="hljs-comment"># * How does it address the problem?</span><br><span class="hljs-comment"># * Are there any side effects?</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-comment"># footer: </span><br><span class="hljs-comment"># - Include a link to the ticket, if any.</span><br><span class="hljs-comment"># - BREAKING CHANGE</span><br><span class="hljs-comment">#</span><br><br></code></pre></td></tr></table></figure></li><li><p>在项目路径下，我们通过 <code>git config</code> 命令指定 commit.template 的路径：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config commit.template .gitmessage<br></code></pre></td></tr></table></figure><blockquote><p>注意：这里仅对当前项目进行了模板配置，如果想要对所有项目使用该模板，则将该文件放置到用户目录下，然后在上述命令中添加 –global 参数即可。 </p><p><code>git config --global commit.template ~/.gitmessage</code></p></blockquote></li></ol><p>此时通过命令 <code>git commit</code> （<strong>不能带参数 -m ！</strong>）即可显示模板，并在模板中快速完成 Commit Message 的编辑。</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/2f3bac498fc45f31f266dc5c6edb3135/1703569918312.png"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/a0b698669c2690308be04db208c5dd77/1703570281939.png"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/bd892785244176b2fc593c84e84a81a5/1703570593953.png"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/793f74f73b0aa895fcc4abf8ab95eb4a/1703571607092.png"></p>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git —— 常用指令</title>
    <link href="/2023/07/31/Git%20%E2%80%94%E2%80%94%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/07/31/Git%20%E2%80%94%E2%80%94%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-——-常用命令"><a href="#Git-——-常用命令" class="headerlink" title="Git —— 常用命令"></a>Git —— 常用命令</h1><ol><li><p>克隆</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;git-repository-url&gt; [local-path] <br><span class="hljs-comment"># option</span><br><span class="hljs-comment"># 1. --recursive # 递归克隆子模块</span><br>git <span class="hljs-built_in">clone</span> &lt;git-repository-url&gt; --recursive [local-path]<br><span class="hljs-comment"># 2. --depth=1 # 浅克隆</span><br>git <span class="hljs-built_in">clone</span> &lt;git-repository-url&gt; --depth=1 [local-path]<br><span class="hljs-comment"># 3. --branch &lt;branch-name&gt; / -b &lt;branch-name&gt; # 克隆指定分支</span><br>git <span class="hljs-built_in">clone</span> &lt;git-repository-url&gt; --branch &lt;branch-name&gt; [local-path]<br></code></pre></td></tr></table></figure></li><li><p>提交</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 添加文件</span><br>git add &lt;file-path&gt;<br><span class="hljs-comment"># 2. 提交</span><br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span><br><span class="hljs-comment"># commit option</span><br><span class="hljs-comment"># 1. --amend # 修改上一次提交记录，注意！仅允许在本地仓库修改，不允许在远程仓库修改，且会覆盖上一次提交的记录</span><br>git commit --amend -m <span class="hljs-string">&quot;commit message&quot;</span><br><span class="hljs-comment"># 2. --no-edit # 仅修改上一次提交的文件，不修改提交记录</span><br>git commit --amend --no-edit<br><span class="hljs-comment"># 3. -a # 跳过 git add，添加所有存在跟踪记录的修改文件</span><br>git commit -a -m <span class="hljs-string">&quot;commit message&quot;</span><br><span class="hljs-comment"># 4. -v # 显示修改的文件</span><br>git commit -v -m <span class="hljs-string">&quot;commit message&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>推送至远程仓库</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意！不建议直接在主干分支中进行修改和更新。</span><br><span class="hljs-comment"># 注意！建议在本地创建分支进行修改，并创建远程分支进行提交，修改完成后在主界面上提交merge request，由管理员审核后合并到主干分支</span><br><span class="hljs-comment"># 注意！建议先拉取远程仓库更新，并将更新合并到本地分支后，确定无conflict后再推送</span><br>git push &lt;remote-name&gt; &lt;branch-name&gt;<br></code></pre></td></tr></table></figure></li><li><p>创建&#x2F;切换分支</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.查看远程分支</span><br>git branch -r<br><span class="hljs-comment"># 2.查看本地分支</span><br>git branch -l<br><span class="hljs-comment"># 3.创建分支</span><br>git branch &lt;branch-name&gt;<br>git add .<br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span><br><span class="hljs-comment"># 4.切换分支</span><br>git checkout &lt;branch-name&gt;<br></code></pre></td></tr></table></figure></li><li><p>将远程仓库更新合并到本地分支</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 git fetch 获取远程仓库更新</span><br>git fetch origin &lt;branch-name&gt;<br><span class="hljs-comment"># 比较本地分支与远程分支的差异</span><br>git <span class="hljs-built_in">log</span> -p FETCH_HEAD &lt;branch-name&gt;<br>git diff FETCH_HEAD &lt;branch-name&gt;<br><span class="hljs-comment"># 修改存在差异和冲突的文件</span><br><span class="hljs-comment"># 将远程分支合并到本地分支</span><br>git merge FETCH_HEAD<br><span class="hljs-comment"># 如果存在冲突，解决冲突后，再次提交</span><br>git commit -am <span class="hljs-string">&quot;commit message&quot;</span><br><span class="hljs-comment"># 将本地分支推送至远程分支</span><br>git push origin &lt;branch-name&gt;<br></code></pre></td></tr></table></figure></li><li><p>删除本地已合并分支</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch --merged main | grep -v <span class="hljs-string">&#x27;^[ *]*main$&#x27;</span> | xargs git branch -d<br></code></pre></td></tr></table></figure></li><li><p>删除远程仓库中已不存在的本地分支</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -a<br><span class="hljs-comment"># </span><br>git remote show origin<br><br>git remote prune origin<br><br></code></pre></td></tr></table></figure></li><li><p>http&#x2F;https 免密</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global credential.helper store<br></code></pre></td></tr></table></figure></li><li><p>ssh 免密</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;your_email&quot;</span><br><span class="hljs-comment"># copy id_ras.pub to git</span><br></code></pre></td></tr></table></figure></li><li><p>stash</p></li><li><p>git fsck –full</p></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开启 Cloudflare CDN 代理，实现 IPv4 to IPv6 转换</title>
    <link href="/2023/06/01/%E5%BC%80%E5%90%AF%20Cloudflare%20CDN%20%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%20IPv4%20to%20IPv6%20%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/06/01/%E5%BC%80%E5%90%AF%20Cloudflare%20CDN%20%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%20IPv4%20to%20IPv6%20%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="开启-Cloudflare-CDN-代理，实现-IPv4-to-IPv6-转换"><a href="#开启-Cloudflare-CDN-代理，实现-IPv4-to-IPv6-转换" class="headerlink" title="开启 Cloudflare CDN 代理，实现 IPv4 to IPv6 转换"></a>开启 Cloudflare CDN 代理，实现 IPv4 to IPv6 转换</h1><p>通过公网IPv6地址实现远程访问专栏系列文章：</p><ol><li><a href="https://ccccx159.github.io/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/">《使用公网IPv6远程访问内网设备》</a></li><li><a href="https://ccccx159.github.io/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/">《DDNS动态域名解析IPv6地址》</a></li><li><a href="https://ccccx159.github.io/2023/06/01/%E5%BC%80%E5%90%AF%20Cloudflare%20CDN%20%E4%BB%A3%E7%90%86%EF%BC%8C%E5%AE%9E%E7%8E%B0%20IPv4%20to%20IPv6%20%E8%BD%AC%E6%8D%A2/">《开启 Cloudflare CDN 代理，实现 IPv4 to IPv6 转换》</a></li></ol><blockquote><p><font color="blue">温馨提示：</font><br>本文存在一部分付费内容，但是付费仅限于域名的购买，如果已经有域名的朋友，请放心大胆食用本文，因为剩余内容均为免费使用。没有域名的朋友，可以移步上一篇文章<a href="https://ccccx159.github.io/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/">《DDNS动态域名解析IPv6地址》</a>，里面详细介绍了如何在腾讯云购买便宜好用的域名。</p></blockquote><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在前两篇文章中，我们详细介绍了如何开启 IPv6 来实现远程访问内网设备，以及如何使用域名和搭建 DDNS 服务实现通过域名来进行远程访问。我们先简单回顾一下，首先需要开启本地网络运营商分发 IPv6 地址的功能，并且开启内网设备的 IPv6 网络权限，因为 IPv6 地址是公网地址，所以此时我们可以直接使用内网设备具体的 IPv6 地址进行直接访问。但是由于IPv6 地址实在是太长了，难以记忆，因此我们通过域名（domain）来绑定 IP 地址，方便记忆。运营商提供的 IP 地址是动态地址，在一定时间后、或者重新拨号联网后会发生变化，针对这一情况，我们在本地搭建了 DDNS 服务，用于监测当前的 IP 地址是否发生变化，如果发生变化，则将新 IP 发送给 DNS 解析服务商，更新域名的 DNS 解析记录。</p><p>但是我们仍然遗留了一个问题，部分网络环境没有 IPv6 解析能力，比如我们公司的网络，在这种情况下，我们无法仅仅使用前两篇文章的内容来进行远程访问了。那么是否有方法能在 IPv4 Only 的环境来访问 IPv6 的站点呢？答案是有的，即<mark>套用 CDN 进行流量回源，简单来说就是在源站和客户端之间建立一个中间服务节点，用来 IPv6 和 IPv4 流量的双向转换</mark>。</p><p>当然答案并不是唯一的，有能力的大神，完全可以自建用于中继转换的服务，但是有免费，简单的轮子，我们当然首选直接拿来用啦。</p><h2 id="二、什么是-CDN"><a href="#二、什么是-CDN" class="headerlink" title="二、什么是 CDN"></a>二、什么是 CDN</h2><p>全称：Content Delivery Network 或 Content Ddistribute Network，即内容分发网络，顾名思义，它是一个分布式节点网络（也称为边缘位置服务器），它有助于根据用户的位置，内容源服务器和边缘服务器向最终用户的地点传送内容（网页、视频、图像等）。CDN节点具有缓存内容的缓存功能，并且可以从地理上靠近最终用户的位置向用户提供内容。CDN节点由CDN提供商部署在多个地理位置，并且可以跨越多个ISP（因特网服务提供商）网络。</p><p>简单来说，它是一个边缘位置服务器，再简单点，它就是一个服务器，用来干什么，用来传递（中转）内容。也就是说我们在访问源站的过程中，实质上是先访问了 CDN 中的边缘服务器，然后由它向源站请求内容后再由它向我们传送了响应内容。</p><p>如果无法理解，那也没关系，看完本文内容，会用即可。</p><h2 id="三、为什么选择-Cloudflare（简称“CF”）"><a href="#三、为什么选择-Cloudflare（简称“CF”）" class="headerlink" title="三、为什么选择 Cloudflare（简称“CF”）"></a>三、为什么选择 Cloudflare（简称“CF”）</h2><p>我们先说一下 Cloudflare 开启 CDN 后最大的缺点：慢！如果使用 Cloudflare 提供的默认边缘节点，有可能会让你的访问速度变得奇慢无比，因为 Cloudflare 的服务器大部分在境外，所以国内访问这些境外的边缘节点的速度你自然懂的。</p><p>但是为什么我们还是选择 Cloudflare 呢？有这几个让人无法拒绝的理由：</p><ol><li>提供了免费的 DNS 解析和 CDN 代理，DNS 支持泛解析；</li><li>CDN 支持 IPv4 和 IPv6 双栈流量的互相转换；</li><li>可以使用第三方开源的 Cloudflare 边缘节点 IP 优选脚本，通过 host 劫持来提高访问速度；</li><li>启用 CDN 后，我们可以隐藏真实 IP 地址，提高个人网络安全；</li><li>国内的 CDN 收费，并且需要绑定实名备案的云服务器，部分 CDN 不支持 IPv6 回源（腾讯云默认 CDN 不支持，需要购买额外的 ECDN 支持 IPv6 的回源）；</li></ol><p>其实仅凭第四点就薄纱国内的 CDN 服务了。CF 速度慢可以通过付费和优选 IP 解决，既然都要付费，那为什么不付给更良心的 CF 呢？</p><h2 id="四、将域名托管至-CF"><a href="#四、将域名托管至-CF" class="headerlink" title="四、将域名托管至 CF"></a>四、将域名托管至 CF</h2><p>前文中，我们在腾讯云购买了域名，并使用 dnspod 进行域名解析。那我们在使用 CF 前，首先要做的就是将域名托管到 CF。CF 使用需要注册账号，这一步就不做过多赘述了，网站支持简体中文，我相信按照说明注册账号应该都能顺利完成。</p><p>在注册完成后，我们点击主页中的“<strong>添加站点</strong>”按钮，导入我们购买的域名：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/483cec301c56b56f697ccb21605e50ce/1685951169889.jpg"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/37a856c85d1a6fe44f380261327cbb6f/1685953812251.jpg"></p><p>这里我们选择免费计划即可，如果有额外需求的，可以按需选择付费计划：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/e64117b1d2645418d6777759462d8143/1685954149112.png"></p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/b2ca18a9f53b7c773ed56b598e340aed/1685954472920.png"></p><p>完成到这一步时，我们已经完成了托管过程中在 CF 的界面所有操作，接下来我们去腾讯云的控制台，修改域名的名称服务器：</p><p>进入我的域名界面：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/1ffede4f3fc54987e9195931b3ddbca4/1685955178290.png"></p><p>在“修改DNS服务器”界面中，完成名称服务器的修改：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/795c0d5460d21f80df505c4a368f94c7/1685954836479.png"></p><h2 id="四、开启-CDN"><a href="#四、开启-CDN" class="headerlink" title="四、开启 CDN"></a>四、开启 CDN</h2><p>在域名托管的过程中，CF 会自动将原有的域名解析记录导入，我们进入 CF 的域名详情页面，选择左侧的 DNS 选项，打开当前域名的 DNS 解析记录界面：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/d39ea2b19a4fb646e050a8100fec5d31/image.png"></p><p>可以看到我这边已经添加了几条解析记录，下面我们从零开始介绍，如何添加解析记录并开启代理。</p><ol><li><p>手动添加一条 DNS 泛解析记录，并关闭代理：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/7c7b5244b0822b67697fc111b1385e26/image.png"></p></li><li><p>本地尝试 Ping 域名，确认 DNS 解析生效：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/237a1e5abb6c40d63531a4418c43906b/image.png"></p><p>可以看到 CF 的 DNS 解析已经生效了，域名被正确解析到了我们填写的 IP 上。</p></li><li><p>修改 DNS 解析记录，开启 CDN 代理：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/88df5e9aab35e19c32c3ff9ecb895f63/image.png"></p></li><li><p>再次尝试 Ping 域名，观察其返回的 IP 是否已经更新为代理的边缘节点 IP：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/731154f5637920912d564a89d9f572cd/image.png"></p></li><li><p>关闭本地电脑的 IPv6 网络，重新 Ping 域名，观察是否能正常 Ping 通，且返回的 IP 为 IPv4 地址：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/c0f48015f6d7c6824e1af70cfcf1ac56/image.png"></p></li><li><p>修改 OpenWrt 中的 DDNS 信息：</p><p>需要先在 CF 的个人资料中获取一个 API Key，用于更新 DNS 解析记录：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/a53419986eba8d4b3b27de92b501c857/image.png"></p><p>然后再去 OpenWrt 的“动态 DNS”插件中添加&#x2F;修改 DDNS 服务配置信息：</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/1a4bb932f2720abbc81a808122e1c664/image.png"></p><p><font color=red>注意：当开启 CDN 代理时，这个插件可能会有 “warn” 级别日志，因为它默认使用了 nslookup 获取域名指向的 IP，在开启代理后 nslookup 获取到的是 CF 边缘节点的 IP 地址，和我们真实的 IP 地址并不相同，并且会获取到多个 IP 导致脚本执行过程中有一步骤 expand_ipv6 会报错。但是这两个问题是没有什么关系的，唯一的影响就是每次检查 IP 的时候，都会强制更新一次 DNS 解析记录，即使真实的 IP 没有发生变化。</font></p></li></ol><p>经过以上6步，我们已经成功给域名套上了 CDN，所有对域名的请求将通过 CF 的边缘节点进行分发和返回，并且我们可以看到，当本地的 IPv6 网络被关闭时，CF 自动给我们分配了 IPv4 的边缘节点，实现了无 IPv6 网络环境下对 IPv6 源站的访问。</p><h2 id="五、Cloudflare-IP-优选"><a href="#五、Cloudflare-IP-优选" class="headerlink" title="五、Cloudflare IP 优选"></a>五、Cloudflare IP 优选</h2><p>在上面开启 CDN 代理的操作步骤中，第2步未开启代理时，单次 ping 的响应时间是15 ms，而第4、5步中 ping 的响应时间则直接上涨到了 200 ms，可见 CF 开启 CDN 代理，对我们访问的速度影响还是比较大的。因此我们需要对 CDN 边缘节点的接入 IP 进行优选。</p><p>此处推荐一个第三方开源的 IP 优选脚本：<a href="https://github.com/XIU2/CloudflareSpeedTest">XIU2&#x2F;CloudflareSpeedTest</a>。详细的使用方法和文档在其 github 主页中都有详细介绍，本文就不再赘述了。</p><h2 id="六、Cloudflare-开启-CDN-后的局限性"><a href="#六、Cloudflare-开启-CDN-后的局限性" class="headerlink" title="六、Cloudflare 开启 CDN 后的局限性"></a>六、Cloudflare 开启 CDN 后的局限性</h2><p>是否只要套用的 CDN，就万事大吉了呢？实则不然，Cloudflare CDN 仅仅能代理 HTTP 和 HTTPS 流量，而我们实际使用过程中，往往还有不同的协议流量，例如 SSH 访问服务器后台（不建议将 SSH 服务暴露到公网）、微软的RDP（mstsc）等，无法通过被代理的域名进行访问。</p><p>解决办法倒也不算麻烦，只要单独为特殊的流量设置独立子域名，并关闭代理即可。比如添加一个用于微软 RDP（mstsc）的子域名解析记录：rdp.yourDomain.com，并指定对应的 IP 地址。同时在添加一个 <code>rdp.yourDomain.com</code> 的 DDNS 服务即可。但是这种方式由于没有 CDN 的代理，也就意味着将直接访问 IPv6 地址，当处于无 IPv6 能力的环境下时，将不可访问。</p><p>当然 Cloudflare 提供了更安全的付费服务 <a href="https://developers.cloudflare.com/spectrum/">Cloudflare Spectrum</a> 来解决这个问题</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/e489644ba5f788f159e905142f4fca6d/image.png"></p><p>对于 HTTP 和 HTTPS 流量的代理，也存在一定的局限性。由于国内无法使用标准的 80 和 443 端口，因此我们不得不使用非标准端口来进行 HTTP(s) 通信。而 Cloudflare 支持转发的端口存在限制，仅支持以下端口的转发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">HTTP  端口：80、8080、8880、2052、2082、2086、2095<br>HTTPS 端口：443、2053、2083、2087、2096、8443<br></code></pre></td></tr></table></figure><p>因此势必需要设置端口转发，将 CF 端口的流量转发到部署的服务指定的端口。</p><p><img src="https://gitlab.ccccxyz.top:8443/xu4nch3n/notebooks/uploads/242211644d7144a59450b84bdc80a411/image.png"></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>到这里，IPv6 远程访问的系列专题基本告一段落了。我们通过三篇文章，详细地介绍了如何开启 IPv6 网络，如何通过域名进行远程访问，以及如何在无 IPv6 网络环境下通过 CDN 代理访问 IPv6 源站。</p><p>虽然这个专题主要介绍的都是 IPv6，但是 IPv4 网络也同样使用，无非就是域名的 DNS 解析类型从 “AAAA” 转变为 “A” 记录。</p><p>尽管 Cloudflare 免费计划无法做到尽善尽美，但是我们可以略微绕个弯进行规避后，一般的个人家用场景基本足够使用了，更别说还有 Frp，ZeroTier 这些优秀的穿透工具可以辅助使用。对 Frp 和 ZeroTier 感兴趣的朋友，推荐观看司波图的这期视频：<a href="https://www.bilibili.com/video/BV1dr4y147aq/?spm_id_from=333.999.0.0&vd_source=d8c59e2abebb7aaa6127921565c34c80">独享带宽，教你搭建只属于自己的内网穿透服务器（基于frp与zerotier moon服务器）</a></p><p>希望这个专题系列能给有需要的人带去帮助~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://developers.cloudflare.com/dns/">Cloudflare DNS 官方文档</a></li><li><a href="https://developers.cloudflare.com/spectrum/">Cloudflare spectrum 官方文档</a></li><li><a href="https://developers.cloudflare.com/api/">Cloudflare API 官方文档</a></li><li><a href="https://www.v2ex.com/t/870627">《家里只有 IPv6 公网地址，怎么操作才能使其他 IPv4 网络也访问到？》</a></li><li><a href="https://github.com/XIU2/CloudflareSpeedTest">XIU2&#x2F;CloudflareSpeedTest</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>cloudflare</tag>
      
      <tag>CDN</tag>
      
      <tag>IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fail2ban 防止暴力破解密码</title>
    <link href="/2023/05/31/fail2ban%20%E9%98%B2%E6%AD%A2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%AF%86%E7%A0%81/"/>
    <url>/2023/05/31/fail2ban%20%E9%98%B2%E6%AD%A2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="fail2ban-防止暴力破解密码"><a href="#fail2ban-防止暴力破解密码" class="headerlink" title="fail2ban 防止暴力破解密码"></a>fail2ban 防止暴力破解密码</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在五一劳动节期间发现家中搭建的 unRAID 服务器的 CPU 直接被拉满了，怀疑是被暴力破解入侵了，并植入了挖矿程序。经过两天的斗智斗勇，发现在系统盘中被创建了一个名为 wireguard.go 的定时脚本，会定时下载运行 Xmrig 的挖矿程序。。。打死我也没想到伪装名用的是 wireguard。由于部分服务被我暴露到公网上，所以不可避免的会被扫描到，然后被暴力破解了 sshd 的 root 密码，从而导致了以上惨剧。因此设置高位端口和复杂密码的必要性可想而知，一旦自建服务器被黑，如果只是植入挖矿程序，还算良心，万一隐私信息的暴露，或者被勒索，那就杯具了。</p><p>由于端口的有限性，尽管设置了高位端口，但还是有可能会有意者扫描到，因此防止暴力破解也是一个非常关键的安全手段。群晖自带了多次登录失败封禁 ip 的功能，但是 unRAID 本身没有这个功能，我们可以借助安装 fail2ban 这个防入侵软件来保护我们的服务器。</p><h2 id="二、fail2ban-简介"><a href="#二、fail2ban-简介" class="headerlink" title="二、fail2ban 简介"></a>二、fail2ban 简介</h2><p>fail2ban 的官方开源仓库：<a href="https://github.com/fail2ban/fail2ban">https://github.com/fail2ban/fail2ban</a></p><p>这里引用 fail2ban 开源仓库的文档内容：</p><blockquote><p>Fail2Ban 扫描日志文件 <code>/var/log/auth.log</code> 并禁止 IP 地址进行过多失败的登录尝试。它通过更新系统防火墙规则以在可配置的时间内拒绝来自这些 IP 地址的新连接来实现这一点。Fail2Ban 开箱即用，可以读取许多标准日志文件，例如 sshd 和 Apache 的日志文件，并且可以轻松配置为读取您选择的任何日志文件，以获取您希望的任何错误。</p><p>尽管 Fail2Ban 能够降低不正确的身份验证尝试率，但它无法消除弱身份验证带来的风险。如果您真的想保护服务，请将服务设置为仅使用两个因素或公共&#x2F;私人身份验证机制。</p></blockquote><p>简单来说，fail2ban 通过扫描日志文件获取相关错误，并通过改写 iptable 来阻止对应 IP 的连接，支持多种服务的保护。</p><p>fail2ban 提供了 docker 版本，因此安装配置也是相对简单的，下面就简要介绍一下如何在 unRAID 中安装 docker 版本的 fail2ban。</p><h2 id="三、docker-安装"><a href="#三、docker-安装" class="headerlink" title="三、docker 安装"></a>三、docker 安装</h2><p>这里以 unRAID 为例，简单介绍一下安装和配置的过程，由于 unRAID 的 APP 市场中存在现有的 docker 应用，因此我们直接拉取市场应用，并填写相关配置即可。当然你也可以基于其 github 发布的源码或者 release 包自行编写 dockerfile 构建镜像。</p><ol><li>点击 unRAID 的 APP 按钮，进入应用市场，在搜索栏中输入 fail2ban，会出来两个应用，我们选择发布者为 linuxserver 的应用，相对安全。另一个是第三方个人构建的 docker 镜像：<br><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/b997e4a75c8c7a7692f7fcdad88c7f02/1685515906781.jpg"></li><li>点击安装后会跳出一个提示界面，提示当前应用将运行在特权（privilege）模式下，可能存在安全风险。由于 fail2ban 是开源的，因此放心大胆的安装吧<br><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/5e62abe2e324bb0e600864bd51a8476a/1685516101870.png"></li><li>进入后是 docker 的配置界面，其实就是 docker run 的参数，填充完参数后完成创建<br><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/7354da94922920c9ead8d4d012049fc6/1685517579501.png">如果仅仅是为了读取系统的日志，其实我们什么都不需要填写和修改，直接创建即可。但是我们也可以看到，模板中还提供了可选的、其他服务的日志监控路径的挂载配置，上图未截全，如果有对应需求的朋友可以自行配置。</li><li>此时根据<a href="https://github.com/linuxserver/fail2ban-confs/blob/master/README.md">linuxserver的说明文档</a>，还要手动去创建和设置一个配置文件 jail.local，否则重启容器后会丢失配置，而且默认的监控服务是被禁用的，我们直接拷贝 ta 提供的完整配置，然后手动修改其中的部分内容，并保存为 jail.local：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs shell">[DEFAULT]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;bantime.increment&quot;</span> allows to use database <span class="hljs-keyword">for</span> searching of previously banned ip<span class="hljs-string">&#x27;s to increase a</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">default ban time</span></span><br>bantime.increment = true<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;bantime.maxtime&quot; is the max number of seconds using the ban time can reach (doesn&#x27;</span>t grow further)</span><br>bantime.maxtime = 5w<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;bantime.factor&quot;</span> is a coefficient to calculate exponent growing of the formula or common multiplier</span><br>bantime.factor = 24<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;bantime&quot;</span> is the number of seconds that a host is banned.</span><br>bantime = 1h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">A host is banned <span class="hljs-keyword">if</span> it has generated <span class="hljs-string">&quot;maxretry&quot;</span> during the last <span class="hljs-string">&quot;findtime&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">seconds.</span><br>findtime = 24h<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&quot;maxretry&quot;</span> is the number of failures before a host get banned.</span><br>maxretry = 5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Prevents banning LAN subnets</span><br>ignoreip    = 127.0.0.1/8 ::1<br>              10.0.0.0/8<br>              172.16.0.0/12<br>              192.168.0.0/16<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The ban action <span class="hljs-string">&quot;iptables-multiport&quot;</span> (default) should work <span class="hljs-keyword">for</span> most</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The ban action <span class="hljs-string">&quot;iptables-allports&quot;</span> can be used <span class="hljs-keyword">if</span> multiport causes issues</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">banaction = %(banaction_allports)s</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Read https://github.com/sebres/PoC/blob/master/FW.IDS-DROP-vs-REJECT/README.md before changing block <span class="hljs-built_in">type</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The block <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;REJECT --reject-with icmp-port-unreachable&quot;</span> (default behavior) should respond to, but <span class="hljs-keyword">then</span> instantly reject connection attempts</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The block <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;DROP&quot;</span> should not respond to connection attempts, resulting <span class="hljs-keyword">in</span> a <span class="hljs-built_in">timeout</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">banaction = iptables-multiport[blocktype=DROP]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Add additional actions</span><br>action  = %(action_)s<br>          apprise-api[host=&quot;127.0.0.1&quot;, tag=&quot;fail2ban&quot;]<br>          cloudflare[cfuser=&quot;YOUR-EMAIL&quot;, cftoken=&quot;YOUR-TOKEN&quot;]<br><br>abuseipdb_apikey = YOUR-API-KEY<br><br>[unraid-sshd]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">configuration inherits from jail.d/unraid-sshd.conf</span><br>enabled = true<br>chain   = INPUT<br>action  = %(known/action)s<br>          abuseipdb[abuseipdb_apikey=&quot;%(abuseipdb_apikey)s&quot;, abuseipdb_category=&quot;18,22&quot;]<br><br>[unraid-webgui]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">configuration inherits from jail.d/unraid-webgui.conf</span><br>enabled = true<br>chain   = INPUT<br>port    = http,https,YOUR-UNRAID-MY-SERVERS-WAN-PORT<br>action  = %(known/action)s<br>          abuseipdb[abuseipdb_apikey=&quot;%(abuseipdb_apikey)s&quot;, abuseipdb_category=&quot;18,21&quot;]<br><br>[unifi-controller-auth]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">configuration inherits from jail.d/unifi-controller-auth.conf</span><br>enabled = true<br>chain   = DOCKER-USER<br>action  = %(known/action)s<br>          abuseipdb[abuseipdb_apikey=&quot;%(abuseipdb_apikey)s&quot;, abuseipdb_category=&quot;18,21&quot;]<br><br>[vaultwarden-auth]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">configuration inherits from jail.d/vaultwarden-auth.conf</span><br>enabled = true<br>chain   = DOCKER-USER<br>action  = %(known/action)s<br>          abuseipdb[abuseipdb_apikey=&quot;%(abuseipdb_apikey)s&quot;, abuseipdb_category=&quot;18,21&quot;]<br><br></code></pre></td></tr></table></figure></li></ol><p>  配置文件中，我们需要手动修改部分内容：</p><ul><li><p>删除第31行行首的 “#” 取消注释，按照其说明，默认的封禁 action 是 iptables-multiport，但是不知道为什么，我这边使用默认的封禁 action 时无法生效，因此我将这行注释取消，使用 iptables-allports 封禁所有端口</p></li><li><p>在 39 ~ 40 行中定义了三种 action，后面两种是推送消息的，如果有需要可以自行配置一下，如果不需要则在第 40 和 41 行的行首分别加上 “#” 即可</p></li><li><p>从 45 行开始，就是各个待监控的服务，每个服务都以 <code>[xxxxxx]</code> 开头，默认配置中添加了 <code>[unifi-controller-auth]</code> 和 <code>[vaultwarden-auth]</code> 的监控，如果不需要可以直接删除，并且默认的监控配置中，action 还额外增加了一条 abuseipdb 的配置，如果没有的，也可以直接将 abuseipdb 这行删除，保留默认的 <code>action = %(known/action)s</code> 即可。</p></li><li><p>如果需要添加其他的服务监控，可以从 docker 本身配置中复制过来，路径为 <code>/mnt/user/appdata/fail2ban/fail2ban/jail.d</code> 下面有各个服务独立的 conf 文件，我们以 gitlab.conf 为例。直接复制粘贴到 jail.local 中即可，将 enable 修改为 true，logpath 中的 &#x2F;gitlab&#x2F;xxxx 修改为 docker 配置界面中的挂载路径即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Version 2022/08/06</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fail2Ban jail configuration <span class="hljs-keyword">for</span> gitlab</span><br><br>[gitlab]<br><br>enabled = false<br>port    = http,https<br>logpath = %(logs_path)s/gitlab/gitlab-rails/application.log<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>将 jail.local 拷贝到 unRAID 的目录中 <code>/mnt/user/appdata/fail2ban/fail2ban/jail.d</code>，重启 docker。</li></ol><h2 id="四、fail2ban-client-命令和效果测试"><a href="#四、fail2ban-client-命令和效果测试" class="headerlink" title="四、fail2ban-client 命令和效果测试"></a>四、fail2ban-client 命令和效果测试</h2><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/1c02f915b01c6f05f89b579cfd94109e/1685520145020.png"></p><p>可以看到在输错几次密码后，ssh 连接直接被拒绝了。我们进 fail2ban 的控制台中看一下封禁状态 <code>fail2ban-client status &lt;服务名称&gt;</code>：</p><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/e6fcd2c4d2085ef6739a64c2331afc1a/1685520332045.png"></p><p>我这边开了7个监控服务，刚才被封禁的是 unraid-sshd，我们在看一下详细的监控服务状态：</p><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/8667dfceba63606dcbd1bb3eea6dfee2/1685520362023.png"></p><p>列出了当前服务失败次数和总次数，以及当前封禁的 ip 数量和总 ip 数量，并列举出了被封禁的详细 ip。<br>我们可以通过 <code>fail2ban-client set &lt;服务名称&gt; unbanip &lt;被封禁的 IP 地址&gt;</code> 来取消封禁：</p><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/b82877dd944756d2e25844094fd5a41a/1685520388282.png"></p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>fail2ban</tag>
      
      <tag>防破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git —— submodule 操作说明</title>
    <link href="/2023/05/19/Git%20%E2%80%94%E2%80%94%20submodule%20%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/"/>
    <url>/2023/05/19/Git%20%E2%80%94%E2%80%94%20submodule%20%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-——-submodule-操作说明"><a href="#Git-——-submodule-操作说明" class="headerlink" title="Git —— submodule 操作说明"></a>Git —— submodule 操作说明</h1><h2 id="1-add-添加子模块"><a href="#1-add-添加子模块" class="headerlink" title="1. add 添加子模块"></a>1. add 添加子模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">git submodule add -b master https://github.com/coolsnowwolf/lede.git ./lede</span><br>git submodule add -b &lt;branch-name]&gt; &lt;git-repository-url&gt; [local-path]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地提交</span><br>git commit -m &quot;add submodule xxxx&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">推送到远程仓库</span><br>git push<br></code></pre></td></tr></table></figure><h2 id="2-checkout-子模块检出"><a href="#2-checkout-子模块检出" class="headerlink" title="2. checkout 子模块检出"></a>2. checkout 子模块检出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">有两种方式：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 使用 --recursive 参数，跟随主仓库递归 <span class="hljs-built_in">clone</span></span><br>git clone &lt;your main repository url&gt; --recursive # 此时 clone 下来的主项目会直接 clone 远程仓库中记录的 commit id 版本的子模块<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 单独 checkout 子模块</span><br>git clone &lt;your main repository url&gt; # 不带 --recursive 递归参数时，submodule 无法被一起 clone 下来<br>git submodule update --init --recursive # 将 submodule 更新到远程仓库中记录的 commit id 版本<br></code></pre></td></tr></table></figure><h2 id="3-update-更新-x2F-切换子模块-commit-id-和当前分支"><a href="#3-update-更新-x2F-切换子模块-commit-id-和当前分支" class="headerlink" title="3. update 更新&#x2F;切换子模块 commit id 和当前分支"></a>3. update 更新&#x2F;切换子模块 commit id 和当前分支</h2><p>这里存在一个较大的坑，默认检出的子模块并不属于任何分支，而是一个 “detached head” ，虽然可以提交更改，但是并没有本地分支跟踪提交的更改，这意味着<font color=red>下次更新子模块会丢失这些更改</font>。</p><p>因此在对子模块进行开发修改前，请先切换其所属分支和对应的 commit id。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">默认添加的 submodule 的 commit <span class="hljs-built_in">id</span> 是 add 时默认分支当前的一个 commit <span class="hljs-built_in">id</span>，当子模块原始仓库更新后，期望切换到指定的 commit <span class="hljs-built_in">id</span> 版本，或者像要切换分支</span><br>git pull<br>git submodule update # 更新本地仓库，避免出现冲突<br>cd &lt;submodule dir&gt;<br>git checkout &lt;branch name&gt; # 切换分支<br>git pull # 拉取新分支源码<br>git checkout &lt;commit id&gt; # 更新子模块版本<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">回到主仓库目录，提交子模块的引用版本修改</span><br>cd ..<br>git add . # 暂存 submodule 的引用版本修改<br>git commit -m &quot;update submodule xxx from xxx to xxx&quot; # 提交<br>git push # 推送到远程仓库<br><br></code></pre></td></tr></table></figure><h2 id="4-commit-提交子模块"><a href="#4-commit-提交子模块" class="headerlink" title="4. commit 提交子模块"></a>4. commit 提交子模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull <br>git submodule update # 确保提交前已将本地仓库更新到远程仓库最新版本，避免提交出现冲突<br>cd &lt;submodulde dir&gt;<br>git add .<br>git commit -am &quot;submodule modify&quot;<br>git push # 将子模块提交的更改推送至远程仓库<br></code></pre></td></tr></table></figure><p>由于子模块和主模块是独立的两个仓库，主模块仅仅应用了子模块的 url 和 commit id。因此当子模块推送更改后，生成新的 commit id，但是主模块对子模块的引用配置并未发生更改，因此需要在主模块中同步进行提交更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ../ # 回到主模块目录<br>git add .<br>git commit -am &quot;submodule reference modify&quot;<br>git push # 推送主模块对子模块的引用记录更改到远程仓库<br></code></pre></td></tr></table></figure><p>可以看到对于子模块的修改，我们需要分别提交和推送子、主模块的更改，当然我们也可以将 “推送至远程仓库” 这一步合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd &lt;main module dir&gt; # 进入主模块目录<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 --recurse-submodules=on-demand 选项，可以在推送主模块更改时，自动推送未推送的子模块</span><br>git push --recurse-submodules=on-demand<br></code></pre></td></tr></table></figure><p>如果出现子模块提交了更改记录，但是未推送到远程仓库，主模块提交了子模块引用记录的变更，并完成了推送到远程仓库的操作。此时拉取主模块没问题，但是在拉取子模块时，会出现 “not our ref” 的报错。这是因为主模块引用了一个远程仓库未记录的 commit id 版本的子模块。需要在提交了变更记录的子模块中完成 push 即可。为了避免<mark>忘记推送子模块修改，仅推送了主模块的引用记录变更</mark>，可以将主模块的推送命令修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 --recurse-submodule=check 选项可以自动检查子模块未 push 的错误</span><br>git push --recurse-submodule=check<br></code></pre></td></tr></table></figure><p>当使用 “–recurse-submodule&#x3D;check” 选项时，如果子模块存在未 push 情况，则当前 push 操作会报警；并且如果子模块存在 push 失败的情况时，也同样会报错。可以直接将其写入 git 配置，减少重复劳动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config push.recurseSubmodules check<br></code></pre></td></tr></table></figure><h2 id="5-modify-修改-submodule-远程仓库-url"><a href="#5-modify-修改-submodule-远程仓库-url" class="headerlink" title="5. modify 修改 submodule 远程仓库 url"></a>5. modify 修改 submodule 远程仓库 url</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd &lt;main module dir&gt; # 进入主模块目录<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改主模块中 .gitmodules 中的 url</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用 <span class="hljs-built_in">sync</span> 命令同步修改至 .git/config 中</span><br>git submodule sync<br>git commit -am &quot;modify submodule url&quot; # 提交修改<br>git push # 推送到主模块远程仓库<br></code></pre></td></tr></table></figure><p>如果时别人修改了子模块 url，则拉取主模块的更新后，使用 sync 命令同步到本地 .git&#x2F;config 中即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd &lt;main module dir&gt; # 进入主模块目录<br>git pull # 拉取主模块更新，即获取 .gitmodule 中 url 的修改<br>git submodule sync # 将 .gitmodule 中的修改同步到本地仓库的配置中 .git/config<br></code></pre></td></tr></table></figure><h2 id="6-deinit-移除已有的-submodule"><a href="#6-deinit-移除已有的-submodule" class="headerlink" title="6. deinit 移除已有的 submodule"></a>6. deinit 移除已有的 submodule</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git submodule deinit &lt;submodule name&gt;<br>git rm &lt;submodule dir&gt;<br>git commit -am &quot;remove submodule xxx&quot;<br>git push<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://ldjhust.github.io/2018/08/22/Standard-Operation-of-Git-Submodule.html">《Git - 使用git submodule的规范操作》</a></li><li><a href="https://knightyun.github.io/2021/03/21/git-submodule">《Git submodule 知识总结》</a></li><li><a href="https://juejin.cn/post/6844903920645455879">《来说说坑爹的 git submodule》</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Git</tag>
      
      <tag>submodule</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WinRAR去广告</title>
    <link href="/2023/05/18/WinRAR%E5%8E%BB%E5%B9%BF%E5%91%8A/"/>
    <url>/2023/05/18/WinRAR%E5%8E%BB%E5%B9%BF%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="WinRAR-去广告。。。"><a href="#WinRAR-去广告。。。" class="headerlink" title="WinRAR 去广告。。。"></a>WinRAR 去广告。。。</h1><p>搜索引默认提供的 winrar 官网由国内公司代理。。。免费版中的广告就是被这个国内代理商插入的。。。真的就是中国人专坑中国人。。。</p><p>直接去源网站 <a href="https://www.rarlab.com/">https://www.rarlab.com/</a> 下载正式发布的英文版或者繁体中文版，纯净无广告。。。</p><p>无语至极。。。</p><p>不想重新安装的，也可以使用以下方法：</p><ol><li>在 WinRAR 的安装目录下新建一个 txt 文件，并重命名为 “<strong>rarreg.key</strong>“</li><li>用记事本，notepad++等软件打开 “<strong>rarreg.key</strong>“，并粘贴以下内容后保存即可 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">RAR registration data  <br>Federal Agency for Education  <br>1000000 PC usage license  <br>UID=b621cca9a84bc5deffbf  <br>6412612250ffbf533df6db2dfe8ccc3aae5362c06d54762105357d  <br>5e3b1489e751c76bf6e0640001014be50a52303fed29664b074145  <br>7e567d04159ad8defc3fb6edf32831fd1966f72c21c0c53c02fbbb  <br>2f91cfca671d9c482b11b8ac3281cb21378e85606494da349941fa  <br>e9ee328f12dc73e90b6356b921fbfb8522d6562a6a4b97e8ef6c9f  <br>fb866be1e3826b5aa126a4d2bfe9336ad63003fc0e71c307fc2c60  <br>64416495d4c55a0cc82d402110498da970812063934815d81470829275<br></code></pre></td></tr></table></figure></li></ol><p>完成上面两个步骤后，在打开 rar 文件就没有广告弹窗了。</p><p>参考：<a href="https://blog.csdn.net/qq_39313596/article/details/85169627">《WinRAR去除 屏蔽广告弹窗方法》</a></p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>WinRAR</tag>
      
      <tag>去广告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云网盘媒体库海报墙加载卡顿解决办法</title>
    <link href="/2023/05/15/%E9%98%BF%E9%87%8C%E4%BA%91%E7%BD%91%E7%9B%98%E5%AA%92%E4%BD%93%E5%BA%93%E6%B5%B7%E6%8A%A5%E5%A2%99%E5%8A%A0%E8%BD%BD%E5%8D%A1%E9%A1%BF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2023/05/15/%E9%98%BF%E9%87%8C%E4%BA%91%E7%BD%91%E7%9B%98%E5%AA%92%E4%BD%93%E5%BA%93%E6%B5%B7%E6%8A%A5%E5%A2%99%E5%8A%A0%E8%BD%BD%E5%8D%A1%E9%A1%BF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里云网盘媒体库海报墙加载卡顿解决办法"><a href="#阿里云网盘媒体库海报墙加载卡顿解决办法" class="headerlink" title="阿里云网盘媒体库海报墙加载卡顿解决办法"></a>阿里云网盘媒体库海报墙加载卡顿解决办法</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>由于阿里云网盘的不限速，以及其支持webdav挂载的优点，很多同学将阿里云盘作为自己的网络媒体库，通过infuse，Emby，plex，fileball等工具进行维护管理实现家庭媒体中心的功能。但是在今年大约4月左右，阿里云官方API对请求的QPS进行了限制，目前最新的QPS限制如下所示：</p><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/13d53b961050c08ea25e237098e189ed/image.png"></p><p>当时几乎所有的第三方阿里云webdav服务都出现了 “to many requests” 的问题，例如 <a href="https://github.com/alist-org/alist">xhofe&#x2F;alist</a> 和 <a href="https://github.com/messense/aliyundrive-webdav">messense&#x2F;aliyundrive-webdav</a> 都有 issue 提到这个问题。虽然各位作者大大都对此进行了适配和优化，但是在挂载后，仍然出现该问题，和媒体海报墙加载极其缓慢和卡顿的问题。</p><h2 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h2><p>出现 “to many requests” 的问题，归根结底还是因为频繁请求导致的。这里以 Emby Server 为例（其余的多媒体管理服务虽然作者本人也有所使用，但 Emby 为主力服务，了解的相对比较详细，因此其余服务再次不作讨论，各位看官可以参考借鉴），在加载海报墙时，Emby 会读取媒体文件的图片和 nfo 文件（ nfo 文件实质上是一个 xml 格式的媒体信息文件，其中包含了刮削后获取的影片详细信息），当进入某个媒体库时，需要预读这个库中所有影片的海报图片和 nfo 文件，可想而知这瞬时的QPS有多大了。</p><p>如果是之前未优化的 webdav 服务，则有可能直接报错然后短时间无法显示，甚至会掉盘，需要重新挂载才能恢复正常。优化后的服务，虽然不会掉盘，但是由于 QPS 的限制，仍然无法像以前一样丝滑的加载海报墙，而且会非常慢，体验十分糟糕。<br><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/c18eebb883199b3f5c964b7868b1f5b1/image.png"></p><h2 id="三、解决思路"><a href="#三、解决思路" class="headerlink" title="三、解决思路"></a>三、解决思路</h2><p>由于 Emby 加载海报墙需要预读图片和 nfo 文件，默认情况下图片和 nfo 文件被保存在媒体文件夹中，即网盘中，那只要将海报和 nfo 文件存储到本地硬盘中不就不需要像阿里云网盘请求就可以加载海报墙并显示影片信息了吗？但是我逛了逛 Emby 的官方论坛，发现官方并没有支持将海报和 nfo 文件存储到独立目录的功能，并且表示没有支持计划。</p><p>但是我在论坛中发现了另一个信息，Emby Server 会在搭建服务的本地维护一个媒体信息的数据库，如果在创建媒体库时，不设置海报和 nfo 文件的读取，就可以将数据存储在本地的数据库中，这样 Emby 在加载海报墙时会直接从本地数据库中获取图片和影片详情，这样就能极大提升海报墙的加载速度了。</p><h2 id="四、操作步骤"><a href="#四、操作步骤" class="headerlink" title="四、操作步骤"></a>四、操作步骤</h2><p>操作非常简单，只需要修改媒体库的设置即可。（作者在这里为了尽可能减少请求数量，将网盘的媒体目录中所有海报和 nfo 文件都删除了，因为列出目录和获取每个文件的下载 url 都会触发 QPS 限制。如果删除海报和 nfo 文件，则需要重新扫库，如果库中影片数量巨大，可能耗时很久）</p><ol><li><p>打开媒体库编辑界面<br> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/0d14378c23268f10ba3bb742eacaf923/image.png"></p></li><li><p>取消勾选下面图示三处选项<br> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/f3f8efe822b0b6df4a3ec324a8234ce4/image.png"></p><p> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/a982f2a6e26c8920bead5f3baaad27d0/image.png"></p><p> <img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/2d4ffec15e38b1c097ce8d231b520d91/image.png"></p></li><li><p>如果删除了原始的海报文件和 nfo 文件，那么重新执行以下扫描媒体库即可。</p></li></ol><h2 id="四、效果展示"><a href="#四、效果展示" class="headerlink" title="四、效果展示"></a>四、效果展示</h2><p><img src="https://gitlab.b1gfac3c4t.top:1594/xu4nch3n/notebooks/uploads/2d35f4f37e392aaad54bdc480dbabfa2/1.gif"></p><h2 id="五、存在的缺点"><a href="#五、存在的缺点" class="headerlink" title="五、存在的缺点"></a>五、存在的缺点</h2><p>在解决思路一节中提到，这种方法是将海报和媒体详细信息保存在本地数据库中，因此当同一个网盘，在异地搭建媒体服务器时，两地的数据库并不是同一份。再加上 Emby 刮削存在错误的可能性，这就导致同一媒体库多次刮削，对于刮削错误需要多次进行手动修改。</p><p>话虽如此，目前 Emby 自带的刮削器效果比较不错，作者的电影库中影片数量共661部，自动刮削错误数量不到10部，其中部分的错误原因还是因为电影的年份和命名不正确导致，在这样的正确率下，这个缺陷也就无伤大雅了。</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Emby</tag>
      
      <tag>阿里云网盘</tag>
      
      <tag>海报墙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDNS动态域名解析IPv6地址</title>
    <link href="/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="DDNS动态域名解析IPv6地址"><a href="#DDNS动态域名解析IPv6地址" class="headerlink" title="DDNS动态域名解析IPv6地址"></a>DDNS动态域名解析IPv6地址</h1><p>通过公网IPv6地址实现远程访问专栏系列文章：</p><ol><li><a href="https://ccccx159.github.io/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/">《使用公网IPv6远程访问内网设备》</a></li><li><a href="https://ccccx159.github.io/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/">《DDNS动态域名解析IPv6地址》</a></li></ol><blockquote><p><font color=red>付费提示！</font></p><p>由于本文教程中需要使用域名和域名解析服务，因此存在付费内容。域名可自行在阿里云、腾讯云、华为云等云服务提供商进行购买，域名解析服务则可以自行选择使用云服务提供商所提供的免费解析服务，也可以将域名托管至第三方服务提供商，例如大名鼎鼎的Cloudflare。<br>根据不同的顶级域名，域名价格从几块钱到上百元不等，可自行选择。</p></blockquote><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在上一篇文章《使用公网IPv6远程访问内网设备》的文末，我们提到了使用IPv6地址进行远程访问几个缺陷：</p><ol><li>IPv6 地址很长，不方便记忆；</li><li>公网 IPv6 地址并非固定不变，在一定情况下，地址发生变更，如果不能及时获取地址，则无法进行远程访问</li><li>部分网络无IPv6的Internet访问权限，比如公司内网等，则无法访问任何IPv6地址</li></ol><p>这三个缺陷，从解决方案的角度来看，我们可以将其分为两类，缺陷1、2分为一类，缺陷3分为第二类。本文我们就来详细介绍一下，如何解决第一类问题，IPv6地址难以记忆且不定时更新。</p><h2 id="二、方案简介"><a href="#二、方案简介" class="headerlink" title="二、方案简介"></a>二、方案简介</h2><p>折腾过IPv4的朋友应该也遇到过这类问题，虽然IPv4地址相对简短，更好记忆，但是一串毫无意义的数字，总归还是难以记忆。解决方案的思路和IPv4相同，都是通过申请域名和设置域名的DNS解析服务，将简单好记的域名绑定到自己的公网IP上，后续可直接通过域名进行访问无需再记忆IP地址，仅需记住自定义的域名即可。域名有多方便记忆应该所有人都有所体会，例如百度（baidu.com）、淘宝（taobao.com）等。</p><p>对于IP不断更新变化的问题，不论是IPv4还是IPv6都存在，解决思路并不复杂，简单来说，我们在本地定时获取光猫或者路由器通过拨号获取的IP地址，即WAN口地址，并与上一次获取记录进行比较判断，如果IP发生变化，则通知用户重新设置DNS解析，或者通过DNS服务的API接口，自动进行设置。自动设置的过程实际上就是文章的标题，DDNS解析IP地址。</p><p>我们来看一下 Wiki 对 DDNS 的解释：</p><blockquote><p><strong>动态DNS</strong>（英语：<strong>Dynamic DNS</strong>，简称<strong>DDNS</strong>）是<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F" title="域名系统">域名系统</a>（DNS）中的一种自动更新<a href="https://zh.wikipedia.org/wiki/%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8" title="名称服务器">名称服务器</a>（Name server）内容的技术。根据互联网的域名订立规则，域名必须跟从固定的IP地址。但动态DNS系统为动态网域提供一个固定的<a href="https://zh.wikipedia.org/wiki/%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8" title="名称服务器">名称服务器</a>（Name server），透过即时更新，使外界用户能够连上动态用户的网址。</p><p>这个术语被用来描述两种不同的概念。在<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF" title="互联网">互联网</a>的管理层面来说，动态DNS更新是指创建一个DNS系统，能够自动更新传统的DNS记录，而不需要手动编辑。这个机制在RFC 2136中被解释，利用<a href="https://zh.wikipedia.org/w/index.php?title=TSIG&action=edit&redlink=1">TSIG</a>机制来提供安全性。————<a href="https://zh.wikipedia.org/wiki/%E5%8B%95%E6%85%8BDNS">Wiki百科</a></p></blockquote><p>OK，话不多说，下面开始逐步进行详细的说明和介绍</p><h2 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h2><p>因为作者本人使用的是腾讯云，所以接下来的教程中，将全部按照腾讯云进行示范，对于其他的域名提供商，整理流程大同小异，也可参考本文进行。</p><h3 id="3-1、申请域名"><a href="#3-1、申请域名" class="headerlink" title="3.1、申请域名"></a>3.1、申请域名</h3><p><img src="https://user-images.githubusercontent.com/35327600/232372209-761d3447-0d43-4926-9907-3a67bc25f335.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/232372574-c1d44454-8c73-43cd-a933-02a06ce622a5.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/232373399-7af123a7-c0e5-41ce-b141-546a67952705.png"></p><p>这里我们选择了 “.top” 这个顶级域名，并二级域名自定义输入了 “ipv6test”，那么最终我们所申请的域名就是 “ipv6test.top”。</p><blockquote><p>什么是 “<strong>顶级域名</strong>“ 和 “<strong>二级域名</strong>“ 请自行百度或者Google搜索，这里不展开赘述了。</p></blockquote><p><img src="https://user-images.githubusercontent.com/35327600/232375887-3b3156b7-4e98-43cc-8490-883d84c24b50.png"></p><p>域名购买的过程中有坑点，需要单独注意下，上图中已经标明了，这里再简单说明一下：</p><ol><li>将域名添加到购物车之后，会弹出 “DNS解析（专业版）” 和 “SSL证书” 这两个购买项， 我们确实需要使用 DNS 解析服务，但是免费版本已经足够使用，无需再单独购买专业版；而 “SSL证书” 我们可以从第三方进行免费申请，根本不需要这个</li><li>点击查询后展示的域名价格是 “<strong>首年价格</strong>“，折扣力度比较大，<font color=red>但是！！！后续每年的续费价格则会恢复原价，导致续费价格会比首年价格贵好几倍！！！</font>如果不想每年重新购买域名，那么最好直接买一个续费价格也相对比便宜的域名。（富哥们不需要在意这个）</li></ol><p>现在购买域名需要实名审核，在结算界面会需要创建一个个人信息模板，按要求填写后，购买成功即可。作者之前已经注册了域名，因此这里不再重复注册了。</p><h3 id="3-2、添加DNS解析记录"><a href="#3-2、添加DNS解析记录" class="headerlink" title="3.2、添加DNS解析记录"></a>3.2、添加DNS解析记录</h3><p>完成域名注册后，和上面的第一步一样，通过云产品中的域名注册，回到我的域名界面，原本的空列表中会显示你刚刚注册的域名，刚刚注册完成的，可能服务状态会显示 “实名认证审核中”，这个审核时长不定。如果实名信息是之前已经认证过的，很快就能通过审核，最终如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/232395377-c1d40738-34e2-4f8f-b4ed-3752f7a4296a.png"></p><p>当服务状态显示为正常时，我们点击后边的解析按钮，进行 DNS 解析记录设置。</p><p><img src="https://user-images.githubusercontent.com/35327600/232397281-5251e681-1ea7-4c7e-924c-b047a95dbc8d.png"></p><p>在点击”添加记录”按钮之后，出现一条空白的解析记录，一共有5项待填充内容，分别是：</p><ol><li>主机记录</li><li>记录类型</li><li>线路类型</li><li>记录值</li><li>TTL<br>一般来说，我们只需要填写其中的主机记录、记录类型和记录值三项就行，线路类型和TTL保持默认即可。</li></ol><h4 id="3-2-1、主机记录"><a href="#3-2-1、主机记录" class="headerlink" title="3.2.1、主机记录"></a>3.2.1、主机记录</h4><p>鼠标点击对应的填充框，下面都会有对应提示，先来看看主机记录：</p><p><img src="https://user-images.githubusercontent.com/35327600/232398413-3a50dc48-9c73-4e6d-8e23-63100544888e.png"></p><p>用通俗的语言来说，主机记录就是域名的前缀，通常指三级及以上的域名（腾讯云的提示中描述的时二级域名，这个描述和计算机网络中的标准定义有差异，本文将按照标准定义进行描述），比如作者申请注册的域名为 “testdomaim.xyz”，我想添加一条解析记录到 “ipv6.testdomain.xyz”，那么主机记录这里就需要填写 “ipv6”；要是还想添加一个域名叫 “ipv4.testdomain.xyz”，那么主机记录就填 “ipv4”。因为我们注册申请了一个二级域名，那么这个二级域名之上的三级域名，四级域名都可以自行设置分配。</p><p>主机记录中有两个特殊的值：”@” 和 “*“。”@” 用于直接解析我们申请的二级域名，也就是 “testdomain.xyz”，当你直接访问这个域名时，DNS服务器将会查询主机记录为 “@” 的解析记录。”*“ 则用于泛解析，故名思意，解析泛域名，意味着所有的三级域名都将通过这条解析记录进行查询。当设置了 “*“ 泛解析后，再单独设置某个三级域名解析记录，将会出现访问错误的情况。</p><h4 id="3-2-2、记录类型"><a href="#3-2-2、记录类型" class="headerlink" title="3.2.2、记录类型"></a>3.2.2、记录类型</h4><p><img src="https://user-images.githubusercontent.com/35327600/232398661-5b8504fa-f4d5-4f56-a63b-30b7e3380739.png"></p><p>记录类型只能点击下方提示的条目进行自动填充，由于我们这次需要指定的 IP 地址为 IPv6 类型，因此这里我们选择 “AAAA” 记录类型。</p><h4 id="3-2-3、记录值"><a href="#3-2-3、记录值" class="headerlink" title="3.2.3、记录值"></a>3.2.3、记录值</h4><p><img src="https://user-images.githubusercontent.com/35327600/232398697-486d6c8f-6209-4b09-98e8-9a5ba93cba68.png"></p><p>简单来说，待访问的终端 IP 地址。通过上一步的教程，我们将电脑的 IPv6 地址填入即可（请先确认地址有效，通过 mstsc 直接填入 IPv6 地址进行连接测试）。</p><p>完成以上三项内容填写后，点击保存，我们就完成了 “ipv6.testdomain.xyz” 这个域名到我们电脑的 IPv6 地址解析记录添加。如下图所示：<br><img src="https://user-images.githubusercontent.com/35327600/232403948-a30edf1b-bb73-4555-9059-dcda07ba3430.png"></p><p>打开CMD，进行 ping 连接测试 <code>ping -6 ipv6.testdomain.xyz</code>：<br><img src="https://user-images.githubusercontent.com/35327600/232404597-67f21713-5820-45fb-b232-ec8e0b21593e.png"></p><p>显示正常 ping 通，说明解析服务已经正常生效了。然后我们再使用 mstsc 进行远程方式试试：<br><img src="https://user-images.githubusercontent.com/35327600/232405249-d864a176-6e29-4d03-a9fa-f8d713524e2d.png"></p><p>也能正常进行远程连接了。至此我们已经完成了通过域名解析到IPv6地址，并进行远程访问的所有设置。接下来我们进行 DDNS 动态域名解析的相关设置。</p><h3 id="3-3、DDNS设置"><a href="#3-3、DDNS设置" class="headerlink" title="3.3、DDNS设置"></a>3.3、DDNS设置</h3><p>由于我的路由器 openwrt 固件中自带 DDNS 插件，因此下文将以路由器中的插件 “动态 DNS” 进行配置说明。</p><blockquote><p>这里推荐一个多平台（win、linux、macos等）可用，且支持docker运行的开源 DDNS 服务：”<a href="https://github.com/jeessy2/ddns-go">ddns-go</a>“，可以直接前往 github 仓库查看其使用说明。整体使用和下文配置大同小异，可相互参考借鉴。</p></blockquote><p>openwrt 中的 “动态 DNS” 界面如下：<br><img src="https://user-images.githubusercontent.com/35327600/232416946-0c5db466-f400-42de-9668-da6ecc806b1b.png"></p><p>可以看到我已经添加了一条配置，下面我们将详细介绍如何通过 “动态 DNS” 插件完成对腾讯云域名的动态解析设置。</p><p><img src="https://user-images.githubusercontent.com/35327600/232418446-39dda62d-3a00-4457-8281-4b3e4442b537.png"></p><p>点击添加按钮后，进入详细配置：</p><p><img src="https://user-images.githubusercontent.com/35327600/232418767-a9c47b89-b09a-4614-821d-b174f86ab446.png"></p><p>由于不同 DNS 服务提供商所需要填充的设置也不同，因此进入以后我们先选择 “DDNS 服务提供商”，由于我们是通过腾讯云注册的，腾讯云提供的默认服务商为 DNSPOD，因此这里我们选择 “dnspod.cn”:</p><p><img src="https://user-images.githubusercontent.com/35327600/232419295-ace51558-691f-49cc-ad44-df5f2f30c22f.png"></p><p>点击更改提供者之后，就能看到详细的配置项了：</p><p><img src="https://user-images.githubusercontent.com/35327600/232421210-57247aea-d68d-4bca-8e6e-d83d8aea852d.png"></p><p>其中 dsnpod 的用户 id 和 token，可前往 <a href="https://console.dnspod.cn/account/token/token">DNSPOD 控制台</a>进行创建。</p><p><img src="https://user-images.githubusercontent.com/35327600/232422150-426adcc2-6627-49ac-836f-288e891964f6.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/232422444-c358c376-7cf3-4a11-b051-436e3d91ee6f.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/232422934-e4179e8e-cb08-4fb2-aed1-a8a9ac49fd4a.png"></p><p>将此处获取的 id 和 token 填入到插件配置中，填充完成后点击右下角 “保存&amp;应用” 完成配置创建。然后点击下图中的启动按钮，即可启动 DDNS 服务：</p><p><img src="https://user-images.githubusercontent.com/35327600/232423971-36958701-6405-4201-97b1-c1a398a9aa66.png"></p><p>我们在点击修改按钮进入配置界面，点击上方的”日志查看器”，点击”读取&#x2F;重新读取日志文件”，查看下方日志内容：<br><img src="https://user-images.githubusercontent.com/35327600/232425360-7d05ca20-83c8-43ca-aa0a-89a05e08eebe.png"><br><img src="https://user-images.githubusercontent.com/35327600/232426260-766bf78b-70f0-45da-843b-3d2166db963a.png"></p><p>可以看到服务已经可以正常查询指定域名的 DNS 解析记录和本地 IPv6 地址。若日志中出现了 “warning “ 和 “error” 等级的日志内容，则说明有配置不正确，需要根据日志提示进行排查和修改。</p><p>DDNS 服务会每隔几分钟轮询 DNS 解析记录和本地 IP，如果本地 IP 发生变更，则会调用 DNSPod 的 API 接口，将新的 IP 地址注册到 DNSPod 中，修改对应域名的解析记录，完美解决了 IP 地址不定时更新的问题。</p><h3 id="3-4、端口转发"><a href="#3-4、端口转发" class="headerlink" title="3.4、端口转发"></a>3.4、端口转发</h3><p><font color=red>注意！！！</font><br><font color=red>如果 DDNS 服务直接运行在期望访问的远程主机上，则不需要进行此章节的设置！</font></p><p>本来配置 DDNS 解析本地 IPv6 地址的过程在上一章节就完全结束了，但是由于作者是通过路由器获取的 IPv6 地址，直接访问域名的话，实际上访问的是路由器。因此如果需要远程访问路由器下的某台电脑，则还需要在路由器的防火墙中，设置端口转发，将流量转发到指定的子网设备中。</p><p>openwrt 防火墙的端口转发仅支持 IPv4 to IPv4。我们现在需要进行 IPv6 向 IPv4 进行转发，因此还需借助另一个插件 “Socat”，来完成 IPv6 流量向 IPv4 地址的转发。</p><p>点击插件界面的 “添加” 按钮，按下图所示完成配置后，点击 “保存&amp;应用”，即可完成最后的端口转发设置。</p><p><img src="https://user-images.githubusercontent.com/35327600/232432133-eeadc95b-5d55-4ddb-afd8-8e5de8998c3c.png"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>在本文中，我们注册申请了一个二级域名，并通过设置域名的 DNS 解析记录，使得可以通过域名来对内网下的windows主机进行远程访问。完全自定义的二级和三级域名，可以是具备标识意义的名称，完美解决了 IP 地址难以记忆的问题。</p><p>我们又通过 DDNS 服务插件完成了当 IP 地址变更时，自动更新对应域名的 DNS 解析记录，确保 IP 变更时，域名仍然能正确指向我们的终端设备。</p><p>通过<a href="https://blog.csdn.net/qq_38894585/article/details/129664331">《使用公网IPv6远程访问内网设备》</a>和本文的所有配置，一般家用场景下已经能完美通过公网 IPv6 地址进行远程访问内网设备了。当然还有进阶的玩法，比如通过 DNSPod 提供的泛解析和路由器的端口转发，我们可以用不同的三级域名来访问家中的不同服务，再加上 Nginx 反向代理，实现全服务的 https 访问。</p><p>后续有时间，也许会补上 DDNS 泛解析和 Nginx 反向代理，实现内网服务的 https 外网访问。</p><p>当前专题系列还有一个问题尚未解决，要能够解析 IPv6 的域名，则当前网路需要能访问 IPv6 网络，但是部分网络环境下，这是个不可解决的难题，比如公司内网为了网络安全，往往会关闭 IPv6 网络，此时即使我们有正确的域名和解析记录，我们也无法完成远程访问。</p><p>限于篇幅原因，我们将在下一篇文章中来解决这一难题，敬请期待~</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>IPv6</tag>
      
      <tag>DDNS</tag>
      
      <tag>Domain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用公网IPv6远程访问内网设备</title>
    <link href="/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="使用公网IPv6远程访问内网设备"><a href="#使用公网IPv6远程访问内网设备" class="headerlink" title="使用公网IPv6远程访问内网设备"></a>使用公网IPv6远程访问内网设备</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>IPv4公网IP一号难求的环境下，如何优雅的使用公网IPv6进行远程访问？本文将以中国移动的宽带和光猫为例，进行IPv6的设置说明，并实现通过IPv6地址和Windows系统自带的远程工具”mstsc”，远程访问内网的Windows主机。</p><p>可能部分宽带安装师傅默认没有打开 IPv6 的功能，因此我们先登录光猫的后台确认光猫是否开启了 IPv6。由于电信的宽带服务相对比较容易获取到公网IPv4地址，因此这里以移动宽带举例，其他宽带运营商提供的光猫可能有所差异，但是功能大同小异，请自行搜索相应操作细节。</p><h2 id="二、确认IPv6连接状态"><a href="#二、确认IPv6连接状态" class="headerlink" title="二、确认IPv6连接状态"></a>二、确认IPv6连接状态</h2><p>如果宽带是由光猫拨号连接的，在浏览器中输入光猫的后台地址，例如 <code>192.168.1.1</code>，移动光猫的后台界面如下图所示。一般来说，移动光猫的管理员账号和密码是相同的，曾经在同一省份的不同城市都办理过移动宽带，光猫后台的账号密码都如图中所示 <code>账号：CMCCAdmin  密码：aDm8H%MdA</code> 。不确定不同省份是否有所差异，如果这个账号密码不可用，请自行搜索或者向宽带运营商索取。</p><p><img src="https://user-images.githubusercontent.com/35327600/223893633-286b2a64-fbe5-4f88-b4b1-ed7ea31af0d4.png"></p><p>点击确定后，进入后台界面，按下图中所标识的按钮和顺序，依次点击，可以在当前界面查看到 IPv6 的连接信息。</p><p><img src="https://user-images.githubusercontent.com/35327600/223897533-878fed3e-07c9-4912-8679-dc645432fefb.png"></p><p>如果确定 IPv6 已正确连接，在上图界面中，可以拉动横向的滚动条，查看当前的 IPv6 地址。</p><p><img src="https://user-images.githubusercontent.com/35327600/226225202-a8abe3c7-357b-4a32-83b4-2e618983d270.png"></p><p>如果上述界面中显示IPv6未连接，请根据以下界面检查运营商是否给当前宽带套餐开通IPv6功能。</p><p><img src="https://user-images.githubusercontent.com/35327600/226227385-07eb44f5-9836-47d3-89ef-7237f855b369.png"></p><h2 id="三、打开并查看远程主机IPv6地址"><a href="#三、打开并查看远程主机IPv6地址" class="headerlink" title="三、打开并查看远程主机IPv6地址"></a>三、打开并查看远程主机IPv6地址</h2><p>这里以win10系统为例，可能部分人的PC默认没有开启IPv6，按照以下步骤打开IPv6，并获取IPv6地址。</p><ol><li>按下 “windows徽标” + “R”，打开运行窗口，输入 “ncpa.cpl” 后回车，打开网络适配器管理界面<br> <img src="https://user-images.githubusercontent.com/35327600/226231169-7eb0ce41-e3b9-429b-b9b2-06306351b0a5.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226231296-153119ad-ce30-4477-ac49-2e53a3a88316.png"></li><li>双击以太网连接，查看当前以太网状态，若IPv6连接显示无网络连接，则按以下图片内说明打开IPv6连接<br> <img src="https://user-images.githubusercontent.com/35327600/226232249-91264fa3-74f0-44d1-891b-64f0ba50561c.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226233016-617c197b-32e8-4d0e-bbdf-d36cac0deb69.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226234598-aa6dba1e-1b3c-4928-a1ea-5ae0794f61f0.png"></li></ol><h2 id="四、打开本地PC的IPv6连接"><a href="#四、打开本地PC的IPv6连接" class="headerlink" title="四、打开本地PC的IPv6连接"></a>四、打开本地PC的IPv6连接</h2><p>由于需要使用IPv6进行远程连接，需要确保本地 PC 和远程 PC 同时具备 IPv6 的连接能力，因此对于本地PC，也需要按照上述<strong>第2步</strong>进行确认。</p><blockquote><p>远程PC和本地PC可使用浏览器访问<a href="http://ipv6.test-ipv6.com/">IPv6测试网站</a>进行连接测试。</p></blockquote><p>完成两端的 IPv6 连接设置后，可以直接使用 IPv6 地址尝试远程连接，不出意外，此时已经可以成功进行远程访问了。</p><ul><li>按下 “windows 徽标” + “R”，打开运行界面，输入 “mstsc”，回车，打开远程连接界面，填入第二步中获取的”<strong>远程 PC 的 IPv6 地址</strong>“，点击连接。正常情况下，此时会弹出要求输入用户名和密码。<br>  <img src="https://user-images.githubusercontent.com/35327600/226236201-a851eec6-c3a7-40dd-b6f0-70f4e48889c2.png"></li></ul><h2 id="五、遇到的坑"><a href="#五、遇到的坑" class="headerlink" title="五、遇到的坑"></a>五、遇到的坑</h2><p>整个过程可能会存在两个坑，导致无法连接：</p><ol><li>光猫默认使能IPv6防火墙的控制转发报文功能（作者的移动光猫中是这么描述的），导致所有的IPv6数据包被拦截，从而无法建立远程连接，甚至无法 ping 通。需要将该功能关闭，才能正常使用IPv6。<br> <img src="https://user-images.githubusercontent.com/35327600/226237991-c5b5cadb-0837-40c6-aa1d-48d968927ce3.png"></li><li>远程PC未打开远程访问功能。win10家庭版不支持远程桌面，专业版则默认关闭了远程桌面，因此需要手动打开和确认。<br> <img src="https://user-images.githubusercontent.com/35327600/226238918-83374ecb-6640-4c8e-87bd-2153e81124ac.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226239110-a296c35e-5546-4a3d-b5cb-913901ac9121.png"></li><li>部分网络默认不开启IPv6，例如公司内部网络等，因此远程PC虽然开启了IPv6，但仍然无法通过IPv6进行远程连接；</li></ol><h2 id="六、存在的缺陷"><a href="#六、存在的缺陷" class="headerlink" title="六、存在的缺陷"></a>六、存在的缺陷</h2><p>按步骤完成上述操作后，一般来说，已经能成功使用IPv6地址进行远程访问。但是使用起来仍然存在2个比较致命的问题：</p><ol><li>IPv6 地址很长，不方便记忆；</li><li>公网 IPv6 地址并非固定不变，在一定情况下，地址发生变更，如果不能及时获取地址，则无法进行远程访问</li><li>部分网络无IPv6的Internet访问权限，比如公司内网等，则无法访问任何IPv6地址</li></ol><p>针对第一个缺陷，由于域名可以自定义申请，并且方便记忆，因此我们可以申请一个域名（例如 baidu.com、google.com），并将域名解析到对应IP地址（DNS服务商提供解析服务），通过域名来进行访问。</p><p>而第二个缺陷，在域名的基础上，我们还需要定期将当前的IP地址，同步给DNS服务商，修改域名解析的目标IP，确保域名能正确解析到我们自己的设备上。</p><p>第三个缺陷，我们则需要借助域名解析服务商提供的CDN功能进行IPv4访问，IPv6回源，同时国内的CDN服务都需要域名在工信部备案（这里点个名，由于作者域名在鹅厂购买的，本来考虑直接使用它的ECDN，结果个人域名备案需要绑定国内云服务器实例….其他云服务商不确定是否也具有同样的骚操作），不得不考虑国外的CDN服务，例如大名鼎鼎的 Cloudflare。</p><p>由于文章篇幅较长，因此将在专栏后续文章中进行详细说明介绍~</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>IPv6</tag>
      
      <tag>mstsc</tag>
      
      <tag>网络运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于DSM7.1，通过nginx反代破解Emby Server Premiere</title>
    <link href="/2023/03/13/%E5%9F%BA%E4%BA%8EDSM7-1%EF%BC%8C%E9%80%9A%E8%BF%87nginx%E5%8F%8D%E4%BB%A3%E7%A0%B4%E8%A7%A3Emby-Server-Premiere/"/>
    <url>/2023/03/13/%E5%9F%BA%E4%BA%8EDSM7-1%EF%BC%8C%E9%80%9A%E8%BF%87nginx%E5%8F%8D%E4%BB%A3%E7%A0%B4%E8%A7%A3Emby-Server-Premiere/</url>
    
    <content type="html"><![CDATA[<h1 id="基于DSM7-1，通过nginx反代破解Emby-Server-Premiere"><a href="#基于DSM7-1，通过nginx反代破解Emby-Server-Premiere" class="headerlink" title="基于DSM7.1，通过nginx反代破解Emby Server Premiere"></a>基于DSM7.1，通过nginx反代破解Emby Server Premiere</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><strong><font color="red">！！！破解教程仅供学习参考，务必支持正版软件，构建良好的软件版权生态！！！</font></strong></p><p>Emby Server是一个开源的流媒体中心软件，可以非常方便的管理和维护电影，电视剧集等媒体库，并生成强大美观的海报墙。并且全平台的客户端，使其跨设备观看变得非常便利。但是服务端的部分插件功能，以及视频转码功能，需要会员才能解锁。针对尝鲜的个人用户来说，这个会员着实不便宜，经过搜寻相关资料后，确定其会员验证是通过与<code>mb3admin.com</code>这个网站通信完成，因此本教程将通过nginx的反向代理+hosts进行域名劫持来实现会员的”破解”。</p><h2 id="二、准备工具"><a href="#二、准备工具" class="headerlink" title="二、准备工具"></a>二、准备工具</h2><ul><li>DMS7.1群晖系统（本质上任意一个nginx服务都可以，DSM本身的web就是通过nginx实现的，因此不需要单独在开一个nginx服务了）</li><li>文本编辑软件（Notepad++，subline text，vs code均可）</li><li>ssh工具（Xshell，MobaXterm，putty，finalshell等）</li></ul><h2 id="三、破解步骤"><a href="#三、破解步骤" class="headerlink" title="三、破解步骤"></a>三、破解步骤</h2><h3 id="1、申请ssl证书"><a href="#1、申请ssl证书" class="headerlink" title="1、申请ssl证书"></a>1、申请ssl证书</h3><p>由于Emby Server需要和<code>mb3admin.com</code>进行https通信，因此我们需要针对该域名申请ssl证书。</p><p>推荐 GMCert.org <a href="https://www.gmcert.org/subForm%E3%80%82%E6%8C%89%E4%BB%A5%E4%B8%8B%E7%94%B3%E8%AF%B7%E6%AD%A5%E9%AA%A4%E8%BF%9B%E8%A1%8C%EF%BC%9A">https://www.gmcert.org/subForm。按以下申请步骤进行：</a></p><p><img src="https://user-images.githubusercontent.com/35327600/201810752-d921d035-c76d-439c-9160-e320a36af37d.jpg"></p><ul><li>CA证书如果此前PC端已安装过，则可不用重复下载安装；如果是全新安装，则尽量安装一下，双击证书，点击安装，然后手动选择证书存储，将证书安装到“受信任的根证书颁发机构”即可。</li><li>主题名称为此次所需的二级域名<code>mb3admin.com</code></li></ul><p>点开下方的“<strong>高级选项</strong>”，并按照以下进行配置：</p><p><img src="https://user-images.githubusercontent.com/35327600/201813309-cc83b055-df1d-4b61-bda9-103939c7cc2c.png"></p><ul><li>在主题备用名称中，填入上图内容，将泛域名也填充进去，保证任意三级域名都处于ssl证书授权范围</li><li>密钥用途和扩展密钥用途按图中红框勾选即可</li><li>点击“<strong>签发证书</strong>”，会下载一个包含密钥和证书的压缩包，解压并保存</li></ul><h3 id="2、上传密钥和证书"><a href="#2、上传密钥和证书" class="headerlink" title="2、上传密钥和证书"></a>2、上传密钥和证书</h3><p>将上一步中解压获取的证书和密钥文件，上传至群晖中</p><p><img src="https://user-images.githubusercontent.com/35327600/201814624-8bc428eb-1947-430f-a27a-2301ce7379d8.png"></p><h3 id="3、创建nginx代理配置"><a href="#3、创建nginx代理配置" class="headerlink" title="3、创建nginx代理配置"></a>3、创建nginx代理配置</h3><p>新建文件<code>emby_crack_nginx.conf</code>，粘贴以下内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>     <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>     <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">443</span> ssl;<br>     <span class="hljs-attribute">server_name</span> mb3admin.com;<br>     <span class="hljs-attribute">ssl_certificate</span> /volume1/web/mb3admin.com/mb3admin.com.cert.pem;<br>     <span class="hljs-attribute">ssl_certificate_key</span> /volume1/web/mb3admin.com/mb3admin.com.key.pem;<br>     <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;<br>     <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>     <span class="hljs-attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<br>     <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br>     <span class="hljs-section">location</span> = /webdefault/images/logo.jpg &#123;<br>     <span class="hljs-attribute">alias</span> /usr/syno/share/nginx/logo.jpg;<br>            &#125;<br>     <span class="hljs-section">location</span> <span class="hljs-variable">@error_page</span> &#123;<br>     <span class="hljs-attribute">root</span> /usr/syno/share/nginx;<br>     <span class="hljs-attribute">rewrite</span> (.*) /<span class="hljs-literal">error</span>.html <span class="hljs-literal">break</span>;<br>            &#125;<br>     <span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /.well-known/acme-challenge &#123;<br>     <span class="hljs-attribute">root</span> /var/lib/letsencrypt;<br>     <span class="hljs-attribute">default_type</span> text/plain;<br>            &#125;<br>     <span class="hljs-section">location</span> / &#123;<br>     <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^</span> / <span class="hljs-literal">redirect</span>;<br>            &#125;<br>     <span class="hljs-section">location</span> <span class="hljs-regexp">~ ^/$</span> &#123;<br>     <span class="hljs-attribute">rewrite</span> / https://<span class="hljs-variable">$host</span>:5001/ <span class="hljs-literal">redirect</span>;<br>            &#125;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin *;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers *;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Method *;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;<br>     <span class="hljs-section">location</span> /admin/service/registration/validateDevice &#123;<br>     <span class="hljs-attribute">default_type</span> application/json;<br>     <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&#123;&quot;cacheExpirationDays&quot;: 365,&quot;message&quot;: &quot;Device Valid&quot;,&quot;resultCode&quot;: &quot;GOOD&quot;&#125;&#x27;</span>;<br>    &#125;<br>     <span class="hljs-section">location</span> /admin/service/registration/validate &#123;<br>     <span class="hljs-attribute">default_type</span> application/json;<br>     <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&#123;&quot;featId&quot;:&quot;&quot;,&quot;registered&quot;:true,&quot;expDate&quot;:&quot;2099-01-01&quot;,&quot;key&quot;:&quot;&quot;&#125;&#x27;</span>;<br>    &#125;<br>     <span class="hljs-section">location</span> /admin/service/registration/getStatus &#123;<br>     <span class="hljs-attribute">default_type</span> application/json;<br>     <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&#123;&quot;deviceStatus&quot;:&quot;0&quot;,&quot;planType&quot;:&quot;Lifetime&quot;,&quot;subscriptions&quot;:&#123;&#125;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><p>由于证书和密钥的文件路径可能各有不同，在上述代码块中修改成自定义路径</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># ssl_certificate /volume1/web/mb3admin.com/mb3admin.com.cert.pem;</span><br><span class="hljs-attribute">ssl_certificate</span> /change/to/your/own/cert/file/path;<br><span class="hljs-comment"># ssl_certificate_key /volume1/web/mb3admin.com/mb3admin.com.key.pem;</span><br><span class="hljs-attribute">ssl_certificate_key</span> /change/to/your/own/key/file/path;<br></code></pre></td></tr></table></figure></li></ul><p>将配置文件<code>emby_crack_nginx.conf</code>拷贝至群晖的系统目录<code>/etc/nginx/sites-enabled</code>目录下。</p><h3 id="4、修改hosts文件"><a href="#4、修改hosts文件" class="headerlink" title="4、修改hosts文件"></a>4、修改hosts文件</h3><p>由于Emby Server和Emby Client在验证会员时，向<code>mb3admin.com</code>进行post请求，因此需要在服务器或者客户端发出请求时，劫持到我们自行构建的nginx服务上，通过nginx发送假的验证通过的消息，实现会员资格验证成功。</p><p>因此需要在Emby Server和Emby Client所在的设备上修改hosts文件，将mb3admin.com域名直接指向群晖的IP。</p><ul><li>如果家中有能修改hosts的路由设备，可在路由器中直接修改，这样就不需要在每一个子设备中进行修改了；如果没有则在以下设备中的hosts文件中加入代码块中内容；</li><li>Emby Server所在服务端设备；</li><li>windows系统PC端；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># hosts</span><br><span class="hljs-comment"># &lt;群晖IP&gt; mb3admin.com</span><br><span class="hljs-comment"># 假如群晖IP是：192.168.1.100，则如下所示</span><br>192.168.1.100 mb3admin.com<br></code></pre></td></tr></table></figure><h3 id="5、向Emby服务端的证书库中导入CA证书"><a href="#5、向Emby服务端的证书库中导入CA证书" class="headerlink" title="5、向Emby服务端的证书库中导入CA证书"></a>5、向Emby服务端的证书库中导入CA证书</h3><p>在日志中发现会存在无法建立SsL连接的情况，爬贴后发现，是因为自签名证书不被Emby信任导致。这时候就需要我们将当初申请证书时，获取到的CA证书导入到Emby的可信任证书库中。docker 版本的话，需要先确认根证书文件是否由 host 端导入。整体操作流程，无论是套件版本还是 docker 版本，都大同小异。下面以套件版本为例进行说明。</p><blockquote><p>一般根证书文件存储在 <code>/etc</code> 目录下，因此需要 root 权限才能完成。以下操作均在 root 用户下进行。</p></blockquote><ol><li>进入证书存储的目录，以上文为例，执行命令： <code>cd /volume1/web/mb3admin.com</code> </li><li>打印证书内容，观察格式是否正确：<code>cat mb3admin.com.cert.pem</code><br> 按下回车键后，屏幕将输出形如一下内容，确认文件以 <code>-----BEGIN CERTIFICATE-----</code> 开头，<code>-----END CERTIFICATE-----</code> 结尾：<br> <img src="https://user-images.githubusercontent.com/35327600/224621454-b0d99048-5b8c-470e-b7b9-70d81d5865df.jpg"></li><li>将证书拷贝至对应目录，并重命名。这里以群晖7.1为例，执行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /usr/syno/etc/security-profile/ca-bundle-profile/ca-certificates/;<br><span class="hljs-built_in">cp</span> /volume1/web/mb3admin.com/mb3admin.com.cert.pem /usr/syno/etc/security-profile/ca-bundle-profile/ca-certificates/mb3admin.com.crt;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p> &#x2F;usr&#x2F;syno&#x2F;etc&#x2F;security-profile&#x2F;ca-bundle-profile&#x2F;ca-certificates&#x2F; 这个路径是从update-ca-certificates.sh中获取的，不同系统的路径可能不同，建议先执行 <code>sodu find / -name &quot;update-ca-certificates</code> ，查找这个文件。例如群晖7.1中，该文件位于 &#x2F;usr&#x2F;syno&#x2F;bin 中。使用 cat 命令查看文件内容，找到 <code>USERCERTSDIR=xxxxxxx</code> 行，”xxxxxxxx” 就是对应的路径；Ubuntu系统下，找到 LOCALCERTSDIR&#x3D;xxxxx 行即可。</p></blockquote><ol start="4"><li>更新根证书，执行命令：<code>update-ca-certificates.sh</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Emby</tag>
      
      <tag>群晖DSM7.1</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unraid自定义docker和虚拟机图标</title>
    <link href="/2023/02/21/Unraid%E8%87%AA%E5%AE%9A%E4%B9%89docker%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BE%E6%A0%87/"/>
    <url>/2023/02/21/Unraid%E8%87%AA%E5%AE%9A%E4%B9%89docker%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Unraid自定义docker和虚拟机图标"><a href="#Unraid自定义docker和虚拟机图标" class="headerlink" title="Unraid自定义docker和虚拟机图标"></a>Unraid自定义docker和虚拟机图标</h1><h2 id="一、自定义docker图标"><a href="#一、自定义docker图标" class="headerlink" title="一、自定义docker图标"></a>一、自定义docker图标</h2><p>在 Unraid 中可以通过自带的应用市场安装 docker 容器，但是也有部分docker并未上架市场，需要通过 “ADD CONTAINER” 按钮手动安装，这样的 docker 容器并没有自带图标。还有一部分即使是在应用市场安装的 docker 容器本身有图标，但是由于国内的网络环境原因，导致图标链接不可访问，最终在 docker 界面中显示一个灰底的问号。</p><p>这里用一个手动安装的 python:alpine3.16 的容器作为示例进行说明：<br><img src="https://user-images.githubusercontent.com/35327600/220238709-7d4f5fff-c5f6-4955-a2be-b84d23658354.png"></p><p>下面介绍两种方式来自定义设置 Docker 容器的图标。</p><h3 id="1-1、方法一：直接修改-Docker-容器配置"><a href="#1-1、方法一：直接修改-Docker-容器配置" class="headerlink" title="1.1、方法一：直接修改 Docker 容器配置"></a>1.1、方法一：直接修改 Docker 容器配置</h3><p>无论是从应用市场安装的 docker 容器还是手动创建的，都会在安装前展示容器的配置界面，两种安装方式的差别仅仅就是应用市场的 docker 容器会将大部分的配置参数预先填充，避免了手动配置填充的过程，为部分经验不足的新手提供了相当的便利。</p><p>一般来说，配置界面只展示了基础配置，我们点击右上角的 “BASIC VIEW” 按钮，打开高级配置 “ADVANCED VIEW”:<br><img src="https://user-images.githubusercontent.com/35327600/220241255-d0f8e445-8d3d-4de6-929a-01719f8c7d87.png"></p><p>打开后可见新增了许多配置项：<br><img src="https://user-images.githubusercontent.com/35327600/220242308-ad3b6a1f-621c-4fc7-b13f-5e5d56e45ec3.png"></p><p>可以看到新增的配置项中，有一项名为 “Icon URL” 的配置，这里填充的就是当前 docker 容器的图标链接。我们在网上找一个 Python 的图标，并复制其图片地址进行配置填充：<br>python图标链接：<code>https://github.com/walkxcode/dashboard-icons/blob/main/png/python.png?raw=true</code><br><img src="https://user-images.githubusercontent.com/35327600/220243495-3daabdd1-79bf-42d9-a819-375c763719de.png"></p><p>配置完成后，点击 “APPLY” 按钮更新应用配置，待完成后在 Docker 界面就能看到图标由原本的问号，变为刚在填充的链接所展示的 python 图标了。<br><img src="https://user-images.githubusercontent.com/35327600/220243941-f6dc6ec8-7df4-4cb9-a83b-39ec20738bdf.png"></p><p>方法一操作简单，直接在 WebUI 中进行配置即可。但是也有朋友想用本地自己制作的个性化图标，一种方法就是将图标上传到图床，然后使用图床链接进行配置。如果是具有个人版权的图标，不想上传到公共图床或者网络上，同时也不想自建图床，因为自建图床的学习成本相对较高，那么有没有其他办法进行修改配置呢？请看方法二——本地存储图标配置。</p><h3 id="1-2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）"><a href="#1-2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）" class="headerlink" title="1.2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）"></a>1.2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）</h3><p><mark>再次重申一下，方法二需要使用命令行操作，不会的朋友请尽量使用方法一，避免对系统本身造成无法修复的损害</mark>。</p><ul><li><p>首先我们先将图标下载到本地（因为我本地没有 Python 的图标，所以此处需要下载，如果本地已经有对应图标，就不需要下载），并存放到 unRAID 的任意共享目录中。</p></li><li><p>将图片名称修改为以下样式 <code>&lt;docker 容器名&gt;-icon.png</code> 。例如此处使用命令 <code>mv python.png python-icon.png</code> 即可完成重命名。<br>  这里我直接采用的 unRAID 后台命令行进行操作，也可以直接在windows下进行重命名<br>  <img src="https://user-images.githubusercontent.com/35327600/220259348-6b70c342-98e6-4d57-bade-6e6ee4111d04.png"></p></li><li><p>然后我们通过命令行将重命名后的图标文件拷贝到这个目录：<code>/var/lib/docker/unraid/images</code> 。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp python-icon.png /var/lib/docker/unraid/images;<br></code></pre></td></tr></table></figure><p>  其实在这个目录下，使用 ls 命令就能发现，所有 docker 容器的图标都被存放在这个目录底下。<br>  此时 docker 的图标还未生效，刷新界面后仍然显示的是灰底的问号。</p></li><li><p>下一步，我们需要去修改 docker 容器的配置。和<strong>方法一</strong>一样，打开高级配置，找到 “Icon URL” 配置项，但是此时<font color=red>不需要填充真实的链接，随意填入内容即可</font>。这是为了告诉 unRAID 系统，这个 docker 容器是有图标的，你得给我显示出来。<br>  但是为什么可以填充随意内容呢？结合上一步中在目录 <code>/var/lib/docker/unraid/images</code> ，我们不难猜到，unRAID 只是根据 “Icon URL” 中的链接去下载图标到特定目录，然后根据 docker 容器的命名和图标文件的命名进行匹配和展示的。由于我们自行将图标重命名并且存放到了指定位置，所以 unRAID 系统自然能进行匹配和展示了。</p><p>  <img src="https://user-images.githubusercontent.com/35327600/220262561-88362131-b355-498c-8193-899e7bc8564d.png"></p><p>  填充完成后，还是老样子，点击下方 “APPLY” 按钮，此时你会发现图标已经变成你自定义的样子了。</p><p>  <img src="https://user-images.githubusercontent.com/35327600/220262946-6d53e1b0-5197-4e09-b79e-a4a96aa2ccb5.png"></p></li></ul><h2 id="二、自定义虚拟机图标"><a href="#二、自定义虚拟机图标" class="headerlink" title="二、自定义虚拟机图标"></a>二、自定义虚拟机图标</h2><p>unRAID 提供的虚拟机图标类型较少，可能无法满足部分朋友的需要，此时也可通过自定义的方式进行配置。配置方法十分简单，下面一起来看下。</p><p>注意：虚拟机的配置修改需要在虚拟机处于关机状态下进行。</p><ol><li>第一步，打开虚拟机配置编辑，点击右上角的 “FORM VIEW”，打开 “XML VIEW” 模式<br> <img src="https://user-images.githubusercontent.com/35327600/220265145-e9d995dd-acd7-46fa-b717-b205d76de807.png"></li><li>按下键盘的 <code>Ctrl</code> + <code>F</code> 键，在弹出的搜索框中输入 “icon”，并回车进行搜索，找到 XML 文件中对应的字样<br> <img src="https://user-images.githubusercontent.com/35327600/220266149-ece8dd67-c4a1-4b5f-9111-a50b7999b615.png"></li><li>将下划线部分 <code>icon=&quot;/mnt/user/domains/DSM7.1/synology_icon.png&quot;</code> 双引号中的内容，修改为你自定义虚拟机图标的绝对路径。图标存放位置不限。<blockquote><p>图标文件的绝对路径，以存在位置为 unRAID 上创建的共享路径为例，可以参考这样修改：&#x2F;mnt&#x2F;user&#x2F;&lt;共享路径&gt;。将尖括号内的路径修改为图标在共享目录下的路径即可。以上文为例，我的共享目录是 domains，并在 domains 下创建了 DSM7.1 的子目录，图标存放在子目录中，因此绝对路径就是：&#x2F;mnt&#x2F;user&#x2F;domains&#x2F;DSM7.1&#x2F;synology_icon.png</p></blockquote></li><li>点击下方 “UPDATE” 按钮后即可生效<br> <img src="https://user-images.githubusercontent.com/35327600/220266951-c1cf9a8d-e093-4de1-a11d-f7cf9434d1ac.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>docker</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个“size_type”引发的Bug</title>
    <link href="/2023/02/21/%E4%B8%80%E4%B8%AA%E2%80%9Csize-type%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84Bug/"/>
    <url>/2023/02/21/%E4%B8%80%E4%B8%AA%E2%80%9Csize-type%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84Bug/</url>
    
    <content type="html"><![CDATA[<h1 id="一个“size-type”引发的Bug"><a href="#一个“size-type”引发的Bug" class="headerlink" title="一个“size_type”引发的Bug"></a>一个“size_type”引发的Bug</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">10</span>&#125;;<br>  <span class="hljs-comment">// 这是一个极端示例</span><br>  <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (pos &lt;= v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;pos &lt;= v.size() - 2&quot;</span> &lt;&lt; endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;pos &gt; v.size() - 2&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察上述示例代码，请回答出程序输出内容是什么？答案是 “pos &lt;&#x3D; v.size() - 2”，还是 “pos &gt; v.size() - 2” 呢？</p><p>可能有的人和我一样，第一反应是 <code>std::vector v</code> 中只有一个元素，因此 <code>v.size() == 1</code>，那 <code>0</code> 和 <code>1 - 2</code> 比较大小，肯定是结果是 “&gt;” 嘛。但是程序运行结果却告诉我们，这里输出的内容是 <code>pos &lt;= v.size() - 2</code> !</p><p>在 Ubuntu20.04 和 Debian10.2.1 中进行测试，结果均为 <code>pos &lt;= v.size() - 2</code>。运行结果如下</p><p><img src="https://user-images.githubusercontent.com/35327600/218906559-3314a6d2-d277-45a6-b50c-d9005bd3f496.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/218907216-e6132f30-a3e5-4ed8-8e52-63a242cc8242.png"></p><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>既然运行结果是 <code>pos &lt;= v.size() - 2</code>，那我们把这个 “&lt;&#x3D;” 号左右两边的值打印出来看看，到底是否与我们认为的 <code>pos == 0</code> 和 <code>v.size() - 2 == -1</code> 的结论一致。将日志输出行修改一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-keyword">if</span> () &#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;pos[&quot;</span> &lt;&lt; pos &lt;&lt; <span class="hljs-string">&quot;] &lt;= v.size() - 2[&quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;]&#x27;</span> &lt;&lt; endl;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>再次编译执行，结果如下：</p><p><img src="https://user-images.githubusercontent.com/35327600/218909328-2a63cad0-6eae-4bef-9529-bea27192ef65.png"></p><p>在控制台输出打印中可以看到，表达式 <code>v.size() - 2</code> 并非像我们认为的那样等于 “1 - 2 &#x3D;&#x3D; -1”，而是一个非常大的数值。其实到这里，有一定经验的程序员已经大概知道这是为什么了。负数，巨大数值，根据这两个因素基本可以确定是<font color=red>有符号类型（-1）被隐式转换成了无符号类型导致的溢出</font>！</p><p>这个问题，具体情况，我们可以通过gdb进行反汇编调试来仔细跟踪一下。</p><blockquote><p>真正的地址需要程序运行起来之后才能正确反汇编出来，否则反汇编出来的是偏移地址。</p></blockquote><p>先设置一个程序入口断点，确保程序已运行，我们在 main 函数的入口设置一个断点 <code>b *main</code>，并运行命中断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b *main<br>Breakpoint 1 at 0x11f5: file ./size_t.cc, line 7.<br>(gdb) r<br>Starting program: /home/openwrt/tmp/size_t/unittest_size_t<br><br>Breakpoint 1, main (argc=1, argv=0x11bf) at ./size_t.cc:7<br>7       int main(int argc, char* argv[]) &#123;<br>(gdb)<br><br></code></pre></td></tr></table></figure><p>然后再确定一下 if 这个判断语句的地址范围和反汇编内容。在 gdb 模式下输入 <code>disas /m main</code> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas /m main<br>Dump of assembler code for function main(int, char**):<br>7       int main(int argc, char* argv[]) &#123;<br>=&gt; 0x00005555555551f5 &lt;+0&gt;:     push   %rbp<br><br>......<br><br>11        if (pos &lt;= v.size() - 2) &#123;<br>   0x0000555555555261 &lt;+108&gt;:   mov    -0x24(%rbp),%eax<br>   0x0000555555555264 &lt;+111&gt;:   movslq %eax,%rbx<br>   0x0000555555555267 &lt;+114&gt;:   lea    -0x50(%rbp),%rax<br>   0x000055555555526b &lt;+118&gt;:   mov    %rax,%rdi<br>   0x000055555555526e &lt;+121&gt;:   call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>   0x0000555555555273 &lt;+126&gt;:   sub    $0x2,%rax<br>   0x0000555555555277 &lt;+130&gt;:   cmp    %rax,%rbx<br>   0x000055555555527a &lt;+133&gt;:   setbe  %al<br>   0x000055555555527d &lt;+136&gt;:   test   %al,%al<br>   0x000055555555527f &lt;+138&gt;:   je     0x5555555552f5 &lt;main(int, char**)+256&gt;<br><br>......<br>(gdb)<br><br></code></pre></td></tr></table></figure><p>我们先看其中这一段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x000055555555526e &lt;+121&gt;:   call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>0x0000555555555273 &lt;+126&gt;:   sub    $0x2,%rax<br>0x0000555555555277 &lt;+130&gt;:   cmp    %rax,%rbx<br></code></pre></td></tr></table></figure><p>这里第一个 call 语句中，我们可以看到调用了 <code>std::vector::size()</code> 的方法，我们将断点设置在这一处 <code>b *0x000055555555526e</code>，并执行 continue，直至命中断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b *0x000055555555526e<br>Breakpoint 2 at 0x55555555526e: file ./size_t.cc, line 11.<br>(gdb) c<br>Continuing.<br><br>Breakpoint 2, 0x000055555555526e in main (argc=1, argv=0x7fffffffe4a8)<br>    at ./size_t.cc:11<br>11        if (pos &lt;= v.size() - 2) &#123;<br>(gdb) x/3i $pc<br>=&gt; 0x55555555526e &lt;main(int, char**)+121&gt;:<br>    call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>   0x555555555273 &lt;main(int, char**)+126&gt;:      sub    $0x2,%rax<br>   0x555555555277 &lt;main(int, char**)+130&gt;:      cmp    %rax,%rbx<br><br></code></pre></td></tr></table></figure><p>观察 pc 指针，已经运行到断点所在地址，从这三句汇编语句中，我们不难看出寄存器 rax 中存放的是表达式 <code>v.size() - 2</code> 的结果，rbx 中则存放的是变量 pos 的值。我们进行单步调试，并在每次步进后查看这两个寄存器的值和寄存器标志位的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) ni  ## call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>11        if (pos &lt;= v.size() - 2) &#123; <br>(gdb) i r rax rbx eflags<br>rax            0x1                 1<br>rbx            0x0                 0<br>eflags         0x202               [ IF ]<br>(gdb) ni  ## sub    $0x2,%rax<br>11        if (pos &lt;= v.size() - 2) &#123;<br>(gdb) i r rax rbx eflags<br>rax            0xffffffffffffffff  -1<br>rbx            0x0                 0<br>eflags         0x297               [ CF PF AF SF IF ]<br>(gdb) x/3i $pc<br>=&gt; 0x555555555277 &lt;main(int, char**)+130&gt;:      cmp    %rax,%rbx<br>   0x55555555527a &lt;main(int, char**)+133&gt;:      setbe  %al<br>   0x55555555527d &lt;main(int, char**)+136&gt;:      test   %al,%al<br>(gdb) ni  ## cmp    %rax,%rbx<br>0x000055555555527a      11        if (pos &lt;= v.size() - 2) &#123;<br>(gdb) i r rax rbx eflags<br>rax            0xffffffffffffffff  -1<br>rbx            0x0                 0<br>eflags         0x213               [ CF AF IF ]<br>(gdb)<br><br></code></pre></td></tr></table></figure><p>通过记录标志位，我们不难发现，当执行 <code>sub $0x2 %rax</code> 时，标志位 CF 被置位了，这代表了<font color=red>这次的减法运算，是无符号类型数的减法运算，并且存在借位，即溢出</font>，同时 SF 也被置位了，表明当前的减法计算结果是一个负数（由于计算机中存放的数据以其补码形式存放，所以此处 0xffffffffffffffff 为补码，转换为源码就是 0x8000000000000001，十进制表示就是-1）。但是在后续的 <code>cmp %rax %rbx</code> 语句中，<mark>标志位 CF 再次被置位，也就意味着计算机将 rax 和 rbx 中的值都按照无符号数进行了减法计算</mark> <code>0x0 - 0xffffffffffffffff</code> 自然产生了借位的情况，所以计算机自然而然地认为 “0 &lt; -1”！</p><p>所以问题的根本原因在于计算机执行 cmp 指令时，将原本应该是有符号数 “-1” 当成了无符号数 “0xffffffffffffffff” 进行比较。因此在判断大小时，出现了异常的结果。</p><h2 id="问题跟踪"><a href="#问题跟踪" class="headerlink" title="问题跟踪"></a>问题跟踪</h2><p>那为什么计算机会将 “-1” 当成是无符号数呢，我们来看一下 <code>std::vector::size()</code> 方法的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><p>因此 <code>v.size()</code> 返回的 1 是 size_type 类型的。这个类型在 cplusplus 网站中，被释义为无符号整型，通常境况下同 size_t。到这里就真相大白了，由于 <code>v.size()</code> 这个方法返回了一个无符号整形结果，因此后续的减法运算和大小比较中，C++ 默认对此进行了隐式转换有符号整型转换为无符号整形，所有的运算都变成了无符号数的运算（对于无符号整形作减法的溢出，编译器不会做出任何警告）。</p><p>结合上文中通过反汇编调试得到的结论，证明问题的原因和最初我们的猜想是一致的。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>既然知道了问题的根本原因，那么解决方法也相对简单，只要保证进行运算操作时类型转换是合法的即可，</p><p>因为示例代码中 <code>v.size()</code> 获得的无符号整形较小，因此我们可以将其直接显式转换为有符号整形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br>  <span class="hljs-keyword">if</span> (pos &lt;= (<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>) &#123;<br>...<br></code></pre></td></tr></table></figure><p>但是这并不意味着只要显式地转换数据类型，就不会发生错误了。比如负数转换成无符号数，无符号数的最大值转换成有符号数，这两种就是典型的类型转换导致数值溢出的问题。</p><p>我们应该在不得不进行数据类型转换前，保证转换后不会出现溢出的问题！</p>]]></content>
    
    
    <categories>
      
      <category>踩坑日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>C++</tag>
      
      <tag>Bug</tag>
      
      <tag>溢出</tag>
      
      <tag>类型转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令简记</title>
    <link href="/2023/02/21/Linux%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/"/>
    <url>/2023/02/21/Linux%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令简记"><a href="#Linux命令简记" class="headerlink" title="Linux命令简记"></a>Linux命令简记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于部分linux命令使用频率较低，导致遇到时常常忘记命令选项的含义和使用方法，因此在本文中记录linux命令的常用选项和具体使用方法，并对部分命令记录使用实例。</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>常用选项：</p><ul><li>-c: 建立压缩档案</li><li>-x：解压</li><li>-t：查看内容</li><li>-r：向压缩归档文件末尾追加文件</li><li>-u：更新原压缩包中的文件</li><li>-f: 使用档案名字，这个参数是最后一个参数，后面只能接档案名</li></ul><p>可选参数：</p><ul><li>-z：有gzip属性的</li><li>-j：有bz2属性的</li><li>-Z：有compress属性的</li><li>-v：显示所有过程</li><li>-O：将文件解开到标准输出</li></ul><h3 id="压缩、解压"><a href="#压缩、解压" class="headerlink" title="压缩、解压"></a>压缩、解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩 file.tar.gz：压缩档案名称；file：待压缩目录</span><br>tar -czvf file.tar.gz ./file<br><br><span class="hljs-comment"># 解压</span><br>tar -xzvf file.tar.gz<br></code></pre></td></tr></table></figure><h3 id="加密压缩、解压"><a href="#加密压缩、解压" class="headerlink" title="加密压缩、解压"></a>加密压缩、解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加密压缩</span><br><span class="hljs-comment"># 使用 --exclude 选项排除指定目录</span><br>tar -czvf - --exclue=<span class="hljs-string">&quot;file/exclude_dir&quot;</span> ./file | openssl enc -e -des3 -salt -k P@ssw0rd | <span class="hljs-built_in">dd</span> of=file.tar.gz.des3<br><br><span class="hljs-comment"># 解压</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=file.tar.gz.des3 | openssl enc -d -des3 -salt -k P@ssw0rd | tar -xzvf -<br></code></pre></td></tr></table></figure><h3 id="分卷加密压缩、解压"><a href="#分卷加密压缩、解压" class="headerlink" title="分卷加密压缩、解压"></a>分卷加密压缩、解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 分卷加密压缩</span><br><span class="hljs-comment"># split 参数</span><br><span class="hljs-comment"># -b, --bytes=SIZE, 指定每个分割文件的大小，单位有K, M, G, P等</span><br><span class="hljs-comment"># -d, --numeric-suffixes, 指定分割文件的后缀为数字</span><br><span class="hljs-comment"># -a, --suffix-length=N, 指定分割文件数字后缀的长度，如果-a 1，则后缀为*.1，*.2；如果-a 2，则后缀为*.01，*.02</span><br><span class="hljs-comment"># -c, --line-bytes=SIZE, 指定每行最大的字节数</span><br><span class="hljs-comment"># -l, --lines=NUMBER, 指定每个文件最大的行数</span><br>tar -czvf - --exclue=<span class="hljs-string">&quot;file/exclude_dir&quot;</span> ./file | openssl enc -e -des3 -salt -k P@ssw0rd | <span class="hljs-built_in">split</span> -b 200m -d -a 2 - file.tar.gz.des3.<br><br><span class="hljs-comment"># 解压</span><br><span class="hljs-built_in">cat</span> file.tar.gz.des3.* | openssl enc -d -des3 -salt -k P@ssw0rd | tar -zxvf -<br></code></pre></td></tr></table></figure><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><ol><li><p>–exclude参数报错</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar: The following options were used after any non-optional arguments <span class="hljs-keyword">in</span> archive create or update mode.  These options are positional and affect only arguments that follow them.  Please, rearrange them properly.<br></code></pre></td></tr></table></figure><p> 这是因为不同版本的tar，<code>--exclude</code>选项添加的位置存在差异。当tar的版本小于1.30时，该选项可以放在待压缩目录之后；若tar版本为1.30时，<code>--exclude</code>需要添加在待压缩目录之前。如下所示</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tar --version tar (GNU tar) 1.30</span><br>tar -czvf file.tar.gz --exclude=<span class="hljs-string">&quot;file/exclude_dir&quot;</span> ./file<br><br><span class="hljs-comment"># tar --version tar (GNU tar) 1.26</span><br>tar -czvf file.tar.gz ./file --exclude=<span class="hljs-string">&quot;file/exclude_dir&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>常用选项：</p><ul><li>-c 或 –count : 计算符合样式的列数。</li><li>-h –no-filename : 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。 </li><li>-H –with-filename : 在显示符合范本样式的那一列之前，标示该列的文件名称。</li><li>-i 或 –ignore-case : 忽略字符大小写的差别。</li><li>-E 或 –extended-regexp : 将样式为延伸的正则表达式来使用。</li><li>-o 或 –only-matching : 只显示匹配PATTERN 部分。</li><li>-v 或 –invert-match : 显示不包含匹配文本的所有行。</li><li>-V 或 –version : 显示版本信息。</li><li>–include : 搜索指定的文件</li><li>–exclude : 搜索结果中排除指定文件</li><li>–exclude-from &lt;fileList&gt;: 在搜索结果中排除fileList中的文件，一行一个“pattern”</li></ul><h3 id="多条件与（and），或（or）查询"><a href="#多条件与（and），或（or）查询" class="headerlink" title="多条件与（and），或（or）查询"></a>多条件与（and），或（or）查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 与（and）</span><br>grep <span class="hljs-string">&#x27;pattern1&#x27;</span> file | grep <span class="hljs-string">&#x27;pattern2&#x27;</span><br><br><span class="hljs-comment"># 或（or），用法1</span><br>grep -E <span class="hljs-string">&#x27;pattern1|pattern2&#x27;</span> file<br><span class="hljs-comment"># 或（or），用法2</span><br>grep <span class="hljs-string">&#x27;pattern1\|pattern2&#x27;</span> file<br><span class="hljs-comment"># 或（or），用法3</span><br>egrep <span class="hljs-string">&#x27;pattern1|pattern2&#x27;</span> file<br><br></code></pre></td></tr></table></figure><h3 id="输出不包含指定内容的行，（非（NOT）查询）"><a href="#输出不包含指定内容的行，（非（NOT）查询）" class="headerlink" title="输出不包含指定内容的行，（非（NOT）查询）"></a>输出不包含指定内容的行，（非（NOT）查询）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出不包含‘pattern’的行</span><br>grep -v <span class="hljs-string">&#x27;pattern&#x27;</span> file<br></code></pre></td></tr></table></figure><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><ol><li>根据可执行文件名称和运行参数，过滤输出进程id <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps ef | grep -i <span class="hljs-string">&#x27;$&#123;process_name&#125;&#x27;</span> | grep -i <span class="hljs-string">&#x27;$&#123;excute_param&#125;&#x27;</span> | grep -v <span class="hljs-string">&#x27;grep&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>dd 命令用于读取、转换并输出数据。可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p><p>格式：<br><code>dd [operand]</code><br><code>dd option</code></p><p>常用参数：</p><ul><li>bs&#x3D;BYTES：同时设置输入&#x2F;输出的块大小为BYTES字节</li><li>count&#x3D;N：仅拷贝N个block块，块大小等于ibs指定的字节数</li><li>cbs&#x3D;BYTES：一次转换BYTES个字节，即指定转换缓冲区大小</li><li>ibs&#x3D;BYTES：一次读取BYTES个字节，即指定读取的一个块大小为BYTES字节</li><li>obs&#x3D;BYTES：一次输出BYTES个字节，即指定输出的一个块大小为BYTES字节</li><li>if&#x3D;FILE：输入文件名，默认为标准输入</li><li>iflag&#x3D;FLAGS</li><li>of&#x3D;FILE：输出文件名，默认为标准输出</li><li>oflag&#x3D;FLAGS</li><li>skip&#x3D;N：从输入文件开头跳过N个block块后开始复制</li><li>seek&#x3D;N：从输出文件开头跳过N个block块后开始复制</li><li>status&#x3D;LEVEL：打印到stderr的信息级别<ul><li>‘node’：    抑制错误消息之外的所有内容、</li><li>‘noxfer’：  抑制最终的传输统计数据</li><li>‘progress’：显示定期传输统计信息</li></ul></li><li>conv&#x3D;&lt;CONVS KEY WORDS&gt;<ul><li>lcase：把大写字符转换为小写字符</li><li>ucase：把小写字符转换为大写字符</li><li>noerror：出错时不停止</li><li>notrunc：不截断输出文件</li></ul></li></ul><h3 id="与管道符（-）配合读取-x2F-输出文件"><a href="#与管道符（-）配合读取-x2F-输出文件" class="headerlink" title="与管道符（|）配合读取&#x2F;输出文件"></a>与管道符（|）配合读取&#x2F;输出文件</h3><ol><li><p>读取文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配合 grep 查找指定内容</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=./testfile status=none | grep <span class="hljs-string">&#x27;HelloWord&#x27;</span><br></code></pre></td></tr></table></figure><p> <img src="https://user-images.githubusercontent.com/35327600/212609068-f83073cf-06b9-4c73-ad8b-55af99d80d98.png"></p></li><li><p>输出文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将docker image信息写入指定文件</span><br>docker image <span class="hljs-built_in">ls</span> | <span class="hljs-built_in">dd</span> of=./docker_image_info.txt status=none<br></code></pre></td></tr></table></figure><p> <img src="https://user-images.githubusercontent.com/35327600/212609286-2525b883-4bfc-4ac9-a804-09f720f3828e.png"></p></li></ol><h3 id="备份磁盘并恢复"><a href="#备份磁盘并恢复" class="headerlink" title="备份磁盘并恢复"></a>备份磁盘并恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 备份</span><br><span class="hljs-comment"># SATA硬盘被挂载在/dev/sda，将该SATA硬盘备份到sda.img中</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/root/sda.img<br><br><span class="hljs-comment"># 恢复</span><br><span class="hljs-comment"># /dev/sda 硬盘出现故障时，将备份的sda.img恢复到指定的sdb盘中去</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/root/sda.img of=/dev/sdb<br><br><span class="hljs-comment"># 复制完整磁盘环境</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/dev/sdc<br></code></pre></td></tr></table></figure><h3 id="压缩备份"><a href="#压缩备份" class="headerlink" title="压缩备份"></a>压缩备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 备份</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda | gzip &gt; /root/sda.img.gz<br><br><span class="hljs-comment"># 恢复</span><br>gzip -dc /root/sda.img.gz | <span class="hljs-built_in">dd</span> of=/dev/sdc<br></code></pre></td></tr></table></figure><h3 id="备份磁盘MBR表"><a href="#备份磁盘MBR表" class="headerlink" title="备份磁盘MBR表"></a>备份磁盘MBR表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 一块磁盘的第一个扇区的 512 个字节所存储的正是这块磁盘的 MBR 信息，我们尝试用 dd 命令备份 MBR：</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/root/sda.mbr.img count=1 bs=512<br><br><span class="hljs-comment"># 恢复</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/root/sda.mbr.img of=/dev/sda<br></code></pre></td></tr></table></figure><h3 id="简单的磁盘读写性能测试"><a href="#简单的磁盘读写性能测试" class="headerlink" title="简单的磁盘读写性能测试"></a>简单的磁盘读写性能测试</h3><p>通过 <code>/dev/null</code> 和 <code>/dev/zero</code> 完成读写性能测试</p><ul><li><code>/dev/null</code>，也叫空设备，小名“无底洞”。任何写入它的数据都会被无情抛弃。</li><li><code>/dev/zero</code>，可以产生连续不断的 null 的流（二进制的零流），用于向设备或文件写入 null 数据，一般用它来对设备或文件进行初始化。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 向磁盘上写入一个大小为1Gb的大文件, 通过计算该命令执行时间，判断磁盘写性能</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file<br><br><span class="hljs-comment"># 读取一个刚才生成的1Gb的文件，通过计算命令执行时间，判断磁盘读取性能</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/root/1Gb.file bs=64k of=/dev/null<br></code></pre></td></tr></table></figure><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch 不仅可以创建文件，还可以对其进行时间的一些修改  <br>格式：touch 参数 文件名  <br>参数：  <br>-a: 修改访问时间，或 -–time=atime 或 -–time=access 或 -–time=use  <br>-c: 或 -–no-creat，如果文件不存在则不创建文件  <br>-d: 使用指定的日期时间，可以使用不同的格式  <br>-m: 或 -–time=mtime 或 -–time=modify，改变修改时间  <br>-r: 把指定的文件日期更设成和参考文档或目录日期相同的时间  <br>-t: 使用指定的日期时间，格式与 date 指令相同<br></code></pre></td></tr></table></figure><h2 id="mtime"><a href="#mtime" class="headerlink" title="-mtime"></a>-mtime</h2><p>查找指定时间修改的文件，单位天，但是按24小时更便于理解，在下面的示例中，将文件修改时间与当前时间的时间差记为 “T”</p><p>e.g.</p><ul><li>-mtime -1：T &lt; 24</li><li>-mtime 1： 24 &lt; T &lt; 48</li><li>-mtime +1：T &gt; 48</li><li>-mtime -2：T &lt; 48</li><li>-mtime 2： 48 &lt; T &lt; 72</li><li>-mtime +2：T &gt; 72</li></ul><p>总结一下：</p><ol><li>假设期望获取修改时间为 <strong>N 天之内</strong>（T &lt; <code>N * 24h</code>内修改过）的文件，则 -mtime -N</li><li>假设期望获取修改时间为<strong>距离当前时间的第 N 天</strong>（<code>N * 24h</code> &lt; T &lt;  <code>(N + 1) * 24h</code>  之间修改）的文件，则 -mtime N</li><li>假设期望获取修改时间为<strong>距离当前时间 N 天之前</strong>（T &gt; <code>N * 24h</code>之前修改）的文件，则 -mtime (N-1)</li></ol><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Watchdog for Emby Media Server</title>
    <link href="/2023/02/21/Watchdog-for-Emby-Media-Server/"/>
    <url>/2023/02/21/Watchdog-for-Emby-Media-Server/</url>
    
    <content type="html"><![CDATA[<h1 id="Watchdog-for-Emby-Media-Server"><a href="#Watchdog-for-Emby-Media-Server" class="headerlink" title="Watchdog for Emby Media Server"></a>Watchdog for Emby Media Server</h1><h2 id="修订版本"><a href="#修订版本" class="headerlink" title="修订版本"></a>修订版本</h2><p><mark><font color="red">v1.x版本后续将不再更新维护，如有需要请更新使用v2.x版本！！！</font></mark></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>借助python中的看门狗模块（“watchdog”）监视emby媒体库目录，通过电报（telegram）的bot和channel，向频道订阅者推送Emby媒体库中新增影片信息，包括电影和剧集。</p><h2 id="实现说明"><a href="#实现说明" class="headerlink" title="实现说明"></a>实现说明</h2><p>v2.x版本中，删除了原始版本中的xmllint依赖，仅通过python完成所有功能实现。**因此在dockerfile中将基础镜像由<code>ubuntu:latest</code>变更为<code>python:alpine3.17</code>，拉取后镜像体积由231MB减小至69.5MB，体积减少约70%**。</p><p><strong>watchdog_for_Emby</strong> 对 Emby Server 自动影片刮削生成的“xxxx.nfo”文件进行监控。影片新入库后，Emby Server 自动执行刮削生成xml格式的nfo文件，<del>通过xmllint可以解析到部分该影片或者剧集的信息</del>通过“ElementTree”模块解析nfo文件，获取当前影片的基本信息。而影片的封面图，和剧集的详细信息，则需要通过TMDB的api进行查询获取，通过调用”requests.get()”方法完成查询。在按照电报bot的api文档对payload数据组装后，调用”requests.post()”方法推送给bot，由bot发布至对应频道。</p><h2 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h2><ol><li>python3.10及以上版本（v2.x版本中，使用了match..case..语法，仅在3.10及以上版本完成支持）</li><li>python Module: <em>watchdog</em>, <em>requests</em> (cmd: <code>pip3 install watchdog requests</code>)，<em>ElementTree</em></li><li><del>xmllint (os: ubuntu 20.04，cmd: <code>sudo apt-get install libxml2-utils</code>)</del> v2.x版本中已去除此依赖</li></ol><h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>BOT_TOKEN</td><td>电报 bot token</td></tr><tr><td>CHAT_ID</td><td>电报频道 chat_id</td></tr><tr><td>TMDB_API</td><td>TMDB api token</td></tr><tr><td>MEDIA_PATH</td><td>Emby 媒体库路径</td></tr><tr><td>LOG_PATH</td><td>&lt;可选&gt;日志文件路径，默认为<code>/var/tmp/overwatch.log</code></td></tr></tbody></table><h2 id="Docker-Run"><a href="#Docker-Run" class="headerlink" title="Docker Run"></a>Docker Run</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=watchdog-emby --restart=unless-stopped \<br>  -v &quot;your media lib&#x27;s host path&quot;:&quot;media lib&#x27;s container path&quot; \<br>  -e BOT_TOKEN=&quot;your telegram bot&#x27;s token&quot; \<br>  -e CHAT_ID=&quot;your telegram channle&#x27;s chat_id&quot; \<br>  -e TMDB_API=&quot;tmdb api token&quot; \<br>  -e MEDIA_PATH=&quot;media lib&#x27;s container path&quot; \<br>  -e LOG_PATH=&quot;log&#x27;s output path&quot; \<br>  b1gfac3c4t/overwatch<br>  <br></code></pre></td></tr></table></figure><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>电影：</p><p><img src="https://user-images.githubusercontent.com/35327600/209752390-4e45180b-d8cc-4378-bd98-c489638f7cb7.png"></p><p>剧集：</p><p><img src="https://user-images.githubusercontent.com/35327600/209752275-bad230b0-97a7-47e5-9a77-081afae7d6cf.png"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li>tmdb api 文档：<a href="https://developers.themoviedb.org/3">https://developers.themoviedb.org/3</a></li><li>telegram bot api 文档：<a href="https://core.telegram.org/bots/api">https://core.telegram.org/bots/api</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Emby</tag>
      
      <tag>Python3.10</tag>
      
      <tag>Watchdog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unraid USB Drive Crack 教程</title>
    <link href="/2023/02/21/Unraid-USB-Drive-Crack-%E6%95%99%E7%A8%8B/"/>
    <url>/2023/02/21/Unraid-USB-Drive-Crack-%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Unraid-USB-Drive-Crack-教程"><a href="#Unraid-USB-Drive-Crack-教程" class="headerlink" title="Unraid USB Drive Crack 教程"></a>Unraid USB Drive Crack 教程</h1><p><strong><font color="red">！！！破解教程仅供学习参考，务必支持正版软件，构建良好的软件版权生态！！！</font></strong></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>由于Unraid OS使用硬盘阵列的形式构建存储池，能尽可能利用硬盘空间，并且可以通过创建校验盘保护数据，因此Unraid OS也不失为一个NAS系统的好选择。</p><p>但是因为试用版需要在联网环境下完成授权，导致处于内网环境的NAS机器无法使用。网上虽然有大量的开心版，不过大多是通过第三方提供的一个keyMaker.exe对USB的GUID生成一个key文件进行破解，总感觉不是很安全。</p><p>在爬了无数帖子后，终于在老毛子的一个论坛中找到了每个人都能轻松”<strong>转正</strong>“，且安全的方法！论坛连接放在文末，近期论坛中已经释出6.11版本。</p><h2 id="二、准备工具"><a href="#二、准备工具" class="headerlink" title="二、准备工具"></a>二、准备工具</h2><ol><li>一个U盘</li><li>官方usb引导创建工具：<strong>Unraid.USB.Creator.Win32-2.1.exe</strong>（官网下载即可）</li><li>一个可以使用gcc的编译环境（Debian、Ubuntu、Centos等，虚拟机，云主机都可以）（windos下其实也可以，但是环境配置相对麻烦，不如直接使用虚拟机创建前面提到的三个linux系统）</li><li>一份源码构建密钥的源码：<code>https://github.com/mysll/unraid_test.git</code></li></ol><h2 id="三、Crack-系统盘破解"><a href="#三、Crack-系统盘破解" class="headerlink" title="三、Crack 系统盘破解"></a>三、Crack 系统盘破解</h2><h3 id="3-1、制作系统盘"><a href="#3-1、制作系统盘" class="headerlink" title="3.1、制作系统盘"></a>3.1、制作系统盘</h3><p>通过在官网下载的USB引导创建工具，制作官方系统盘即可，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/209258446-6d68256c-f8bf-4275-a102-13b0c288f0d3.png"></p><p>制作过程不在这里进行赘述了，B站大佬<a href="https://space.bilibili.com/28457/channel/seriesdetail?sid=896368">司波图</a>的Unraid系列教程中介绍的很详细了，不了解的朋友可以移步观看。</p><p>这里有几个需要注意的点：</p><ol><li><p>由于服务器在国外，直接在线下载可能会很慢，或者没有速度，也可以单独下载官网中的zip包，然后在图中第一步中选择”Local Zip”；</p></li><li><p>图中第二步”Select your USB Flash device”，注意是否是待制作的U盘，确认后将USB名称后面中括号内的一串数字记录下，如图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/209281193-0a968f78-8add-4d06-97cb-c80b44517b2a.png"></p><p>这是U盘的<strong>GUID</strong>，在后续破解中还需使用到。（如果忘记保存了，也没关系，重新打开这个制作工具就能再次看到了)</p></li><li><p>点击“<strong>Write</strong>”后会提示当前选中U盘会被格式化，如果没选错的话，OK就行；</p></li></ol><p>等待进度条满后，系统盘就制作完成了。<font color="blue">如果在制作系统盘时，选择了”Local Zip”，那么接下来还需要注意以下一点</font>:</p><blockquote><p>打开U盘目录，找到根目录下“make_bootable.bat”文件，右键点击后，选择管理员模式运行</p></blockquote><p>完成以上步骤后，暂时先不要拔下U盘，后续还需要对内部的文件进行操作。</p><h3 id="3-2、制作密钥"><a href="#3-2、制作密钥" class="headerlink" title="3.2、制作密钥"></a>3.2、制作密钥</h3><p>制作密钥过程需要在linux环境中进行（如果你的windows系统也部署了gcc，那也可以在windows下操作）。利用windows自带的“Hyper-V”虚拟机搭建一个Ubuntu非常的简单方便，不会的朋友可自行百度教程。下面我以Ubuntu为例介绍密钥的制作过程。</p><ol><li><p>首先将准备工具中第4点提到的源码下载下来，依次执行以下两条命令：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/mysll/unraid_test.git ./Unraid_test<br>cd Unraid_test<br></code></pre></td></tr></table></figure><p> <img src="https://user-images.githubusercontent.com/35327600/209284969-1ccd4d06-b0ad-4129-a746-3e7d487923ae.png"><br> 当然也可以不用以上命令，直接点击源码链接，去github网站上进行下载。（此处也有可能有网络问题，存在网络问题是，请百度关键词“github 下载失败”）</p></li><li><p>进入源码目录后，执行命令 <code>gcc -fPIC -shared unraid.c -o BTRS.key</code>，会一点C语言或者C++在linux环境编译的话，就能明白这一步在做什么，不明白也没关系，无脑执行即可。<br><font color="red">此时会在当前目录下生成一个名为“<strong>BTRS.key</strong>”的文件，你猜的没错，这就是我们所需要的密钥文件</font></p></li><li><p>将第二步中生成的“<strong>BTRS.key</strong>”拷贝到U盘的“<strong>config</strong>”目录下</p><p> <img src="https://user-images.githubusercontent.com/35327600/209305975-9f6ec553-e639-4fd3-8170-6584aa525047.png"></p></li><li><p>在config目录下找到一个名为“<strong>go</strong>”的文件，先将该文件备份一下，然后用以下内容替换原文件的内容</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">---------修改以下三项内容，只需要修改等号右边内容，左边不要变更--------- <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">GUID 将单引号内的内容替换成你自己U盘对应GUID</span><br>export UNRAID_GUID=&#x27;xxxx-xxxx-xxxx-xxxxxxxxxxxx&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME 随便填</span><br>export UNRAID_NAME=unraid_test<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是unix的一个时间戳，百度关键词“unix时间戳”，找一个转换网站，将当前时间转换为时间戳后填入，下面有示例</span><br>export UNRAID_DATE=1658129986<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-----------不要修改！！！不要修改！！！不要修改！！！------------------ <span class="hljs-comment">#</span></span><br>export UNRAID_VERSION=Pro<br>LD_PRELOAD=/boot/config/BTRS.key /usr/local/sbin/emhttp &amp;<br></code></pre></td></tr></table></figure></li></ol><p>  时间戳转换示例，<a href="https://tool.lu/timestamp/">在线转换工具</a>：</p><p>  <img src="https://user-images.githubusercontent.com/35327600/209291869-4c00d313-2e98-414c-b755-e2f48ab44e50.png"></p><p>此时可以拔下U盘，然后插到你的NAS上，愉快的使用啦~~~</p><p>当然了，还是希望有能力的朋友支持正版，毕竟这种开心版是否在后续使用中还是有所缺陷，例如强大的my_server就无法使用。更何况软件版权生态也是需要大家共同维护的。</p><h2 id="四、Backup-系统盘备份"><a href="#四、Backup-系统盘备份" class="headerlink" title="四、Backup 系统盘备份"></a>四、Backup 系统盘备份</h2><p>由于Unraid的系统文件完全被存储在U盘中，并且十分的轻量，因此备份变得非常方便。</p><p>在APP市场中下载“<strong>User Scripts</strong>”插件，通过定时执行备份脚本，实现定期备份系统盘的功能。</p><p><img src="https://user-images.githubusercontent.com/35327600/209297717-10fcb3ff-b65c-48fe-a796-a7a419912c20.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/209298058-adb48d23-c188-4000-b24a-0619df42ebb2.png"></p><p>创建完成后点击脚本前的小齿轮，选择”<strong>EDIT SCRIPT</strong>“，将下方内容贴入，然后点击”<strong>SAVE CHANGES</strong>即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>CUR_TIME=$(date &quot;+%Y%m%d%H%M%S&quot;)<br>BACKUP_FILE=&quot;unraid_flash_backup_$&#123;CUR_TIME&#125;.tar.gz&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将等号后面的路径修改为你自己的备份路径</span><br>BACKUP_PATH=&quot;/your/back/up/path/&quot;<br><br>tar -czvf $&#123;BACKUP_PATH&#125;$&#123;BACKUP_FILE&#125; /boot;<br></code></pre></td></tr></table></figure><p>保存后可以点击 “RUN SCRIPT” 测试一下备份文件是否成功创建。注意不可关闭运行后的弹窗，否则脚本会中止执行。</p><blockquote><p>这里还有更进阶的玩法，可以结合阿里云的webdav和rclone挂载，将备份包上传至网盘中，并删除过期备份包，避免占用过多网盘空间，这个有需要的话，可以后面再出一篇详细教程。</p></blockquote><h2 id="五、Rescure-系统盘恢复"><a href="#五、Rescure-系统盘恢复" class="headerlink" title="五、Rescure 系统盘恢复"></a>五、Rescure 系统盘恢复</h2><p>由于Unraid OS的完整系统都存在U盘中，因此当系统配置出现问题，导致无法进入引导，无法进入GUI界面时，并不会影响阵列！</p><p>因此系统盘的恢复，比备份更简单。只需要使用官方的USB制作工具创建一个官方的系统盘，然后将备份包中的config目录完全拷贝至当前的U盘内即可！是不是超级，非常，极其简单和方便！！！</p><p><mark>当然还有一个注意点，如果U盘更换了，config目录中的”<strong>go</strong>“文件中的GUID也需要同步修改一下。千万别忘记啦！</mark></p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oh-my-posh安装教程</title>
    <link href="/2023/02/21/oh-my-posh%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2023/02/21/oh-my-posh%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="oh-my-posh安装教程"><a href="#oh-my-posh安装教程" class="headerlink" title="oh-my-posh安装教程"></a>oh-my-posh安装教程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>github: <a href="https://github.com/JanDeDobbeleer/oh-my-posh">https://github.com/JanDeDobbeleer/oh-my-posh</a></li><li>docs:   <a href="https://ohmyposh.dev/">https://ohmyposh.dev/</a></li></ul><p>docs中有详细的安装和使用说明，下文中有不明白的可以移步官方文档自行学习使用~</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下面以新安装的x86_64的debian环境进行举例</p><p><code>Linux debian 5.10.0-19-amd64 #1 SMP Debian 5.10.149-2 (2022-10-21) x86_64 GNU/Linux</code></p><p>针对内网和非root用户进行安装，避免污染其他用户的使用环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 获取posh可执行文件，内网环境可以直接从github中下载后，拷贝到用户下指定目录</span><br><span class="hljs-comment"># 当前命令中下载的可执行文件是基于amd64架构的，根据自己的系统架构选择下载</span><br><span class="hljs-built_in">mkdir</span> -p ~/oh-my-posh<br>wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-amd64 -O ~/oh-my-posh/posh;<br><span class="hljs-built_in">wait</span>;<br><span class="hljs-built_in">chmod</span> +x ~/oh-my-posh/posh;<br><br><span class="hljs-comment"># 下载主题</span><br><span class="hljs-built_in">mkdir</span> -p ~/oh-my-posh/.poshthemes;<br>wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/oh-my-posh/.poshthemes/themes.zip;<br><span class="hljs-built_in">wait</span>;<br>unzip -q ~/oh-my-posh/.poshthemes/themes.zip -d ~/oh-my-posh/.poshthemes;<br><span class="hljs-built_in">wait</span>;<br><span class="hljs-built_in">rm</span> ~/oh-my-posh/.poshthemes/themes.zip -vf;<br><span class="hljs-built_in">chmod</span> u+rw ~/oh-my-posh/.poshthemes/*.omp.*;<br><br><span class="hljs-comment"># 向~/.profile，或者~/.bashrc，或者~/.bash_profile中写入posh初始化命令，下面命令中以~/.profile为例，并指定主题 montys.omp.json</span><br>sed -i <span class="hljs-string">&#x27;$a eval &quot;$(~/oh-my-posh/posh init bash --config ~/oh-my-posh/.poshthemes/montys.omp.json)&quot;&#x27;</span> ~/.profile;<br><br><span class="hljs-comment"># 重新启用bash</span><br><span class="hljs-built_in">source</span> ~/.profile;<br><br><span class="hljs-comment"># 若安装了zsh，则最后两行命令用下面两行替代</span><br><span class="hljs-comment"># 向~/.zshrc中写入posh初始化命令，并指定主题 montys.omp.json</span><br><span class="hljs-comment">#sed -i &#x27;$a eval &quot;$(~/oh-my-posh/posh init zsh --config ~/oh-my-posh/.poshthemes/montys.omp.json)&quot;&#x27; ~/.zshrc;</span><br><span class="hljs-comment"># 应用新的.zshrc文件</span><br><span class="hljs-comment">#exec zsh;</span><br><br></code></pre></td></tr></table></figure><h2 id="示例动画"><a href="#示例动画" class="headerlink" title="示例动画"></a>示例动画</h2><p><img src="https://user-images.githubusercontent.com/35327600/211761346-9d91a9ad-bc18-4128-8cf4-49a91ebfcb0e.gif"></p><h2 id="montys-omp-json主题微调"><a href="#montys-omp-json主题微调" class="headerlink" title="montys.omp.json主题微调"></a>montys.omp.json主题微调</h2><p>由于montys主题默认会在powerline中输出完整的路径，当路径层级较深时，powerline显示就太长了，因此参考文档进行了微调。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/themes/montys.omp.json b/themes/montys.omp.json</span><br><span class="hljs-comment">index c7797e88..c8eeb6c4 100644</span><br><span class="hljs-comment">--- a/themes/montys.omp.json</span><br><span class="hljs-comment">+++ b/themes/montys.omp.json</span><br><span class="hljs-meta">@@ -17,10 +17,11 @@</span><br>           &quot;foreground&quot;: &quot;#ffffff&quot;,<br>           &quot;powerline_symbol&quot;: &quot;\ue0b0&quot;,<br>           &quot;properties&quot;: &#123;<br><span class="hljs-deletion">-            &quot;folder_icon&quot;: &quot;\uf115&quot;,</span><br><span class="hljs-addition">+            &quot;folder_icon&quot;: &quot;\uf07c&quot;,</span><br>             &quot;folder_separator_icon&quot;: &quot;\\&quot;,<br>             &quot;home_icon&quot;: &quot;\uf7db&quot;,<br><span class="hljs-deletion">-            &quot;style&quot;: &quot;full&quot;</span><br><span class="hljs-addition">+            &quot;style&quot;: &quot;agnoster_short&quot;,</span><br><span class="hljs-addition">+            &quot;max_depth&quot;: 3</span><br>           &#125;,<br>           &quot;style&quot;: &quot;powerline&quot;,<br>           &quot;template&quot;: &quot; &lt;#000&gt;\uf07b \uf553&lt;/&gt; &#123;&#123; .Path &#125;&#125; &quot;,<br></code></pre></td></tr></table></figure><p>效果对比：</p><p>before：</p><p><img src="https://user-images.githubusercontent.com/35327600/211757664-172072e7-7c19-49e0-b900-7c6975471931.png"></p><p>after:</p><p><img src="https://user-images.githubusercontent.com/35327600/211762075-d3a46f69-5bf8-4dfe-a15a-e39ff4ca9198.png"></p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Shell</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>Debain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows10挂载Webdav</title>
    <link href="/2023/02/21/Windows10%E6%8C%82%E8%BD%BDWebdav/"/>
    <url>/2023/02/21/Windows10%E6%8C%82%E8%BD%BDWebdav/</url>
    
    <content type="html"><![CDATA[<h1 id="windows10挂载webdav"><a href="#windows10挂载webdav" class="headerlink" title="windows10挂载webdav"></a>windows10挂载webdav</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>当前市面上大部分的网盘，可以挂载到 “<strong>Alist</strong>“ 中。Alist 又支持 webdav协议。这就意味着通过 Alist 的 webdav 服务，我们可以直接将网盘挂载到本地，类似于本地磁盘一样读写网盘中文件。</p><p>但是在本地挂载的过程中，无论是添加网络位置，还是映射网络驱动器，都会出现文件路径不对、网络错误无法访问等错误，如下所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/215680157-9de51400-15cc-4d22-9d01-5e6bf8411e8f.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/215675986-ba71818f-88cb-4151-86b9-aae6ee69aa22.png"></p><p>本文将简单介绍如何在Windows环境下挂载本地webdav。</p><h2 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h2><p>导致简介中的问题其实非常简单。<mark>windows 默认的 WebClient 服务仅支持 https 协议</mark>，而本地搭建的 webdav 服务和链接都是基于 http 协议的，因此才造成了挂载失败的情况。</p><p>对于部分高手来说，将 webdav 服务转换为 https 协议必然是更安全，更好的选择。但是对于部分仅内网挂载访问，安全性需求较低的朋友来说，升级 https 的代价可能有些高昂，因此使 windows 自带的 WebClient 支持 http，可能是更快捷方便的选择。</p><h3 id="三、设置-WebClient，允许-http-链接挂载"><a href="#三、设置-WebClient，允许-http-链接挂载" class="headerlink" title="三、设置 WebClient，允许 http 链接挂载"></a>三、设置 WebClient，允许 http 链接挂载</h3><p>步骤1：<br>按下 “<strong>windows徽标键</strong>“ + “<strong>R</strong>“，打开运行窗口，输入<code>regedit</code>，点击确定后，打开注册表编辑器窗口。</p><p>步骤2：<br>将路径定位到以下路径：<code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters</code>。双击右侧界面中的 <code>BasicAuthLevel</code> 条目，将数值数据修改为“2”，点击确定后关闭注册表编辑器。</p><p><img src="https://user-images.githubusercontent.com/35327600/215690501-29b6636a-a17b-4fcd-a871-f3ddf031dfef.png"></p><p>步骤3：<br>按下 “<strong>windows徽标键</strong>“ + “<strong>R</strong>“，打开运行窗口，输入<code>services.msc</code>，点击确定后，打开“服务”界面。找到 “<strong>WebClient</strong>“<br>服务，右键点击打开选项菜单，选择重新启动，稍等几秒，待完成后，关闭“服务”界面。</p><p><img src="https://user-images.githubusercontent.com/35327600/215691793-fc3e4385-f6e4-47ed-bd8e-7a00d3a7cf4f.png"></p><p>完成上述三个步骤后，WebClient 服务已经允许使用 http 协议进行挂载。</p><h2 id="四、挂载测试"><a href="#四、挂载测试" class="headerlink" title="四、挂载测试"></a>四、挂载测试</h2><ol><li><p>映射网络驱动器<br> <img src="https://user-images.githubusercontent.com/35327600/215694498-777dba03-505a-4922-9485-ba99c0eb5809.png"><br> <img src="https://user-images.githubusercontent.com/35327600/215694514-24f0ddf9-f2b2-4059-8e7a-107b216565d9.png"></p></li><li><p>添加网络位置<br> <img src="https://user-images.githubusercontent.com/35327600/215695212-f220eeb9-23f0-4500-987d-dea5146898a4.png"><br> <img src="https://user-images.githubusercontent.com/35327600/215695227-595b63d6-c31e-4d06-83da-98179b01fdb1.png"></p></li></ol><p>可以看到，在修改注册表后，映射网络驱动器和添加网络位置，都能正确访问 webdav 服务了。</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Windows10</tag>
      
      <tag>Webdav</tag>
      
      <tag>注册表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/2023/02/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/02/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><blockquote><p>在C++11和更高版本中，Lambda表达式（通常称为Lambda）是一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。Lambda通常用于封装传递给算法或异步函数的少量代码行。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++ 中的 Lambda 表达式（https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170）](https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170)">[1]</span></a></sup></p></blockquote><p>Lambda表达式是C++11中一个较为重要的特性，其来源于函数式编程的概念，也是现代编程语言的一个特点。</p><p>Lambda表达式有以下优点：</p><ul><li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。以更直接的方式撰写程序代码，具有较高的可读性和可维护性。</li><li>简介：不需要额外写一个函数或函数对象，避免代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也具备更高的生产效率。</li><li>在需要的时间和地点实现功能闭包，使程序更灵活。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++11 lambda表达式精讲（http://c.biancheng.net/view/3741.html）](http://c.biancheng.net/view/3741.html)">[2]</span></a></sup></li></ul><p>下文将记录和简述Lambda表达式中的基本概念和用法。</p><h2 id="一、Lambda表达式组成"><a href="#一、Lambda表达式组成" class="headerlink" title="一、Lambda表达式组成"></a>一、Lambda表达式组成</h2><p>ISO C++ 标准展示了作为第三个参数传递给 <code>std::sort()</code> 函数的简单 lambda：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abssort</span><span class="hljs-params">(<span class="hljs-type">float</span>* x, <span class="hljs-type">unsigned</span> n)</span> </span>&#123;<br>std::<span class="hljs-built_in">sort</span>(x, x+n, <br><span class="hljs-comment">// Lambda expression begins</span><br>[](<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b) &#123;<br><span class="hljs-built_in">return</span> (std::<span class="hljs-built_in">abs</span>(a) &lt; std::<span class="hljs-built_in">abs</span>(b));<br>&#125; <span class="hljs-comment">// end of lambda expression</span><br>);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的简单Lambda示例，可以将其按照下图进行概括：</p><p><img src="https://learn.microsoft.com/zh-cn/cpp/cpp/media/lambdaexpsyntax.png?view=msvc-170" alt="Lambda组成"></p><p>其中各个组成部分分别表示为：</p><ol><li>capture子句（C++规范中也称为Lambda引导）</li><li>参数列表（可选）。（也称为Lambda声明符）</li><li>mutable规范（可选）。</li><li>exception-specification（可选）。</li><li>trailing-return-type（可选）。</li><li>Lambda体，即函数体。</li></ol><h2 id="二、capture子句"><a href="#二、capture子句" class="headerlink" title="二、capture子句"></a>二、capture子句</h2><p>Lambda 以 capture 子句开头，它用于指示 Lambda 捕获周边范围中的哪些变量，以及捕获变量的方式（按值捕获、按引用捕获’&amp;’），当然也可以使用空的 capture 子句<code>[ ]</code>表示不捕获任何变量。</p><p>除了在 capture 子句中直接指定待捕获的外部变量，也可以使用默认捕获模式来指示如何捕获Lambda体中引用的任何外部变量：</p><ol><li><p><code>[&amp;]</code>：表示通过“<strong>引用捕获</strong>”引用所有的变量</p></li><li><p><code>[=]</code>：表示通过“<strong>值捕获</strong>”获取外部变量的值</p></li></ol><p><font color=red>当使用默认捕获模式时，仍然可以为特定变量显式地指定相反的模式</font>。例如，Lambda 体通过引用访问外部变量 <code>a</code> ，并通过值访问外部变量 <code>b</code> ，则可以参考以下 capture 子句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[&amp;a, b] <span class="hljs-comment">// 分别指定引用访问a，值访问b</span><br>[b, &amp;a] <span class="hljs-comment">// 单独指定时，不区分先后顺序</span><br>[=, &amp;a] <span class="hljs-comment">// 默认使用值捕获，但是变量a使用引用捕获</span><br>[&amp;,  b] <span class="hljs-comment">// 默认使用引用捕获，但是表量b使用值捕获</span><br><span class="hljs-comment">// 使用默认捕获时，只有 Lambda 体中提及的变量才会被捕获。</span><br></code></pre></td></tr></table></figure><p><mark>在类成员函数中使用 Lambda，如果 Lambda 需要访问类的成员函数和数据成员，则需要将this指针传递给 capture 子句。在C++17及以上版本中，可以通过在 capture 子句中指定<code>*this</code>通过值捕获<code>this</code>指针</mark>。</p><p>在使用 capture 子句时，有以下几点建议：</p><ul><li><font color=red>Lambda 能捕获当前作用域内的<code>non-static</code>类型变量，对于全局变量，局部静态变量，则可以在 Lambda 体中直接引用</font>，但是此处容易存在依赖问题，在下文章节 [“Effective Modern C++ 中的 Lambda 表达式”](#八、Effective Modern C++ 中的 Lambda 表达式) 中进行介绍。</li><li>引用捕获可用于修改外部变量，而值捕获却不能实现此操作。（<font color=red><code>mutable</code>声明允许修改Lambda中的副本，但不会修改原始项</font>）</li><li>引用捕获会反映外部变量的更新，而值捕获不会。</li><li>避免使用默认捕获模式。（同第一条，将在 [“Effective Modern C++ 中的 Lambda 表达式”](#八、Effective Modern C++ 中的 Lambda 表达式) 章节中详细描述）</li></ul><h2 id="三、通用捕获-x2F-初始化捕获（init-capture）（C-14）"><a href="#三、通用捕获-x2F-初始化捕获（init-capture）（C-14）" class="headerlink" title="三、通用捕获&#x2F;初始化捕获（init capture）（C++14）"></a>三、通用捕获&#x2F;初始化捕获（<em>init capture</em>）（C++14）</h2><p>在某些场景下，如果有一个只能被移动的对象（例如<code>std::unique_ptr</code>或<code>std::future</code>）要进入闭包中，使用C++11是无法实现的。又或者要复制的对象复制开销非常高，但移动成本却相对比较低（例如stl标准库中的大多数容器），并且开发者期望的是宁愿移动该对象到闭包而不是复制时，C++11也无法实现该目标。</p><p>在C++14标准中，增加了通用捕获，又或者叫初始化捕获，移动捕获是它可以执行的技术之一。</p><p>使用初始化捕获时，开发者可以指定：</p><ol><li>从 lambda 生成的闭包类中的数据成员名称；</li><li>初始化该成员的表达式</li></ol><p>见以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pNums = make_unique&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(nums);<br><br><span class="hljs-keyword">auto</span> a = [ptr = <span class="hljs-built_in">move</span>(pNums)]() &#123;<br><span class="hljs-comment">// use ptr</span><br>  &#125;;<br></code></pre></td></tr></table></figure><h2 id="四、参数列表"><a href="#四、参数列表" class="headerlink" title="四、参数列表"></a>四、参数列表</h2><p>参数列表（在标准语法中称为 Lambda 声明符）是可选的。在大多数时候，它类似于参数的参数列表。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>在C++14中，可以使用<code>auto</code>关键字作为类型说明符，表示泛型参数类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>在C++14中，Lambda 也接受可变形参</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> &amp;&amp;...params) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(params)&gt;(params)...));<br>  &#125;;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>由于参数列表是可选的，因此在不将自变量传递到 Lambda 表达式，并且其 Lambda 声明符不包含 exception-specification、trailing-return-type 或 <strong><code>mutable</code></strong> 的情况下，可以省略空括号。</p></blockquote><h2 id="五、mutable-规范"><a href="#五、mutable-规范" class="headerlink" title="五、mutable 规范"></a>五、mutable 规范</h2><p><mark>通常，Lambda 的函数调用运算符是<code>const-by-value</code>，但是对<code>mutable</code>关键字的使用可以取消。利用<code>mutable</code>规范，Lambda 表达式的主题可以修改通过值捕获的变量。</mark></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *b = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">auto</span> f4 = [b]() <span class="hljs-keyword">mutable</span> &#123;<br>  b = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>  *b = <span class="hljs-number">10</span>;<br>  cout &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;--&quot;</span> &lt;&lt; *b &lt;&lt; endl;<br>  <span class="hljs-keyword">delete</span> b;<br>&#125;;<br><span class="hljs-built_in">f4</span>();<br></code></pre></td></tr></table></figure><h2 id="六、异常规范"><a href="#六、异常规范" class="headerlink" title="六、异常规范"></a>六、异常规范</h2><p>你可以使用 noexcept 异常规范来指示 Lambda 表达式不会引发任何异常。 与普通函数一样，如果 Lambda 表达式声明 noexcept 异常规范且 Lambda 体引发异常，Microsoft C++ 编译器将生成警告。</p><h2 id="七、返回类型"><a href="#七、返回类型" class="headerlink" title="七、返回类型"></a>七、返回类型</h2><p>编译器能够自动推导 Lambda 表达值返回值类型，缺省状态下即表示为自动推导。当然也可以手动指定 trailing-return-type。trailing-return-type 类似普通函数的return-type，但是返回类型必须更在参数列表后面，并且必须在返回类型前包含关键字 <code>-&gt;</code>。</p><p>Lambda 表达式可以生成另一个 lambda 表达式作为其返回值。</p><h2 id="八、Effective-Modern-C-中的-Lambda-表达式"><a href="#八、Effective-Modern-C-中的-Lambda-表达式" class="headerlink" title="八、Effective Modern C++ 中的 Lambda 表达式"></a>八、Effective Modern C++ 中的 Lambda 表达式</h2><p>在《Effective Modern C++》中也对 lambda 表达式给出了相关的建议，一共包含了四项条款，将在下文进行介绍和记录。</p><h3 id="条款31：避免使用默认捕获模式"><a href="#条款31：避免使用默认捕获模式" class="headerlink" title="条款31：避免使用默认捕获模式"></a>条款31：避免使用默认捕获模式</h3><p>Item 31: Avoid default capture modes</p><p>就个人理解而言，该条款主要还是针对使用默认的按引用捕获时，由于引用存在依赖生命周期的问题，因此极易导致悬空引用的问题。而默认的按值捕获，按照作者的描述，则可能诱骗开发者以为能解决悬空引用的问题（实际上并没有解决），还会让开发者误以为自己所构建的闭包是独立的（事实上也并不是独立的）。</p><p>对于默认按引用捕获导致悬空引用的问题，我们先来举一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> Fn = function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><br><span class="hljs-function">Fn <span class="hljs-title">capture_by_ref</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Fn <span class="hljs-title">capture_by_val</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">capture_by_ref</span>();<br>  <span class="hljs-built_in">f</span>();<br>  f = <span class="hljs-built_in">capture_by_val</span>();<br>  <span class="hljs-built_in">f</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Fn <span class="hljs-title">capture_by_val</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [=]()&#123;cout &lt;&lt; <span class="hljs-string">&quot;capture_by_val: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;;<br>&#125;<br><br><span class="hljs-function">Fn <span class="hljs-title">capture_by_ref</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [&amp;]()&#123;cout &lt;&lt; <span class="hljs-string">&quot;capture_by_ref: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在<code>Ubuntu 20.04</code>下编译运行，结果如下图所示：<br><img src="https://user-images.githubusercontent.com/35327600/215710670-8e68c21d-58ba-450f-8342-f49a40bc2589.png"><br>可以清晰的看到，按值捕获的 a 可以正常输出打印。但是在按引用捕获的情形下，a已经成为一个悬空的引用了，在 cout 时，出现了未定义的行为。每次执行输出的 a 的值都是一个随机值。</p><p>为什么会出现这个问题呢？根本原因就在于按引用捕获！</p><p>在<code>Fn capture_by_ref();</code>函数中，<font color=red>Lambda 捕获了一个临时变量的引用，但是在函数 return 之后，临时变量 a 将被系统自动释放出栈，此时 a 的生命周期已经结束</font>。而 Lambda 中却仍然保存着该临时变量的引用，“这里我们可以暂时将其理解为闭包类中保存的是原临时变量 a 的地址，在函数<code>capture_by_ref</code> return 之后，该地址被释放，里面的内容自然变成了未定义的内容”，所以每次调用时程序所打印的内容都是未知的值。</p><p>这个例子很好的说明了按引用捕获存在着较高的引用悬空的风险，默认的引用捕获则更是加大了这种风险，因此尽量还是避免使用默认的按引用捕获。</p><p><code>Fn capture_by_val();</code>采用了按值捕获的方式，正确打印了被捕获的变量 a 的值，这也确实是解决被引用捕获的变量的生命周期短于 Lambda 导致引用悬空问题的一个正确方法。但是这并不代表着按值捕获不存在问题。按值捕获同样存在着依赖生命周期的问题。</p><p>再来看一个简单的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>  *a = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// Lambda 按值捕获指针变量 a，在闭包类中保存 a 的副本</span><br>  <span class="hljs-keyword">auto</span> f = [=]() &#123; cout &lt;&lt; *a &lt;&lt; endl; &#125;;<br>  <span class="hljs-comment">// 在外部调用 delete 释放指针变量 a</span><br>  <span class="hljs-keyword">delete</span> a;<br>  <span class="hljs-comment">// 调用 Lambda，运行时会提示 heap-used-after-free</span><br>  <span class="hljs-built_in">f</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// avoid_default_capture.cc</span><br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://user-images.githubusercontent.com/35327600/215921879-efb4fc60-68db-4e35-a1a8-53c75da3bc1b.png"></p><p>结果是显而易见的，尽管我们在 Lambda 中使用了按值捕获以获得指针变量 a 的副本，但是我们无法避免外部对这个指针变量的 delete 操作。在这个例子中，Lambda 表达式执行时，指针变量 a 已经成为一个未定义的内容，直接对其解引用操作自然也就存在严重错误了。</p><p>当然这个例子放在这里可能比较极端，但是在多线程的异步编程中，变量生命周期长短不同，需要大量线程同步的情况随处可见，因此不得不小心。更何况在多线程中，还存在着大量的异步读写，这也可能会导致 Lambda 对该变量存在脏读的可能。</p><p>如果只能使用C++11标准，那么对于这种特定的问题，可以<font color=red>通过给期望捕获的变量做一个局部副本，然后捕获该副本去解决</font>，比如像下面例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>  *a = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 期望捕获指针变量 a，用以获取 a 中存储的内容</span><br>  <span class="hljs-comment">// 声明一个 _a 变量，作为指针变量 a 的局部副本</span><br>  <span class="hljs-type">int</span> _a = *a;<br>  <span class="hljs-comment">// 通过按值捕获副本，避免出现依赖生命周期的问题</span><br>  <span class="hljs-keyword">auto</span> f = [_a]() &#123; cout &lt;&lt; _a &lt;&lt; endl; &#125;;<br>  <span class="hljs-comment">// 在外部调用 delete 释放指针变量 a</span><br>  <span class="hljs-keyword">delete</span> a;<br>  <span class="hljs-comment">// 此时调用函数 f()，就不再出现之前的“heap-used-after-free”问题</span><br>  <span class="hljs-built_in">f</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// avoid_default_capture.cc</span><br></code></pre></td></tr></table></figure><p><mark>如果你被允许使用C++14或者更高的标准，那么使用“初始化捕获”可能是更好的选择。</mark></p><p>默认捕获模式，还存在一个更大的隐患，在类的“non-static”成员函数中使用默认捕获。众所周知，在类的“non-static”成员函数中，都包含了一个隐式指针 “<strong>this</strong>”。这里直接展示《Effective Modern C++》中的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> FilterContainer =                     <span class="hljs-comment">//“using”参见条款9，</span><br>    std::vector&lt;std::function&lt;<span class="hljs-built_in">bool</span>(<span class="hljs-type">int</span>)&gt;&gt;;  <span class="hljs-comment">//std::function参见条款2</span><br><br>FilterContainer filters;                    <span class="hljs-comment">//过滤函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    …                       <span class="hljs-comment">//构造函数等</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addFilter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//向filters添加条目</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> divisor;            <span class="hljs-comment">//在Widget的过滤器使用</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::addFilter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    filters.<span class="hljs-built_in">emplace_back</span>(<br>        [=](<span class="hljs-type">int</span> value) &#123; <span class="hljs-keyword">return</span> value % divisor == <span class="hljs-number">0</span>; &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>在函数<code>void Widget::addFilter() const;</code>中，Lambda 中使用了一个变量 <code>divisor</code>。对于不熟悉 lambda 的开发者来说，可能不太能理解变量 divisor 是什么，从哪里来的。C++ 中类的“non-static”成员函数都包含一个隐式的参数——“<strong>this</strong>指针”，而在 lambda 的捕获子句中使用了默认按值捕获的模式，这也就意味着 lambda 捕获了这个类的“<strong>this</strong>”指针，因此可以在 lambda 体中直接访问该类的数据成员和成员函数。<font color=red>由于捕获只能应用与 lambda 被创建时所在作用域内的 “non-static” 局部变量（包括形参）</font>,因此直接显式地指定捕获 divisor 变量，或者删除默认捕获模式，都将导致该代码编译失败。</p><p>这也就是前面提到的，默认按值捕获，会诱骗开发者错误地认为当前闭包是独立的。对于这个缺点，《Effective Modern C++》中还给出了一个例子，让我们来简单看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addDivisorFilter</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> calc1 = <span class="hljs-built_in">computeSomeValue1</span>();    <span class="hljs-comment">//现在是static</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> calc2 = <span class="hljs-built_in">computeSomeValue2</span>();    <span class="hljs-comment">//现在是static</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> divisor =                       <span class="hljs-comment">//现在是static</span><br>    <span class="hljs-built_in">computeDivisor</span>(calc1, calc2);<br><br>    filters.<span class="hljs-built_in">emplace_back</span>(<br>        [=](<span class="hljs-type">int</span> value)                          <span class="hljs-comment">//什么也没捕获到！</span><br>        &#123; <span class="hljs-keyword">return</span> value % divisor == <span class="hljs-number">0</span>; &#125;        <span class="hljs-comment">//引用上面的static</span><br>    );<br><br>    ++divisor;                                  <span class="hljs-comment">//调整divisor</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还记得上面提到的一个 Lambda 表达值中 capture 子句的一个限制吗？<font color=red>捕获只能应用与 lambda 被创建时所在作用域内的 “non-static” 局部变量（包括形参）</font>。那么在这个例子中，如果开发者对这个限制不了解，那么可能会错误地理解此处 Lambda 体中对 divisor 变量的使用是基于按值捕获的，也就会错误地认为在 Lambda 体中，divisor 变量始终为初始化的值。</p><p><mark>正确的解释应该是这样。divisor 被声明为 static 类型，因此在 Lambda 体中不需要捕获该变量，即可直接引用。这也就意味着这个被添加的闭包依赖了外部的 divisor，所有的闭包会随着外部 divisor 的变化而变化。所以，这个闭包根本不是独立的！</mark></p><p>我们再回顾一下上面 Widget 的例子，通过默认捕获模式捕获 this 指针，然后在 lambda 中访问类的数据成员，就目前来看没有任何问题。但是其中隐含了一个依赖生命周期的问题。还是《Effective Modern C++》中的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomeWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> pw =                               <span class="hljs-comment">//创建Widget；std::make_unique</span><br>        std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;();         <span class="hljs-comment">//见条款21</span><br><br>    pw-&gt;<span class="hljs-built_in">addFilter</span>();                        <span class="hljs-comment">//添加使用Widget::divisor的过滤器</span><br><br>    …<br>&#125;                                           <span class="hljs-comment">//销毁Widget；filters现在持有悬空指针！</span><br></code></pre></td></tr></table></figure><p>在调用 <code>doSomeWork()</code> 时，通过 <code>std::make_unique</code> 构建了一个 Widget 的对象，并且该对象向全局的 filters 中添加了一个过滤器。但是该过滤器中依赖了 Widget 对象的 this 指针，因为在默认捕获模式下访问了对象的数据成员 divisor。但是在函数 <code>doSomeWork()</code> 结束时，基于智能指针 <code>std::unique_ptr</code> 的特性，Widget 对象将自动析构，这意味着 this 指针也将被销毁。但是我们在全局的 filters 中仍然保存一个依赖于 this 指针的过滤器，尽管这个指针已经悬空！</p><p>简单总结一下《Effective Modern C++》中条款31中对 Lambda 捕获变量过程中存在的限制和隐患：</p><ol><li>捕获只能应用与 lambda 被创建时所在作用域内的 “non-static” 局部变量（包括形参）。</li><li>静态存储生命周期的对象，这些对象定义在全局空间或者命名空间，或者在类、函数、文件中被声明为 <code>static</code> ，这些变量无法被 lambda捕获，但可以直接使用</li><li>无论是按值捕获，还是按引用捕获，都存在依赖生命周期的问题。其中按引用捕获可能会导致悬空引用，而按值捕获则对悬空指针很敏感（尤其是 this 指针），并且容易误导开发者产生 lambda 是独立的想法。</li></ol><p>基于上面的几点，《Effective Modern C++》建议尽可能避免使用默认捕获模式，显式地指定期望被捕获的变量可能是个更好的选择。</p><h3 id="条款32：使用初始化捕获来移动对象到闭包中"><a href="#条款32：使用初始化捕获来移动对象到闭包中" class="headerlink" title="条款32：使用初始化捕获来移动对象到闭包中"></a>条款32：使用初始化捕获来移动对象到闭包中</h3><p>Item 32: Use init capture to move objects into closures</p><p>根据作者的表述，C++14标准中增加“初始化捕获”的初衷，是为了解决C++11中无法移动捕获的缺陷，但是移动捕获只是该捕获机制中的一中执行技术。</p><p>为什么初始化捕获可以执行移动捕获？本质上是因为下面两点特性：</p><ol><li>可以指定从 lambda 生成的闭包类中的数据成员的名称；</li><li>可以指定初始化该成员的表达式；</li></ol><p>因此可以通过移动语句的表达式完成对成员的初始化，从而实现移动捕获。下面简单介绍一下在C++14标准下通过初始化捕获将特定内容移动到闭包的方法，以及C++11实现近似移动捕获的方法。</p><p>其实在C++14中，这显得非常简单，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;                          <span class="hljs-comment">//一些有用的类型</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidated</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isProcessed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isArchived</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    …<br>&#125;;<br><br><span class="hljs-keyword">auto</span> pw = std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;();   <span class="hljs-comment">//创建Widget；使用std::make_unique</span><br>                                        <span class="hljs-comment">//的有关信息参见条款21</span><br><br>…                                       <span class="hljs-comment">//设置*pw</span><br><br><span class="hljs-keyword">auto</span> func1 = [pw = std::<span class="hljs-built_in">move</span>(pw)]        <span class="hljs-comment">//使用std::move(pw)初始化闭包数据成员</span><br>            &#123; <span class="hljs-keyword">return</span> pw-&gt;<span class="hljs-built_in">isValidated</span>()<br>                     &amp;&amp; pw-&gt;<span class="hljs-built_in">isArchived</span>(); &#125;;<br><br></code></pre></td></tr></table></figure><p>在 capture 子句中，“&#x3D;” 的左侧是指定的数据成员，右侧则是初始化表达式。这里就是通过初始化捕获的方式，将一个 <code>std::unique_ptr</code> 移动到了闭包类中。关于“&#x3D;”左右两侧的作用域，我想应该不必多说，左侧既然是闭包类的数据成员，那么其作用域必然仅仅在闭包类之内，而右侧则是一个外部变量，那么其作用域必然和当前的 lambda 享有同样的作用域。</p><p>倘若上述例子中，不需要要设置 *pw 那么可以再度简化 lambda 的捕获语句，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> func1 = [pw = std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;()]<br>            &#123; <span class="hljs-keyword">return</span> pw-&gt;<span class="hljs-built_in">isValidated</span>()<br>                     &amp;&amp; pw-&gt;<span class="hljs-built_in">isArchived</span>(); &#125;;<br></code></pre></td></tr></table></figure><p>因此，在C++14标准下，通过初始化捕获模式完成移动捕获是一件非常简单和便捷的事。但是这并不代表在C++11标准下，移动捕获是不可实现的。</p><p>对于在C++11下实现移动捕获，《Effective Modern C++》中给出了两种方式来模拟初始化捕获。</p><p>第一种，手写“闭包类”。<font color=red>Lambda 表达式只是生成一个类和创建该类型对象的一种简单方式</font>，因此通过手写实现这个类，同样可以模拟实现初始化捕获。直接看例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IsValAndArch</span> &#123;                            <span class="hljs-comment">//“is validated and archived”</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = std::unique_ptr&lt;Widget&gt;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">IsValAndArch</span><span class="hljs-params">(DataType&amp;&amp; ptr)</span>       <span class="hljs-comment">//条款25解释了std::move的使用</span></span><br><span class="hljs-function">    : pw(std::move(ptr)) &#123;</span>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> pw-&gt;<span class="hljs-built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="hljs-built_in">isArchived</span>(); &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    DataType pw;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> func2 = <span class="hljs-built_in">IsValAndArch</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;()); <span class="hljs-comment">// func 的真实类型是什么？ IsValAndArch</span><br></code></pre></td></tr></table></figure><p>通过将构造函数的参数设置为右值引用类型，通过 <code>std::move</code> 完成对数据成员 pw 的初始化。并通过重载括号运算符 <code>()</code> ，使对象可以通过 <code>()</code> 直接获取 Widget 对象 pw 的状态。虽然此处 func2 的使用方式和上文中的 func1 看起来一致，都形如 <code>func()</code>，但是两个 func 在本质上存在着差异，func1 实际为一个闭包对象，可以通过 <code>std::function</code> 进行包装，而 fun2 本质上只是普通类 IsValAndArch 的一个实例对象而已！</p><p>第二种模拟初始化捕获的方式，则是使用 <code>std::bind</code>：</p><ol><li>将要捕获的对象移动到由 <code>std::bind</code> 产生的函数对象中；</li><li>将“被捕获的”对象的引用赋予给 lambda 表达式。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">double</span>&gt; data;               <span class="hljs-comment">//要移动进闭包的对象</span><br><br>…                                       <span class="hljs-comment">//填充data</span><br><br><span class="hljs-keyword">auto</span> func = [data = std::<span class="hljs-built_in">move</span>(data)]    <span class="hljs-comment">//C++14初始化捕获</span><br>            &#123; <span class="hljs-comment">/*使用data*/</span> &#125;;<br><br><span class="hljs-keyword">auto</span> func_cpp11 =<br>    std::<span class="hljs-built_in">bind</span>(                              <span class="hljs-comment">//C++11模拟初始化捕获</span><br>        [](<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data) <span class="hljs-comment">//译者注：本行高亮</span><br>        &#123; <span class="hljs-comment">/*使用data*/</span> &#125;,<br>        std::<span class="hljs-built_in">move</span>(data)                     <span class="hljs-comment">//译者注：本行高亮</span><br>    );<br><br></code></pre></td></tr></table></figure>当然上面两个func不能写到同一处，因为在初始化捕获时，data已经将其内容移动到 func 这个闭包对象的数据成员 data 中了，在 func_cpp11 中再次进行 move 自然是无效移动了。</li></ol><p><font color=red>在默认情况下，从 lambda 生成的闭包类中的 operator() 成员函数为 const 的，这能将闭包中的所有数据成员渲染为 const 的效果</font>。<mark>而 std::bind 对象内部的移动构造的 data 副本不是 const的</mark>，因此为了避免 lambda 内部对该副本产生修改，此处形参声明为 reference-to-const 是必要的。</p><p>下面是《Effective Modern C++》中对此节内容的总结，一起看一下：</p><ul><li>无法移动构造一个对象到C++11闭包，但是可以将对象移动构造进C++11的bind对象。</li><li>在C++11中模拟移动捕获包括将对象移动构造进bind对象，然后通过传引用将移动构造的对象传递给lambda。</li><li>由于bind对象的生命周期与闭包对象的生命周期相同，因此可以将bind对象中的对象视为闭包中的对象。</li></ul><h3 id="条款33：对auto-amp-amp-形参使用decltype用以std-forward（完美转发）它们"><a href="#条款33：对auto-amp-amp-形参使用decltype用以std-forward（完美转发）它们" class="headerlink" title="条款33：对auto&amp;&amp;形参使用decltype用以std::forward（完美转发）它们"></a>条款33：对auto&amp;&amp;形参使用decltype用以std::forward（完美转发）它们</h3><p>Item 33: Use decltype on auto&amp;&amp; parameters to std::forward them</p><blockquote><p>由于完美转发掌握的有限，后续在进行补充</p></blockquote><h3 id="条款34：考虑lambda而非std-bind"><a href="#条款34：考虑lambda而非std-bind" class="headerlink" title="条款34：考虑lambda而非std::bind"></a>条款34：考虑lambda而非std::bind</h3><p>Item 34: Prefer lambdas to std::bind</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">C++ 中的 Lambda 表达式（https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170）</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://c.biancheng.net/view/3741.html">C++11 lambda表达式精讲（http://c.biancheng.net/view/3741.html）</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>lambda</tag>
      
      <tag>Linux编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unraid下虚拟DSM7.1，并开启相册人脸识别</title>
    <link href="/2023/02/17/Unraid%E4%B8%8B%E8%99%9A%E6%8B%9FDSM7-1%EF%BC%8C%E5%B9%B6%E5%BC%80%E5%90%AF%E7%9B%B8%E5%86%8C%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <url>/2023/02/17/Unraid%E4%B8%8B%E8%99%9A%E6%8B%9FDSM7-1%EF%BC%8C%E5%B9%B6%E5%BC%80%E5%90%AF%E7%9B%B8%E5%86%8C%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Unraid下虚拟DSM7-1，并开启相册人脸识别"><a href="#Unraid下虚拟DSM7-1，并开启相册人脸识别" class="headerlink" title="Unraid下虚拟DSM7.1，并开启相册人脸识别"></a>Unraid下虚拟DSM7.1，并开启相册人脸识别</h1><p><strong><font color="red">风险提示！！！请勿直接应用于生产环境或者单一数据存储环境，当前仅为测试版本！！！数据无价，请务必做好数据备份！！！</font></strong></p><p><strong><font color="red">风险提示！！！请勿直接应用于生产环境或者单一数据存储环境，当前仅为测试版本！！！数据无价，请务必做好数据备份！！！</font></strong></p><p><strong><font color="red">风险提示！！！请勿直接应用于生产环境或者单一数据存储环境，当前仅为测试版本！！！数据无价，请务必做好数据备份！！！</font></strong></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>由于主机换新，之前的旧设备闲置也是闲置，于是参考 <a href="https://space.bilibili.com/28457/">Unraid 教父——司波图</a>一系列教程搭建了一台 Unraid 系统的 NAS。之前四盘位的 J3455 蜗牛星际也快满了，并且性能远远低于换代下来的 i5 8500，正好将内容迁移到 Unraid 上。但是群晖的相册套件说实话简单上手好用，还自带人脸识别，所以还是打算在 Unraid 上虚拟一个黑群晖，专门用于相册的备份和维护。废话不多说，下面开始干货。</p><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><table><thead><tr><th align="left"></th><th align="right"></th></tr></thead><tbody><tr><td align="left">sys</td><td align="right">Unraid 6.10.3</td></tr><tr><td align="left">cpu</td><td align="right">Intel® Core™ i5-8500 CPU @ 3.00GHz</td></tr><tr><td align="left">主板</td><td align="right">Gigabyte Technology Co., Ltd. B360M AORUS Gaming 3-CF</td></tr><tr><td align="left">内存</td><td align="right">DDR4 -  24G 普条</td></tr><tr><td align="left">硬盘</td><td align="right">希捷 ST18000NM013J_ZR56YQB9 - 18 TB<br />西数 SN570 -1TB</td></tr></tbody></table><p>基本配置如上，其中西数的 SN570 作为 cache 使用，无校验盘。“亡命之徒”本徒了。</p><p><strong><font color="red">注意：如果需要添加校验盘，则校验盘容量必须大于等于阵列中单硬盘最大容量，以上配置就需要一个 18T 的硬盘作为校验盘。没有校验盘时，重要资料务必多地备份！</font></strong></p><h2 id="三、准备事项"><a href="#三、准备事项" class="headerlink" title="三、准备事项"></a>三、准备事项</h2><p><strong>以下内容都是基于 DSM918+ 7.1.0 展开，其余设备型号或者版本因精力有限未做尝试！</strong></p><ol><li>准备一个 tinycore-redpill 的基础镜像（tinycore-redpill-uefi.v0.8.0.0.img）：<a href="https://github.com/pocopico/tinycore-redpill">https://github.com/pocopico/tinycore-redpill</a></li><li>准备 DSM918+ 7.1.0patch 文件：<a href="https://cndl.synology.cn/download/DSM/release/7.1/42661-1/DSM_DS918%2B_42661.pat">https://cndl.synology.cn/download/DSM/release/7.1/42661-1/DSM_DS918%2B_42661.pat</a></li><li>主板 bios 打开核显（安装过程中发现，核显被设置为自动，当有独显时，核显默认不开，会导致 Unraid 无法获取核显信息，<strong>Intel GVT-g</strong> 插件无法使用）</li><li>ssh 工具，如 xshell，putty，MobaXterm 等</li></ol><h2 id="四、创建虚拟-DSM-流程"><a href="#四、创建虚拟-DSM-流程" class="headerlink" title="四、创建虚拟 DSM 流程"></a>四、创建虚拟 DSM 流程</h2><p><mark><font color="red">再次提醒！！！务必做好数据备份，在无需担心数据损失的前提下进行以下操作！！！</font></mark></p><p><mark><font color="red">再次提醒！！！务必做好数据备份，在无需担心数据损失的前提下进行以下操作！！！</font></mark></p><p><mark><font color="red">再次提醒！！！务必做好数据备份，在无需担心数据损失的前提下进行以下操作！！！</font></mark></p><h3 id="1、创建虚拟机"><a href="#1、创建虚拟机" class="headerlink" title="1、创建虚拟机"></a>1、创建虚拟机</h3><p>创建虚拟机的基本步骤请参考——<a href="https://www.bilibili.com/video/BV1R7411s7gP?spm_id_from=333.999.0.0">unRaid 下黑群晖，Freenas，OMV 的安装方法——司波图 UNRAID 陪玩教程 05</a>。</p><p>最新的创建参数和大佬的有些差别：</p><ol><li>Machine：Q35-6.2</li><li>BIOS：OVMF（tinycore 选择 UEFI 镜像）</li><li>USB Controller：3.0(qemu XHCI)</li><li>Primary vDisk 选择我们事先拷贝到 isos 目录下的镜像文件（tinycore-redpill-uefi.v0.8.0.0.img），并选择 USB 模式</li><li>添加第二块 vDisk，此处设置为 sata 模式，其余按需设置即可</li><li>网卡设置为 e1000</li><li>取消勾选“Start VM after creation”</li></ol><p>此时已基本完成虚拟机相关设置，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/180962087-4ce99534-f44e-4cf7-bb9e-26dc5148f248.png"></p><p>创建后，重新编辑虚拟机，打开 xml 模式，修改以下红框内划线处 <code>controller = &quot;0&quot;</code> 为 <code>controller = &quot;1&quot;</code>。</p><p><img src="https://user-images.githubusercontent.com/35327600/180955218-2dc76d15-879c-4f12-b029-1f90cf0ca5b8.png"></p><p>本人在尝试了无数次卡重新安装 pat 的死循环后，最终在 xp 论坛上找到了解决方案。就是这个 sata disk 的 controller 索引错误导致无法找到 sata 磁盘控制信息，从而卡在安装 pat 文件错误的死循环中。原贴链接：<a href="https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607">https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607</a></p><p>整体安装 DSM 的流程也可参考原贴。</p><h3 id="2、创建完整引导镜像"><a href="#2、创建完整引导镜像" class="headerlink" title="2、创建完整引导镜像"></a>2、创建完整引导镜像</h3><ol><li><p>开启虚拟机，并开启 VNC，看到如下界面：</p><p><img src="https://user-images.githubusercontent.com/35327600/180959772-e0ea5062-238d-4e65-a9f0-db37e77e379e.png"></p><p>按照图片中描述操作，获取当前虚拟机 ip 地址</p></li><li><p>通过 ssh 工具进行连接虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh tc@192.168.2.191<br>&lt;输入密码：P@ssw0rd&gt;<br><br>Connecting to 192.168.2.191:22...<br>Connection established.<br>To escape to local shell, press &#x27;Ctrl+Alt+]&#x27;.<br><br>WARNING! The remote SSH server rejected X11 forwarding request.<br>   ( &#x27;&gt;&#x27;)<br>  /) TC (\   Core is distributed with ABSOLUTELY NO WARRANTY.<br> (/-_--_-\)           www.tinycorelinux.net<br><br>tc@box:~$ <br></code></pre></td></tr></table></figure></li><li><p>依次无脑执行以下命令，命令执行过程中会有部分内容需要手动确定，有 yY 输 y，无 yY 直接回车</p><ul><li><code>./rploader.sh update now</code></li><li><code>./rploader.sh fullupgrade now</code></li><li><code>./rploader.sh serialgen DS918+</code></li><li><code>./rploader.sh satamap now</code></li><li><code>./rploader.sh identifyusb now</code></li><li><code>./rploader.sh ext apollolake-7.1.0-42661 add https://raw.githubusercontent.com/pocopico/rp-ext/master/e1000/rpext-index.json</code></li><li><code>./rploader.sh build apollolake-7.1.0-42661</code></li></ul><p>执行最后一个命令时，可能会有红色日志提示，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[!] Extension is already added (index exists at /home/tc/redpill-load/custom/extensions/pocopico.e1000/pocopico.e1000.json). For more info use &quot;ext-manager.sh info pocopico.e1000&quot;<br>*** Process will exit ***<br></code></pre></td></tr></table></figure><p>该提示目前使用下来无影响，出现如下打印，表示镜像构建成功：</p><p><img src="https://user-images.githubusercontent.com/35327600/180965299-4c8231d4-a541-4275-b167-0ba521330ab8.png"></p></li><li><p>关闭虚拟机，打开 xml 编辑，查看之前修改的 <code>controller = &quot;1&quot;</code> 是否又变回默认值 <code>&quot;0&quot;</code>。如果发生改变，请再一次手动更改为 <code>&quot;1&quot;</code>，否则将无法正确安装 pat 文件。</p></li></ol><h3 id="3、创建-DSM7-1"><a href="#3、创建-DSM7-1" class="headerlink" title="3、创建 DSM7.1"></a>3、创建 DSM7.1</h3><p>启动虚拟机，并在 VNC 中手动选择 USB 引导。（起始界面还有一个 SATA 引导，未进行测试，喜欢折腾可以试试）</p><p>后续就和常规安装群晖一样，使用浏览器访问 <a href="https://finds.synology.com/%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%96%B0%E5%AE%89%E8%A3%85%E7%9A%84">https://finds.synology.com/，获取新安装的</a> DSM 信息，上传 pat 文件进行安装。</p><p><img src="https://user-images.githubusercontent.com/35327600/180968642-5e580051-e9a7-4e82-be03-267eadf2e1b0.png"></p><p>恭喜，DSM 7.1 至此已完成完整的安装！接下来的基本操作就不在赘述了，按照指引正常处理就行。</p><h2 id="五、开启相册人脸识别"><a href="#五、开启相册人脸识别" class="headerlink" title="五、开启相册人脸识别"></a>五、开启相册人脸识别</h2><p>按照上述流程创建的群晖是无法开启相册套件中的人脸识别功能，因为核显没有直通给群晖，导致群晖无法调用核显进行人脸识别。我们需要借助“<strong>Intel GVT-g</strong>”插件虚拟化核显，并配置给我们的群晖虚拟机。</p><ol><li><p>配置好群晖后，关闭虚拟机</p></li><li><p>在 Unraid APP 市场中安装插件 <strong>Intel GVT-g</strong></p></li><li><p>在 PLUGINS 界面中打开 <strong>Intel GVT-g</strong> 配置</p></li><li><p>根据当前虚拟显存的模式，分配给群晖虚拟机，确定后点击 “ASSIGN VM”</p><p><img src="https://user-images.githubusercontent.com/35327600/180971454-d802c4c7-6050-452f-b954-d1bc4e8a3375.png"></p></li><li><p>回到虚拟机的 xml 配置进行修改，安装时的 <code>controller = &quot;1&quot;</code> 还是需要注意的地方。其余部分按下图进行修改：</p><p><img src="https://user-images.githubusercontent.com/35327600/180977569-0c9566b4-8ab8-4232-89d8-a39959387c5a.png"></p><p>找到 xml 中新增的 &lt;hostdev&gt;，将其中的 <code>bus = &#39;0x01&#39; slot=&#39;0x00&#39;</code> 修改为 <code>bus = &#39;0x00&#39; slot=&#39;0x02&#39;</code>，这是因为虚拟化后核显的地址默认为 <code>0000:00:02.0</code></p><p>由于我们将虚拟化核显的总线（bus）和设备号（slot）修改了，和 xml 中部分原有配置产生冲突，因此需要将其余 <code>bus = &#39;0x00&#39; slot=&#39;0x02&#39;</code> 所在的行删除，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/180977611-5185c30b-d8d6-43d6-94c8-b6dfc9714bfd.png"></p></li><li><p>修改完成后，重启群晖虚拟机，在 <code>控制面板-&gt;终端机和SNMP</code> 中打开 ssh 功能。使用 ssh 工具进行连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">输入：ls /dev/dri<br>显示：card0  renderD128<br></code></pre></td></tr></table></figure></li></ol><p>如果能正常显示上述内容，如果不是设备特殊，此时应该已经能进行人脸识别，我们测试一下</p><h2 id="六、人脸识别功能测试"><a href="#六、人脸识别功能测试" class="headerlink" title="六、人脸识别功能测试"></a>六、人脸识别功能测试</h2><p>在套件中心搜索关键词“photo”，下载安装完成后打开，点击右上角用户图标，在设置中“启用个人空间人物相册”</p><p><img src="https://user-images.githubusercontent.com/35327600/180982129-913020e6-c84d-4f68-9292-c982bc34b2c2.png"></p><p>找几张图上传，等一段时间后，查看一下人物相册，是否根据人脸识别自动创建了对应的相册，如果正确创建了，那么恭喜！</p><p><img src="https://user-images.githubusercontent.com/35327600/181008438-89e5df3b-ec6e-4bad-ab56-56d63161810a.png"></p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li>pocopico 大佬的 github：<a href="https://github.com/pocopico/tinycore-redpill">https://github.com/pocopico/tinycore-redpill</a></li><li>xpenology 论坛：<a href="https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607">https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607</a></li><li>Jinlife 大佬博客：<a href="https://blog.jinlife.com/index.php/archives/49/">https://blog.jinlife.com/index.php/archives/49/</a></li><li>张大妈：<a href="https://post.smzdm.com/p/a5dl2808/">https://post.smzdm.com/p/a5dl2808/</a></li><li>司波图 B 站教程视频：<a href="https://space.bilibili.com/28457/channel/seriesdetail?sid=896368">https://space.bilibili.com/28457/channel/seriesdetail?sid=896368</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>DSM7.1</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
