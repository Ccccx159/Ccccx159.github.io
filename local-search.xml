<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DDNS动态域名解析IPv6地址</title>
    <link href="/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/03/21/DDNS%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90IPv6%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用公网IPv6远程访问内网设备</title>
    <link href="/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/"/>
    <url>/2023/03/21/%E4%BD%BF%E7%94%A8%E5%85%AC%E7%BD%91IPv6%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="使用公网IPv6远程访问内网设备"><a href="#使用公网IPv6远程访问内网设备" class="headerlink" title="使用公网IPv6远程访问内网设备"></a>使用公网IPv6远程访问内网设备</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>IPv4公网IP一号难求的环境下，如何优雅的使用公网IPv6进行远程访问？本文将以中国移动的宽带和光猫为例，进行IPv6的设置说明，并实现通过IPv6地址和Windows系统自带的远程工具”mstsc”，远程访问内网的Windows主机。</p><p>可能部分宽带安装师傅默认没有打开 IPv6 的功能，因此我们先登录光猫的后台确认光猫是否开启了 IPv6。由于电信的宽带服务相对比较容易获取到公网IPv4地址，因此这里以移动宽带举例，其他宽带运营商提供的光猫可能有所差异，但是功能大同小异，请自行搜索相应操作细节。</p><h2 id="二、确认IPv6连接状态"><a href="#二、确认IPv6连接状态" class="headerlink" title="二、确认IPv6连接状态"></a>二、确认IPv6连接状态</h2><p>如果宽带是由光猫拨号连接的，在浏览器中输入光猫的后台地址，例如 <code>192.168.1.1</code>，移动光猫的后台界面如下图所示。一般来说，移动光猫的管理员账号和密码是相同的，曾经在同一省份的不同城市都办理过移动宽带，光猫后台的账号密码都如图中所示 <code>账号：CMCCAdmin  密码：aDm8H%MdA</code> 。不确定不同省份是否有所差异，如果这个账号密码不可用，请自行搜索或者向宽带运营商索取。</p><p><img src="https://user-images.githubusercontent.com/35327600/223893633-286b2a64-fbe5-4f88-b4b1-ed7ea31af0d4.png"></p><p>点击确定后，进入后台界面，按下图中所标识的按钮和顺序，依次点击，可以在当前界面查看到 IPv6 的连接信息。</p><p><img src="https://user-images.githubusercontent.com/35327600/223897533-878fed3e-07c9-4912-8679-dc645432fefb.png"></p><p>如果确定 IPv6 已正确连接，在上图界面中，可以拉动横向的滚动条，查看当前的 IPv6 地址。</p><p><img src="https://user-images.githubusercontent.com/35327600/226225202-a8abe3c7-357b-4a32-83b4-2e618983d270.png"></p><p>如果上述界面中显示IPv6未连接，请根据以下界面检查运营商是否给当前宽带套餐开通IPv6功能。</p><p><img src="https://user-images.githubusercontent.com/35327600/226227385-07eb44f5-9836-47d3-89ef-7237f855b369.png"></p><h2 id="三、打开并查看远程主机IPv6地址"><a href="#三、打开并查看远程主机IPv6地址" class="headerlink" title="三、打开并查看远程主机IPv6地址"></a>三、打开并查看远程主机IPv6地址</h2><p>这里以win10系统为例，可能部分人的PC默认没有开启IPv6，按照以下步骤打开IPv6，并获取IPv6地址。</p><ol><li>按下 “windows徽标” + “R”，打开运行窗口，输入 “ncpa.cpl” 后回车，打开网络适配器管理界面<br> <img src="https://user-images.githubusercontent.com/35327600/226231169-7eb0ce41-e3b9-429b-b9b2-06306351b0a5.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226231296-153119ad-ce30-4477-ac49-2e53a3a88316.png"></li><li>双击以太网连接，查看当前以太网状态，若IPv6连接显示无网络连接，则按以下图片内说明打开IPv6连接<br> <img src="https://user-images.githubusercontent.com/35327600/226232249-91264fa3-74f0-44d1-891b-64f0ba50561c.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226233016-617c197b-32e8-4d0e-bbdf-d36cac0deb69.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226234598-aa6dba1e-1b3c-4928-a1ea-5ae0794f61f0.png"></li></ol><h2 id="四、打开本地PC的IPv6连接"><a href="#四、打开本地PC的IPv6连接" class="headerlink" title="四、打开本地PC的IPv6连接"></a>四、打开本地PC的IPv6连接</h2><p>由于需要使用IPv6进行远程连接，需要确保本地 PC 和远程 PC 同时具备 IPv6 的连接能力，因此对于本地PC，也需要按照上述<strong>第2步</strong>进行确认。</p><blockquote><p>远程PC和本地PC可使用浏览器访问<a href="http://ipv6.test-ipv6.com/">IPv6测试网站</a>进行连接测试。</p></blockquote><p>完成两端的 IPv6 连接设置后，可以直接使用 IPv6 地址尝试远程连接，不出意外，此时已经可以成功进行远程访问了。</p><ul><li>按下 “windows 徽标” + “R”，打开运行界面，输入 “mstsc”，回车，打开远程连接界面，填入第二步中获取的”<strong>远程 PC 的 IPv6 地址</strong>“，点击连接。正常情况下，此时会弹出要求输入用户名和密码。<br>  <img src="https://user-images.githubusercontent.com/35327600/226236201-a851eec6-c3a7-40dd-b6f0-70f4e48889c2.png"></li></ul><h2 id="五、遇到的坑"><a href="#五、遇到的坑" class="headerlink" title="五、遇到的坑"></a>五、遇到的坑</h2><p>整个过程可能会存在两个坑，导致无法连接：</p><ol><li>光猫默认使能IPv6防火墙的控制转发报文功能（作者的移动光猫中是这么描述的），导致所有的IPv6数据包被拦截，从而无法建立远程连接，甚至无法 ping 通。需要将该功能关闭，才能正常使用IPv6。<br> <img src="https://user-images.githubusercontent.com/35327600/226237991-c5b5cadb-0837-40c6-aa1d-48d968927ce3.png"></li><li>远程PC未打开远程访问功能。win10家庭版不支持远程桌面，专业版则默认关闭了远程桌面，因此需要手动打开和确认。<br> <img src="https://user-images.githubusercontent.com/35327600/226238918-83374ecb-6640-4c8e-87bd-2153e81124ac.png"><br> <img src="https://user-images.githubusercontent.com/35327600/226239110-a296c35e-5546-4a3d-b5cb-913901ac9121.png"></li><li>部分网络默认不开启IPv6，例如公司内部网络等，因此远程PC虽然开启了IPv6，但仍然无法通过IPv6进行远程连接；</li></ol><h2 id="六、存在的缺陷"><a href="#六、存在的缺陷" class="headerlink" title="六、存在的缺陷"></a>六、存在的缺陷</h2><p>按步骤完成上述操作后，一般来说，已经能成功使用IPv6地址进行远程访问。但是使用起来仍然存在2个比较致命的问题：</p><ol><li>IPv6 地址很长，不方便记忆；</li><li>公网 IPv6 地址并非固定不变，在一定情况下，地址发生变更，如果不能及时获取地址，则无法进行远程访问</li></ol><p>针对第一个缺陷，由于域名可以自定义申请，并且方便记忆，因此我们可以申请一个域名（例如 baidu.com、google.com），并将域名解析到对应IP地址（DNS服务商提供解析服务），通过域名来进行访问。</p><p>而第二个缺陷，在域名的基础上，我们还需要定期将当前的IP地址，同步给DNS服务商，修改域名解析的目标IP，确保域名能正确解析到我们自己的设备上。</p><p>由于文章篇幅较长，因此将在下一篇文章中进行详细说明介绍~</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>IPv6</tag>
      
      <tag>mstsc</tag>
      
      <tag>网络运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于DSM7.1，通过nginx反代破解Emby Server Premiere</title>
    <link href="/2023/03/13/%E5%9F%BA%E4%BA%8EDSM7-1%EF%BC%8C%E9%80%9A%E8%BF%87nginx%E5%8F%8D%E4%BB%A3%E7%A0%B4%E8%A7%A3Emby-Server-Premiere/"/>
    <url>/2023/03/13/%E5%9F%BA%E4%BA%8EDSM7-1%EF%BC%8C%E9%80%9A%E8%BF%87nginx%E5%8F%8D%E4%BB%A3%E7%A0%B4%E8%A7%A3Emby-Server-Premiere/</url>
    
    <content type="html"><![CDATA[<h1 id="基于DSM7-1，通过nginx反代破解Emby-Server-Premiere"><a href="#基于DSM7-1，通过nginx反代破解Emby-Server-Premiere" class="headerlink" title="基于DSM7.1，通过nginx反代破解Emby Server Premiere"></a>基于DSM7.1，通过nginx反代破解Emby Server Premiere</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><strong><font color="red">！！！破解教程仅供学习参考，务必支持正版软件，构建良好的软件版权生态！！！</font></strong></p><p>Emby Server是一个开源的流媒体中心软件，可以非常方便的管理和维护电影，电视剧集等媒体库，并生成强大美观的海报墙。并且全平台的客户端，使其跨设备观看变得非常便利。但是服务端的部分插件功能，以及视频转码功能，需要会员才能解锁。针对尝鲜的个人用户来说，这个会员着实不便宜，经过搜寻相关资料后，确定其会员验证是通过与<code>mb3admin.com</code>这个网站通信完成，因此本教程将通过nginx的反向代理+hosts进行域名劫持来实现会员的”破解”。</p><h2 id="二、准备工具"><a href="#二、准备工具" class="headerlink" title="二、准备工具"></a>二、准备工具</h2><ul><li>DMS7.1群晖系统（本质上任意一个nginx服务都可以，DSM本身的web就是通过nginx实现的，因此不需要单独在开一个nginx服务了）</li><li>文本编辑软件（Notepad++，subline text，vs code均可）</li><li>ssh工具（Xshell，MobaXterm，putty，finalshell等）</li></ul><h2 id="三、破解步骤"><a href="#三、破解步骤" class="headerlink" title="三、破解步骤"></a>三、破解步骤</h2><h3 id="1、申请ssl证书"><a href="#1、申请ssl证书" class="headerlink" title="1、申请ssl证书"></a>1、申请ssl证书</h3><p>由于Emby Server需要和<code>mb3admin.com</code>进行https通信，因此我们需要针对该域名申请ssl证书。</p><p>推荐 GMCert.org <a href="https://www.gmcert.org/subForm%E3%80%82%E6%8C%89%E4%BB%A5%E4%B8%8B%E7%94%B3%E8%AF%B7%E6%AD%A5%E9%AA%A4%E8%BF%9B%E8%A1%8C%EF%BC%9A">https://www.gmcert.org/subForm。按以下申请步骤进行：</a></p><p><img src="https://user-images.githubusercontent.com/35327600/201810752-d921d035-c76d-439c-9160-e320a36af37d.jpg"></p><ul><li>CA证书如果此前PC端已安装过，则可不用重复下载安装；如果是全新安装，则尽量安装一下，双击证书，点击安装，然后手动选择证书存储，将证书安装到“受信任的根证书颁发机构”即可。</li><li>主题名称为此次所需的二级域名<code>mb3admin.com</code></li></ul><p>点开下方的“<strong>高级选项</strong>”，并按照以下进行配置：</p><p><img src="https://user-images.githubusercontent.com/35327600/201813309-cc83b055-df1d-4b61-bda9-103939c7cc2c.png"></p><ul><li>在主题备用名称中，填入上图内容，将泛域名也填充进去，保证任意三级域名都处于ssl证书授权范围</li><li>密钥用途和扩展密钥用途按图中红框勾选即可</li><li>点击“<strong>签发证书</strong>”，会下载一个包含密钥和证书的压缩包，解压并保存</li></ul><h3 id="2、上传密钥和证书"><a href="#2、上传密钥和证书" class="headerlink" title="2、上传密钥和证书"></a>2、上传密钥和证书</h3><p>将上一步中解压获取的证书和密钥文件，上传至群晖中</p><p><img src="https://user-images.githubusercontent.com/35327600/201814624-8bc428eb-1947-430f-a27a-2301ce7379d8.png"></p><h3 id="3、创建nginx代理配置"><a href="#3、创建nginx代理配置" class="headerlink" title="3、创建nginx代理配置"></a>3、创建nginx代理配置</h3><p>新建文件<code>emby_crack_nginx.conf</code>，粘贴以下内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>     <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>     <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">443</span> ssl;<br>     <span class="hljs-attribute">server_name</span> mb3admin.com;<br>     <span class="hljs-attribute">ssl_certificate</span> /volume1/web/mb3admin.com/mb3admin.com.cert.pem;<br>     <span class="hljs-attribute">ssl_certificate_key</span> /volume1/web/mb3admin.com/mb3admin.com.key.pem;<br>     <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;<br>     <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;<br>     <span class="hljs-attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<br>     <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br>     <span class="hljs-section">location</span> = /webdefault/images/logo.jpg &#123;<br>     <span class="hljs-attribute">alias</span> /usr/syno/share/nginx/logo.jpg;<br>            &#125;<br>     <span class="hljs-section">location</span> <span class="hljs-variable">@error_page</span> &#123;<br>     <span class="hljs-attribute">root</span> /usr/syno/share/nginx;<br>     <span class="hljs-attribute">rewrite</span> (.*) /<span class="hljs-literal">error</span>.html <span class="hljs-literal">break</span>;<br>            &#125;<br>     <span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /.well-known/acme-challenge &#123;<br>     <span class="hljs-attribute">root</span> /var/lib/letsencrypt;<br>     <span class="hljs-attribute">default_type</span> text/plain;<br>            &#125;<br>     <span class="hljs-section">location</span> / &#123;<br>     <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^</span> / <span class="hljs-literal">redirect</span>;<br>            &#125;<br>     <span class="hljs-section">location</span> <span class="hljs-regexp">~ ^/$</span> &#123;<br>     <span class="hljs-attribute">rewrite</span> / https://<span class="hljs-variable">$host</span>:5001/ <span class="hljs-literal">redirect</span>;<br>            &#125;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin *;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers *;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Method *;<br>     <span class="hljs-attribute">add_header</span> Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;<br>     <span class="hljs-section">location</span> /admin/service/registration/validateDevice &#123;<br>     <span class="hljs-attribute">default_type</span> application/json;<br>     <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&#123;&quot;cacheExpirationDays&quot;: 365,&quot;message&quot;: &quot;Device Valid&quot;,&quot;resultCode&quot;: &quot;GOOD&quot;&#125;&#x27;</span>;<br>    &#125;<br>     <span class="hljs-section">location</span> /admin/service/registration/validate &#123;<br>     <span class="hljs-attribute">default_type</span> application/json;<br>     <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&#123;&quot;featId&quot;:&quot;&quot;,&quot;registered&quot;:true,&quot;expDate&quot;:&quot;2099-01-01&quot;,&quot;key&quot;:&quot;&quot;&#125;&#x27;</span>;<br>    &#125;<br>     <span class="hljs-section">location</span> /admin/service/registration/getStatus &#123;<br>     <span class="hljs-attribute">default_type</span> application/json;<br>     <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">&#x27;&#123;&quot;deviceStatus&quot;:&quot;0&quot;,&quot;planType&quot;:&quot;Lifetime&quot;,&quot;subscriptions&quot;:&#123;&#125;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><p>由于证书和密钥的文件路径可能各有不同，在上述代码块中修改成自定义路径</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># ssl_certificate /volume1/web/mb3admin.com/mb3admin.com.cert.pem;</span><br><span class="hljs-attribute">ssl_certificate</span> /change/to/your/own/cert/file/path;<br><span class="hljs-comment"># ssl_certificate_key /volume1/web/mb3admin.com/mb3admin.com.key.pem;</span><br><span class="hljs-attribute">ssl_certificate_key</span> /change/to/your/own/key/file/path;<br></code></pre></td></tr></table></figure></li></ul><p>将配置文件<code>emby_crack_nginx.conf</code>拷贝至群晖的系统目录<code>/etc/nginx/sites-enabled</code>目录下。</p><h3 id="4、修改hosts文件"><a href="#4、修改hosts文件" class="headerlink" title="4、修改hosts文件"></a>4、修改hosts文件</h3><p>由于Emby Server和Emby Client在验证会员时，向<code>mb3admin.com</code>进行post请求，因此需要在服务器或者客户端发出请求时，劫持到我们自行构建的nginx服务上，通过nginx发送假的验证通过的消息，实现会员资格验证成功。</p><p>因此需要在Emby Server和Emby Client所在的设备上修改hosts文件，将mb3admin.com域名直接指向群晖的IP。</p><ul><li>如果家中有能修改hosts的路由设备，可在路由器中直接修改，这样就不需要在每一个子设备中进行修改了；如果没有则在以下设备中的hosts文件中加入代码块中内容；</li><li>Emby Server所在服务端设备；</li><li>windows系统PC端；</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># hosts</span><br><span class="hljs-comment"># &lt;群晖IP&gt; mb3admin.com</span><br><span class="hljs-comment"># 假如群晖IP是：192.168.1.100，则如下所示</span><br>192.168.1.100 mb3admin.com<br></code></pre></td></tr></table></figure><h3 id="5、向Emby服务端的证书库中导入CA证书"><a href="#5、向Emby服务端的证书库中导入CA证书" class="headerlink" title="5、向Emby服务端的证书库中导入CA证书"></a>5、向Emby服务端的证书库中导入CA证书</h3><p>在日志中发现会存在无法建立SsL连接的情况，爬贴后发现，是因为自签名证书不被Emby信任导致。这时候就需要我们将当初申请证书时，获取到的CA证书导入到Emby的可信任证书库中。docker 版本的话，需要先确认根证书文件是否由 host 端导入。整体操作流程，无论是套件版本还是 docker 版本，都大同小异。下面以套件版本为例进行说明。</p><blockquote><p>一般根证书文件存储在 <code>/etc</code> 目录下，因此需要 root 权限才能完成。以下操作均在 root 用户下进行。</p></blockquote><ol><li>进入证书存储的目录，以上文为例，执行命令： <code>cd /volume1/web/mb3admin.com</code> </li><li>打印证书内容，观察格式是否正确：<code>cat mb3admin.com.cert.pem</code><br> 按下回车键后，屏幕将输出形如一下内容，确认文件以 <code>-----BEGIN CERTIFICATE-----</code> 开头，<code>-----END CERTIFICATE-----</code> 结尾：<br> <img src="https://user-images.githubusercontent.com/35327600/224621454-b0d99048-5b8c-470e-b7b9-70d81d5865df.jpg"></li><li>将证书拷贝至对应目录，并重命名。这里以群晖7.1为例，执行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /usr/syno/etc/security-profile/ca-bundle-profile/ca-certificates/;<br><span class="hljs-built_in">cp</span> /volume1/web/mb3admin.com/mb3admin.com.cert.pem /usr/syno/etc/security-profile/ca-bundle-profile/ca-certificates/mb3admin.com.crt;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p> &#x2F;usr&#x2F;syno&#x2F;etc&#x2F;security-profile&#x2F;ca-bundle-profile&#x2F;ca-certificates&#x2F; 这个路径是从update-ca-certificates.sh中获取的，不同系统的路径可能不同，建议先执行 <code>sodu find / -name &quot;update-ca-certificates</code> ，查找这个文件。例如群晖7.1中，该文件位于 &#x2F;usr&#x2F;syno&#x2F;bin 中。使用 cat 命令查看文件内容，找到 <code>USERCERTSDIR=xxxxxxx</code> 行，”xxxxxxxx” 就是对应的路径；Ubuntu系统下，找到 LOCALCERTSDIR&#x3D;xxxxx 行即可。</p></blockquote><ol start="4"><li>更新根证书，执行命令：<code>update-ca-certificates.sh</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Emby</tag>
      
      <tag>群晖DSM7.1</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unraid自定义docker和虚拟机图标</title>
    <link href="/2023/02/21/Unraid%E8%87%AA%E5%AE%9A%E4%B9%89docker%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BE%E6%A0%87/"/>
    <url>/2023/02/21/Unraid%E8%87%AA%E5%AE%9A%E4%B9%89docker%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Unraid自定义docker和虚拟机图标"><a href="#Unraid自定义docker和虚拟机图标" class="headerlink" title="Unraid自定义docker和虚拟机图标"></a>Unraid自定义docker和虚拟机图标</h1><h2 id="一、自定义docker图标"><a href="#一、自定义docker图标" class="headerlink" title="一、自定义docker图标"></a>一、自定义docker图标</h2><p>在 Unraid 中可以通过自带的应用市场安装 docker 容器，但是也有部分docker并未上架市场，需要通过 “ADD CONTAINER” 按钮手动安装，这样的 docker 容器并没有自带图标。还有一部分即使是在应用市场安装的 docker 容器本身有图标，但是由于国内的网络环境原因，导致图标链接不可访问，最终在 docker 界面中显示一个灰底的问号。</p><p>这里用一个手动安装的 python:alpine3.16 的容器作为示例进行说明：<br><img src="https://user-images.githubusercontent.com/35327600/220238709-7d4f5fff-c5f6-4955-a2be-b84d23658354.png"></p><p>下面介绍两种方式来自定义设置 Docker 容器的图标。</p><h3 id="1-1、方法一：直接修改-Docker-容器配置"><a href="#1-1、方法一：直接修改-Docker-容器配置" class="headerlink" title="1.1、方法一：直接修改 Docker 容器配置"></a>1.1、方法一：直接修改 Docker 容器配置</h3><p>无论是从应用市场安装的 docker 容器还是手动创建的，都会在安装前展示容器的配置界面，两种安装方式的差别仅仅就是应用市场的 docker 容器会将大部分的配置参数预先填充，避免了手动配置填充的过程，为部分经验不足的新手提供了相当的便利。</p><p>一般来说，配置界面只展示了基础配置，我们点击右上角的 “BASIC VIEW” 按钮，打开高级配置 “ADVANCED VIEW”:<br><img src="https://user-images.githubusercontent.com/35327600/220241255-d0f8e445-8d3d-4de6-929a-01719f8c7d87.png"></p><p>打开后可见新增了许多配置项：<br><img src="https://user-images.githubusercontent.com/35327600/220242308-ad3b6a1f-621c-4fc7-b13f-5e5d56e45ec3.png"></p><p>可以看到新增的配置项中，有一项名为 “Icon URL” 的配置，这里填充的就是当前 docker 容器的图标链接。我们在网上找一个 Python 的图标，并复制其图片地址进行配置填充：<br>python图标链接：<code>https://github.com/walkxcode/dashboard-icons/blob/main/png/python.png?raw=true</code><br><img src="https://user-images.githubusercontent.com/35327600/220243495-3daabdd1-79bf-42d9-a819-375c763719de.png"></p><p>配置完成后，点击 “APPLY” 按钮更新应用配置，待完成后在 Docker 界面就能看到图标由原本的问号，变为刚在填充的链接所展示的 python 图标了。<br><img src="https://user-images.githubusercontent.com/35327600/220243941-f6dc6ec8-7df4-4cb9-a83b-39ec20738bdf.png"></p><p>方法一操作简单，直接在 WebUI 中进行配置即可。但是也有朋友想用本地自己制作的个性化图标，一种方法就是将图标上传到图床，然后使用图床链接进行配置。如果是具有个人版权的图标，不想上传到公共图床或者网络上，同时也不想自建图床，因为自建图床的学习成本相对较高，那么有没有其他办法进行修改配置呢？请看方法二——本地存储图标配置。</p><h3 id="1-2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）"><a href="#1-2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）" class="headerlink" title="1.2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）"></a>1.2、方法二：本地存储图标图片并配置（需使用命令行操作，不会的朋友请尽量使用方法一）</h3><p><mark>再次重申一下，方法二需要使用命令行操作，不会的朋友请尽量使用方法一，避免对系统本身造成无法修复的损害</mark>。</p><ul><li><p>首先我们先将图标下载到本地（因为我本地没有 Python 的图标，所以此处需要下载，如果本地已经有对应图标，就不需要下载），并存放到 unRAID 的任意共享目录中。</p></li><li><p>将图片名称修改为以下样式 <code>&lt;docker 容器名&gt;-icon.png</code> 。例如此处使用命令 <code>mv python.png python-icon.png</code> 即可完成重命名。<br>  这里我直接采用的 unRAID 后台命令行进行操作，也可以直接在windows下进行重命名<br>  <img src="https://user-images.githubusercontent.com/35327600/220259348-6b70c342-98e6-4d57-bade-6e6ee4111d04.png"></p></li><li><p>然后我们通过命令行将重命名后的图标文件拷贝到这个目录：<code>/var/lib/docker/unraid/images</code> 。</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp python-icon.png /var/lib/docker/unraid/images;<br></code></pre></td></tr></table></figure><p>  其实在这个目录下，使用 ls 命令就能发现，所有 docker 容器的图标都被存放在这个目录底下。<br>  此时 docker 的图标还未生效，刷新界面后仍然显示的是灰底的问号。</p></li><li><p>下一步，我们需要去修改 docker 容器的配置。和<strong>方法一</strong>一样，打开高级配置，找到 “Icon URL” 配置项，但是此时<font color=red>不需要填充真实的链接，随意填入内容即可</font>。这是为了告诉 unRAID 系统，这个 docker 容器是有图标的，你得给我显示出来。<br>  但是为什么可以填充随意内容呢？结合上一步中在目录 <code>/var/lib/docker/unraid/images</code> ，我们不难猜到，unRAID 只是根据 “Icon URL” 中的链接去下载图标到特定目录，然后根据 docker 容器的命名和图标文件的命名进行匹配和展示的。由于我们自行将图标重命名并且存放到了指定位置，所以 unRAID 系统自然能进行匹配和展示了。</p><p>  <img src="https://user-images.githubusercontent.com/35327600/220262561-88362131-b355-498c-8193-899e7bc8564d.png"></p><p>  填充完成后，还是老样子，点击下方 “APPLY” 按钮，此时你会发现图标已经变成你自定义的样子了。</p><p>  <img src="https://user-images.githubusercontent.com/35327600/220262946-6d53e1b0-5197-4e09-b79e-a4a96aa2ccb5.png"></p></li></ul><h2 id="二、自定义虚拟机图标"><a href="#二、自定义虚拟机图标" class="headerlink" title="二、自定义虚拟机图标"></a>二、自定义虚拟机图标</h2><p>unRAID 提供的虚拟机图标类型较少，可能无法满足部分朋友的需要，此时也可通过自定义的方式进行配置。配置方法十分简单，下面一起来看下。</p><p>注意：虚拟机的配置修改需要在虚拟机处于关机状态下进行。</p><ol><li>第一步，打开虚拟机配置编辑，点击右上角的 “FORM VIEW”，打开 “XML VIEW” 模式<br> <img src="https://user-images.githubusercontent.com/35327600/220265145-e9d995dd-acd7-46fa-b717-b205d76de807.png"></li><li>按下键盘的 <code>Ctrl</code> + <code>F</code> 键，在弹出的搜索框中输入 “icon”，并回车进行搜索，找到 XML 文件中对应的字样<br> <img src="https://user-images.githubusercontent.com/35327600/220266149-ece8dd67-c4a1-4b5f-9111-a50b7999b615.png"></li><li>将下划线部分 <code>icon=&quot;/mnt/user/domains/DSM7.1/synology_icon.png&quot;</code> 双引号中的内容，修改为你自定义虚拟机图标的绝对路径。图标存放位置不限。<blockquote><p>图标文件的绝对路径，以存在位置为 unRAID 上创建的共享路径为例，可以参考这样修改：&#x2F;mnt&#x2F;user&#x2F;&lt;共享路径&gt;。将尖括号内的路径修改为图标在共享目录下的路径即可。以上文为例，我的共享目录是 domains，并在 domains 下创建了 DSM7.1 的子目录，图标存放在子目录中，因此绝对路径就是：&#x2F;mnt&#x2F;user&#x2F;domains&#x2F;DSM7.1&#x2F;synology_icon.png</p></blockquote></li><li>点击下方 “UPDATE” 按钮后即可生效<br> <img src="https://user-images.githubusercontent.com/35327600/220266951-c1cf9a8d-e093-4de1-a11d-f7cf9434d1ac.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>docker</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个“size_type”引发的Bug</title>
    <link href="/2023/02/21/%E4%B8%80%E4%B8%AA%E2%80%9Csize-type%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84Bug/"/>
    <url>/2023/02/21/%E4%B8%80%E4%B8%AA%E2%80%9Csize-type%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84Bug/</url>
    
    <content type="html"><![CDATA[<h1 id="一个“size-type”引发的Bug"><a href="#一个“size-type”引发的Bug" class="headerlink" title="一个“size_type”引发的Bug"></a>一个“size_type”引发的Bug</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">10</span>&#125;;<br>  <span class="hljs-comment">// 这是一个极端示例</span><br>  <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (pos &lt;= v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;pos &lt;= v.size() - 2&quot;</span> &lt;&lt; endl;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;pos &gt; v.size() - 2&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察上述示例代码，请回答出程序输出内容是什么？答案是 “pos &lt;&#x3D; v.size() - 2”，还是 “pos &gt; v.size() - 2” 呢？</p><p>可能有的人和我一样，第一反应是 <code>std::vector v</code> 中只有一个元素，因此 <code>v.size() == 1</code>，那 <code>0</code> 和 <code>1 - 2</code> 比较大小，肯定是结果是 “&gt;” 嘛。但是程序运行结果却告诉我们，这里输出的内容是 <code>pos &lt;= v.size() - 2</code> !</p><p>在 Ubuntu20.04 和 Debian10.2.1 中进行测试，结果均为 <code>pos &lt;= v.size() - 2</code>。运行结果如下</p><p><img src="https://user-images.githubusercontent.com/35327600/218906559-3314a6d2-d277-45a6-b50c-d9005bd3f496.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/218907216-e6132f30-a3e5-4ed8-8e52-63a242cc8242.png"></p><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>既然运行结果是 <code>pos &lt;= v.size() - 2</code>，那我们把这个 “&lt;&#x3D;” 号左右两边的值打印出来看看，到底是否与我们认为的 <code>pos == 0</code> 和 <code>v.size() - 2 == -1</code> 的结论一致。将日志输出行修改一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><span class="hljs-keyword">if</span> () &#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;pos[&quot;</span> &lt;&lt; pos &lt;&lt; <span class="hljs-string">&quot;] &lt;= v.size() - 2[&quot;</span> &lt;&lt; v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;]&#x27;</span> &lt;&lt; endl;<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>再次编译执行，结果如下：</p><p><img src="https://user-images.githubusercontent.com/35327600/218909328-2a63cad0-6eae-4bef-9529-bea27192ef65.png"></p><p>在控制台输出打印中可以看到，表达式 <code>v.size() - 2</code> 并非像我们认为的那样等于 “1 - 2 &#x3D;&#x3D; -1”，而是一个非常大的数值。其实到这里，有一定经验的程序员已经大概知道这是为什么了。负数，巨大数值，根据这两个因素基本可以确定是<font color=red>有符号类型（-1）被隐式转换成了无符号类型导致的溢出</font>！</p><p>这个问题，具体情况，我们可以通过gdb进行反汇编调试来仔细跟踪一下。</p><blockquote><p>真正的地址需要程序运行起来之后才能正确反汇编出来，否则反汇编出来的是偏移地址。</p></blockquote><p>先设置一个程序入口断点，确保程序已运行，我们在 main 函数的入口设置一个断点 <code>b *main</code>，并运行命中断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b *main<br>Breakpoint 1 at 0x11f5: file ./size_t.cc, line 7.<br>(gdb) r<br>Starting program: /home/openwrt/tmp/size_t/unittest_size_t<br><br>Breakpoint 1, main (argc=1, argv=0x11bf) at ./size_t.cc:7<br>7       int main(int argc, char* argv[]) &#123;<br>(gdb)<br><br></code></pre></td></tr></table></figure><p>然后再确定一下 if 这个判断语句的地址范围和反汇编内容。在 gdb 模式下输入 <code>disas /m main</code> :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) disas /m main<br>Dump of assembler code for function main(int, char**):<br>7       int main(int argc, char* argv[]) &#123;<br>=&gt; 0x00005555555551f5 &lt;+0&gt;:     push   %rbp<br><br>......<br><br>11        if (pos &lt;= v.size() - 2) &#123;<br>   0x0000555555555261 &lt;+108&gt;:   mov    -0x24(%rbp),%eax<br>   0x0000555555555264 &lt;+111&gt;:   movslq %eax,%rbx<br>   0x0000555555555267 &lt;+114&gt;:   lea    -0x50(%rbp),%rax<br>   0x000055555555526b &lt;+118&gt;:   mov    %rax,%rdi<br>   0x000055555555526e &lt;+121&gt;:   call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>   0x0000555555555273 &lt;+126&gt;:   sub    $0x2,%rax<br>   0x0000555555555277 &lt;+130&gt;:   cmp    %rax,%rbx<br>   0x000055555555527a &lt;+133&gt;:   setbe  %al<br>   0x000055555555527d &lt;+136&gt;:   test   %al,%al<br>   0x000055555555527f &lt;+138&gt;:   je     0x5555555552f5 &lt;main(int, char**)+256&gt;<br><br>......<br>(gdb)<br><br></code></pre></td></tr></table></figure><p>我们先看其中这一段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x000055555555526e &lt;+121&gt;:   call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>0x0000555555555273 &lt;+126&gt;:   sub    $0x2,%rax<br>0x0000555555555277 &lt;+130&gt;:   cmp    %rax,%rbx<br></code></pre></td></tr></table></figure><p>这里第一个 call 语句中，我们可以看到调用了 <code>std::vector::size()</code> 的方法，我们将断点设置在这一处 <code>b *0x000055555555526e</code>，并执行 continue，直至命中断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b *0x000055555555526e<br>Breakpoint 2 at 0x55555555526e: file ./size_t.cc, line 11.<br>(gdb) c<br>Continuing.<br><br>Breakpoint 2, 0x000055555555526e in main (argc=1, argv=0x7fffffffe4a8)<br>    at ./size_t.cc:11<br>11        if (pos &lt;= v.size() - 2) &#123;<br>(gdb) x/3i $pc<br>=&gt; 0x55555555526e &lt;main(int, char**)+121&gt;:<br>    call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>   0x555555555273 &lt;main(int, char**)+126&gt;:      sub    $0x2,%rax<br>   0x555555555277 &lt;main(int, char**)+130&gt;:      cmp    %rax,%rbx<br><br></code></pre></td></tr></table></figure><p>观察 pc 指针，已经运行到断点所在地址，从这三句汇编语句中，我们不难看出寄存器 rax 中存放的是表达式 <code>v.size() - 2</code> 的结果，rbx 中则存放的是变量 pos 的值。我们进行单步调试，并在每次步进后查看这两个寄存器的值和寄存器标志位的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) ni  ## call   0x5555555554d4 &lt;_ZNKSt6vectorIiSaIiEE4sizeEv&gt;<br>11        if (pos &lt;= v.size() - 2) &#123; <br>(gdb) i r rax rbx eflags<br>rax            0x1                 1<br>rbx            0x0                 0<br>eflags         0x202               [ IF ]<br>(gdb) ni  ## sub    $0x2,%rax<br>11        if (pos &lt;= v.size() - 2) &#123;<br>(gdb) i r rax rbx eflags<br>rax            0xffffffffffffffff  -1<br>rbx            0x0                 0<br>eflags         0x297               [ CF PF AF SF IF ]<br>(gdb) x/3i $pc<br>=&gt; 0x555555555277 &lt;main(int, char**)+130&gt;:      cmp    %rax,%rbx<br>   0x55555555527a &lt;main(int, char**)+133&gt;:      setbe  %al<br>   0x55555555527d &lt;main(int, char**)+136&gt;:      test   %al,%al<br>(gdb) ni  ## cmp    %rax,%rbx<br>0x000055555555527a      11        if (pos &lt;= v.size() - 2) &#123;<br>(gdb) i r rax rbx eflags<br>rax            0xffffffffffffffff  -1<br>rbx            0x0                 0<br>eflags         0x213               [ CF AF IF ]<br>(gdb)<br><br></code></pre></td></tr></table></figure><p>通过记录标志位，我们不难发现，当执行 <code>sub $0x2 %rax</code> 时，标志位 CF 被置位了，这代表了<font color=red>这次的减法运算，是无符号类型数的减法运算，并且存在借位，即溢出</font>，同时 SF 也被置位了，表明当前的减法计算结果是一个负数（由于计算机中存放的数据以其补码形式存放，所以此处 0xffffffffffffffff 为补码，转换为源码就是 0x8000000000000001，十进制表示就是-1）。但是在后续的 <code>cmp %rax %rbx</code> 语句中，<mark>标志位 CF 再次被置位，也就意味着计算机将 rax 和 rbx 中的值都按照无符号数进行了减法计算</mark> <code>0x0 - 0xffffffffffffffff</code> 自然产生了借位的情况，所以计算机自然而然地认为 “0 &lt; -1”！</p><p>所以问题的根本原因在于计算机执行 cmp 指令时，将原本应该是有符号数 “-1” 当成了无符号数 “0xffffffffffffffff” 进行比较。因此在判断大小时，出现了异常的结果。</p><h2 id="问题跟踪"><a href="#问题跟踪" class="headerlink" title="问题跟踪"></a>问题跟踪</h2><p>那为什么计算机会将 “-1” 当成是无符号数呢，我们来看一下 <code>std::vector::size()</code> 方法的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><p>因此 <code>v.size()</code> 返回的 1 是 size_type 类型的。这个类型在 cplusplus 网站中，被释义为无符号整型，通常境况下同 size_t。到这里就真相大白了，由于 <code>v.size()</code> 这个方法返回了一个无符号整形结果，因此后续的减法运算和大小比较中，C++ 默认对此进行了隐式转换有符号整型转换为无符号整形，所有的运算都变成了无符号数的运算（对于无符号整形作减法的溢出，编译器不会做出任何警告）。</p><p>结合上文中通过反汇编调试得到的结论，证明问题的原因和最初我们的猜想是一致的。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>既然知道了问题的根本原因，那么解决方法也相对简单，只要保证进行运算操作时类型转换是合法的即可，</p><p>因为示例代码中 <code>v.size()</code> 获得的无符号整形较小，因此我们可以将其直接显式转换为有符号整形：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br>  <span class="hljs-keyword">if</span> (pos &lt;= (<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>) &#123;<br>...<br></code></pre></td></tr></table></figure><p>但是这并不意味着只要显式地转换数据类型，就不会发生错误了。比如负数转换成无符号数，无符号数的最大值转换成有符号数，这两种就是典型的类型转换导致数值溢出的问题。</p><p>我们应该在不得不进行数据类型转换前，保证转换后不会出现溢出的问题！</p>]]></content>
    
    
    <categories>
      
      <category>踩坑日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>C++</tag>
      
      <tag>Bug</tag>
      
      <tag>溢出</tag>
      
      <tag>类型转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令简记</title>
    <link href="/2023/02/21/Linux%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/"/>
    <url>/2023/02/21/Linux%E5%91%BD%E4%BB%A4%E7%AE%80%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令简记"><a href="#Linux命令简记" class="headerlink" title="Linux命令简记"></a>Linux命令简记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于部分linux命令使用频率较低，导致遇到时常常忘记命令选项的含义和使用方法，因此在本文中记录linux命令的常用选项和具体使用方法，并对部分命令记录使用实例。</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>常用选项：</p><ul><li>-c: 建立压缩档案</li><li>-x：解压</li><li>-t：查看内容</li><li>-r：向压缩归档文件末尾追加文件</li><li>-u：更新原压缩包中的文件</li><li>-f: 使用档案名字，这个参数是最后一个参数，后面只能接档案名</li></ul><p>可选参数：</p><ul><li>-z：有gzip属性的</li><li>-j：有bz2属性的</li><li>-Z：有compress属性的</li><li>-v：显示所有过程</li><li>-O：将文件解开到标准输出</li></ul><h3 id="压缩、解压"><a href="#压缩、解压" class="headerlink" title="压缩、解压"></a>压缩、解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩 file.tar.gz：压缩档案名称；file：待压缩目录</span><br>tar -czvf file.tar.gz ./file<br><br><span class="hljs-comment"># 解压</span><br>tar -xzvf file.tar.gz<br></code></pre></td></tr></table></figure><h3 id="加密压缩、解压"><a href="#加密压缩、解压" class="headerlink" title="加密压缩、解压"></a>加密压缩、解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加密压缩</span><br><span class="hljs-comment"># 使用 --exclude 选项排除指定目录</span><br>tar -czvf - --exclue=<span class="hljs-string">&quot;file/exclude_dir&quot;</span> ./file | openssl enc -e -des3 -salt -k P@ssw0rd | <span class="hljs-built_in">dd</span> of=file.tar.gz.des3<br><br><span class="hljs-comment"># 解压</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=file.tar.gz.des3 | openssl enc -d -des3 -salt -k P@ssw0rd | tar -xzvf -<br></code></pre></td></tr></table></figure><h3 id="分卷加密压缩、解压"><a href="#分卷加密压缩、解压" class="headerlink" title="分卷加密压缩、解压"></a>分卷加密压缩、解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 分卷加密压缩</span><br><span class="hljs-comment"># split 参数</span><br><span class="hljs-comment"># -b, --bytes=SIZE, 指定每个分割文件的大小，单位有K, M, G, P等</span><br><span class="hljs-comment"># -d, --numeric-suffixes, 指定分割文件的后缀为数字</span><br><span class="hljs-comment"># -a, --suffix-length=N, 指定分割文件数字后缀的长度，如果-a 1，则后缀为*.1，*.2；如果-a 2，则后缀为*.01，*.02</span><br><span class="hljs-comment"># -c, --line-bytes=SIZE, 指定每行最大的字节数</span><br><span class="hljs-comment"># -l, --lines=NUMBER, 指定每个文件最大的行数</span><br>tar -czvf - --exclue=<span class="hljs-string">&quot;file/exclude_dir&quot;</span> ./file | openssl enc -e -des3 -salt -k P@ssw0rd | <span class="hljs-built_in">split</span> -b 200m -d -a 2 - file.tar.gz.des3.<br><br><span class="hljs-comment"># 解压</span><br><span class="hljs-built_in">cat</span> file.tar.gz.des3.* | openssl enc -d -des3 -salt -k P@ssw0rd | tar -zxvf -<br></code></pre></td></tr></table></figure><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><ol><li><p>–exclude参数报错</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar: The following options were used after any non-optional arguments <span class="hljs-keyword">in</span> archive create or update mode.  These options are positional and affect only arguments that follow them.  Please, rearrange them properly.<br></code></pre></td></tr></table></figure><p> 这是因为不同版本的tar，<code>--exclude</code>选项添加的位置存在差异。当tar的版本小于1.30时，该选项可以放在待压缩目录之后；若tar版本为1.30时，<code>--exclude</code>需要添加在待压缩目录之前。如下所示</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tar --version tar (GNU tar) 1.30</span><br>tar -czvf file.tar.gz --exclude=<span class="hljs-string">&quot;file/exclude_dir&quot;</span> ./file<br><br><span class="hljs-comment"># tar --version tar (GNU tar) 1.26</span><br>tar -czvf file.tar.gz ./file --exclude=<span class="hljs-string">&quot;file/exclude_dir&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>常用选项：</p><ul><li>-c 或 –count : 计算符合样式的列数。</li><li>-h –no-filename : 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。 </li><li>-H –with-filename : 在显示符合范本样式的那一列之前，标示该列的文件名称。</li><li>-i 或 –ignore-case : 忽略字符大小写的差别。</li><li>-E 或 –extended-regexp : 将样式为延伸的正则表达式来使用。</li><li>-o 或 –only-matching : 只显示匹配PATTERN 部分。</li><li>-v 或 –invert-match : 显示不包含匹配文本的所有行。</li><li>-V 或 –version : 显示版本信息。</li><li>–include : 搜索指定的文件</li><li>–exclude : 搜索结果中排除指定文件</li><li>–exclude-from &lt;fileList&gt;: 在搜索结果中排除fileList中的文件，一行一个“pattern”</li></ul><h3 id="多条件与（and），或（or）查询"><a href="#多条件与（and），或（or）查询" class="headerlink" title="多条件与（and），或（or）查询"></a>多条件与（and），或（or）查询</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 与（and）</span><br>grep <span class="hljs-string">&#x27;pattern1&#x27;</span> file | grep <span class="hljs-string">&#x27;pattern2&#x27;</span><br><br><span class="hljs-comment"># 或（or），用法1</span><br>grep -E <span class="hljs-string">&#x27;pattern1|pattern2&#x27;</span> file<br><span class="hljs-comment"># 或（or），用法2</span><br>grep <span class="hljs-string">&#x27;pattern1\|pattern2&#x27;</span> file<br><span class="hljs-comment"># 或（or），用法3</span><br>egrep <span class="hljs-string">&#x27;pattern1|pattern2&#x27;</span> file<br><br></code></pre></td></tr></table></figure><h3 id="输出不包含指定内容的行，（非（NOT）查询）"><a href="#输出不包含指定内容的行，（非（NOT）查询）" class="headerlink" title="输出不包含指定内容的行，（非（NOT）查询）"></a>输出不包含指定内容的行，（非（NOT）查询）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出不包含‘pattern’的行</span><br>grep -v <span class="hljs-string">&#x27;pattern&#x27;</span> file<br></code></pre></td></tr></table></figure><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><ol><li>根据可执行文件名称和运行参数，过滤输出进程id <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps ef | grep -i <span class="hljs-string">&#x27;$&#123;process_name&#125;&#x27;</span> | grep -i <span class="hljs-string">&#x27;$&#123;excute_param&#125;&#x27;</span> | grep -v <span class="hljs-string">&#x27;grep&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>dd 命令用于读取、转换并输出数据。可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p><p>格式：<br><code>dd [operand]</code><br><code>dd option</code></p><p>常用参数：</p><ul><li>bs&#x3D;BYTES：同时设置输入&#x2F;输出的块大小为BYTES字节</li><li>count&#x3D;N：仅拷贝N个block块，块大小等于ibs指定的字节数</li><li>cbs&#x3D;BYTES：一次转换BYTES个字节，即指定转换缓冲区大小</li><li>ibs&#x3D;BYTES：一次读取BYTES个字节，即指定读取的一个块大小为BYTES字节</li><li>obs&#x3D;BYTES：一次输出BYTES个字节，即指定输出的一个块大小为BYTES字节</li><li>if&#x3D;FILE：输入文件名，默认为标准输入</li><li>iflag&#x3D;FLAGS</li><li>of&#x3D;FILE：输出文件名，默认为标准输出</li><li>oflag&#x3D;FLAGS</li><li>skip&#x3D;N：从输入文件开头跳过N个block块后开始复制</li><li>seek&#x3D;N：从输出文件开头跳过N个block块后开始复制</li><li>status&#x3D;LEVEL：打印到stderr的信息级别<ul><li>‘node’：    抑制错误消息之外的所有内容、</li><li>‘noxfer’：  抑制最终的传输统计数据</li><li>‘progress’：显示定期传输统计信息</li></ul></li><li>conv&#x3D;&lt;CONVS KEY WORDS&gt;<ul><li>lcase：把大写字符转换为小写字符</li><li>ucase：把小写字符转换为大写字符</li><li>noerror：出错时不停止</li><li>notrunc：不截断输出文件</li></ul></li></ul><h3 id="与管道符（-）配合读取-x2F-输出文件"><a href="#与管道符（-）配合读取-x2F-输出文件" class="headerlink" title="与管道符（|）配合读取&#x2F;输出文件"></a>与管道符（|）配合读取&#x2F;输出文件</h3><ol><li><p>读取文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配合 grep 查找指定内容</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=./testfile status=none | grep <span class="hljs-string">&#x27;HelloWord&#x27;</span><br></code></pre></td></tr></table></figure><p> <img src="https://user-images.githubusercontent.com/35327600/212609068-f83073cf-06b9-4c73-ad8b-55af99d80d98.png"></p></li><li><p>输出文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将docker image信息写入指定文件</span><br>docker image <span class="hljs-built_in">ls</span> | <span class="hljs-built_in">dd</span> of=./docker_image_info.txt status=none<br></code></pre></td></tr></table></figure><p> <img src="https://user-images.githubusercontent.com/35327600/212609286-2525b883-4bfc-4ac9-a804-09f720f3828e.png"></p></li></ol><h3 id="备份磁盘并恢复"><a href="#备份磁盘并恢复" class="headerlink" title="备份磁盘并恢复"></a>备份磁盘并恢复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 备份</span><br><span class="hljs-comment"># SATA硬盘被挂载在/dev/sda，将该SATA硬盘备份到sda.img中</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/root/sda.img<br><br><span class="hljs-comment"># 恢复</span><br><span class="hljs-comment"># /dev/sda 硬盘出现故障时，将备份的sda.img恢复到指定的sdb盘中去</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/root/sda.img of=/dev/sdb<br><br><span class="hljs-comment"># 复制完整磁盘环境</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/dev/sdc<br></code></pre></td></tr></table></figure><h3 id="压缩备份"><a href="#压缩备份" class="headerlink" title="压缩备份"></a>压缩备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 备份</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda | gzip &gt; /root/sda.img.gz<br><br><span class="hljs-comment"># 恢复</span><br>gzip -dc /root/sda.img.gz | <span class="hljs-built_in">dd</span> of=/dev/sdc<br></code></pre></td></tr></table></figure><h3 id="备份磁盘MBR表"><a href="#备份磁盘MBR表" class="headerlink" title="备份磁盘MBR表"></a>备份磁盘MBR表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 一块磁盘的第一个扇区的 512 个字节所存储的正是这块磁盘的 MBR 信息，我们尝试用 dd 命令备份 MBR：</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda of=/root/sda.mbr.img count=1 bs=512<br><br><span class="hljs-comment"># 恢复</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/root/sda.mbr.img of=/dev/sda<br></code></pre></td></tr></table></figure><h3 id="简单的磁盘读写性能测试"><a href="#简单的磁盘读写性能测试" class="headerlink" title="简单的磁盘读写性能测试"></a>简单的磁盘读写性能测试</h3><p>通过 <code>/dev/null</code> 和 <code>/dev/zero</code> 完成读写性能测试</p><ul><li><code>/dev/null</code>，也叫空设备，小名“无底洞”。任何写入它的数据都会被无情抛弃。</li><li><code>/dev/zero</code>，可以产生连续不断的 null 的流（二进制的零流），用于向设备或文件写入 null 数据，一般用它来对设备或文件进行初始化。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 向磁盘上写入一个大小为1Gb的大文件, 通过计算该命令执行时间，判断磁盘写性能</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file<br><br><span class="hljs-comment"># 读取一个刚才生成的1Gb的文件，通过计算命令执行时间，判断磁盘读取性能</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/root/1Gb.file bs=64k of=/dev/null<br></code></pre></td></tr></table></figure><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Watchdog for Emby Media Server</title>
    <link href="/2023/02/21/Watchdog-for-Emby-Media-Server/"/>
    <url>/2023/02/21/Watchdog-for-Emby-Media-Server/</url>
    
    <content type="html"><![CDATA[<h1 id="Watchdog-for-Emby-Media-Server"><a href="#Watchdog-for-Emby-Media-Server" class="headerlink" title="Watchdog for Emby Media Server"></a>Watchdog for Emby Media Server</h1><h2 id="修订版本"><a href="#修订版本" class="headerlink" title="修订版本"></a>修订版本</h2><p><mark><font color="red">v1.x版本后续将不再更新维护，如有需要请更新使用v2.x版本！！！</font></mark></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>借助python中的看门狗模块（“watchdog”）监视emby媒体库目录，通过电报（telegram）的bot和channel，向频道订阅者推送Emby媒体库中新增影片信息，包括电影和剧集。</p><h2 id="实现说明"><a href="#实现说明" class="headerlink" title="实现说明"></a>实现说明</h2><p>v2.x版本中，删除了原始版本中的xmllint依赖，仅通过python完成所有功能实现。**因此在dockerfile中将基础镜像由<code>ubuntu:latest</code>变更为<code>python:alpine3.17</code>，拉取后镜像体积由231MB减小至69.5MB，体积减少约70%**。</p><p><strong>watchdog_for_Emby</strong> 对 Emby Server 自动影片刮削生成的“xxxx.nfo”文件进行监控。影片新入库后，Emby Server 自动执行刮削生成xml格式的nfo文件，<del>通过xmllint可以解析到部分该影片或者剧集的信息</del>通过“ElementTree”模块解析nfo文件，获取当前影片的基本信息。而影片的封面图，和剧集的详细信息，则需要通过TMDB的api进行查询获取，通过调用”requests.get()”方法完成查询。在按照电报bot的api文档对payload数据组装后，调用”requests.post()”方法推送给bot，由bot发布至对应频道。</p><h2 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h2><ol><li>python3.10及以上版本（v2.x版本中，使用了match..case..语法，仅在3.10及以上版本完成支持）</li><li>python Module: <em>watchdog</em>, <em>requests</em> (cmd: <code>pip3 install watchdog requests</code>)，<em>ElementTree</em></li><li><del>xmllint (os: ubuntu 20.04，cmd: <code>sudo apt-get install libxml2-utils</code>)</del> v2.x版本中已去除此依赖</li></ol><h2 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>BOT_TOKEN</td><td>电报 bot token</td></tr><tr><td>CHAT_ID</td><td>电报频道 chat_id</td></tr><tr><td>TMDB_API</td><td>TMDB api token</td></tr><tr><td>MEDIA_PATH</td><td>Emby 媒体库路径</td></tr><tr><td>LOG_PATH</td><td>&lt;可选&gt;日志文件路径，默认为<code>/var/tmp/overwatch.log</code></td></tr></tbody></table><h2 id="Docker-Run"><a href="#Docker-Run" class="headerlink" title="Docker Run"></a>Docker Run</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=watchdog-emby --restart=unless-stopped \<br>  -v &quot;your media lib&#x27;s host path&quot;:&quot;media lib&#x27;s container path&quot; \<br>  -e BOT_TOKEN=&quot;your telegram bot&#x27;s token&quot; \<br>  -e CHAT_ID=&quot;your telegram channle&#x27;s chat_id&quot; \<br>  -e TMDB_API=&quot;tmdb api token&quot; \<br>  -e MEDIA_PATH=&quot;media lib&#x27;s container path&quot; \<br>  -e LOG_PATH=&quot;log&#x27;s output path&quot; \<br>  b1gfac3c4t/overwatch<br>  <br></code></pre></td></tr></table></figure><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>电影：</p><p><img src="https://user-images.githubusercontent.com/35327600/209752390-4e45180b-d8cc-4378-bd98-c489638f7cb7.png"></p><p>剧集：</p><p><img src="https://user-images.githubusercontent.com/35327600/209752275-bad230b0-97a7-47e5-9a77-081afae7d6cf.png"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li>tmdb api 文档：<a href="https://developers.themoviedb.org/3">https://developers.themoviedb.org/3</a></li><li>telegram bot api 文档：<a href="https://core.telegram.org/bots/api">https://core.telegram.org/bots/api</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Emby</tag>
      
      <tag>Python3.10</tag>
      
      <tag>Watchdog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unraid USB Drive Crack 教程</title>
    <link href="/2023/02/21/Unraid-USB-Drive-Crack-%E6%95%99%E7%A8%8B/"/>
    <url>/2023/02/21/Unraid-USB-Drive-Crack-%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Unraid-USB-Drive-Crack-教程"><a href="#Unraid-USB-Drive-Crack-教程" class="headerlink" title="Unraid USB Drive Crack 教程"></a>Unraid USB Drive Crack 教程</h1><p><strong><font color="red">！！！破解教程仅供学习参考，务必支持正版软件，构建良好的软件版权生态！！！</font></strong></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>由于Unraid OS使用硬盘阵列的形式构建存储池，能尽可能利用硬盘空间，并且可以通过创建校验盘保护数据，因此Unraid OS也不失为一个NAS系统的好选择。</p><p>但是因为试用版需要在联网环境下完成授权，导致处于内网环境的NAS机器无法使用。网上虽然有大量的开心版，不过大多是通过第三方提供的一个keyMaker.exe对USB的GUID生成一个key文件进行破解，总感觉不是很安全。</p><p>在爬了无数帖子后，终于在老毛子的一个论坛中找到了每个人都能轻松”<strong>转正</strong>“，且安全的方法！论坛连接放在文末，近期论坛中已经释出6.11版本。</p><h2 id="二、准备工具"><a href="#二、准备工具" class="headerlink" title="二、准备工具"></a>二、准备工具</h2><ol><li>一个U盘</li><li>官方usb引导创建工具：<strong>Unraid.USB.Creator.Win32-2.1.exe</strong>（官网下载即可）</li><li>一个可以使用gcc的编译环境（Debian、Ubuntu、Centos等，虚拟机，云主机都可以）（windos下其实也可以，但是环境配置相对麻烦，不如直接使用虚拟机创建前面提到的三个linux系统）</li><li>一份源码构建密钥的源码：<code>https://github.com/mysll/unraid_test.git</code></li></ol><h2 id="三、Crack-系统盘破解"><a href="#三、Crack-系统盘破解" class="headerlink" title="三、Crack 系统盘破解"></a>三、Crack 系统盘破解</h2><h3 id="3-1、制作系统盘"><a href="#3-1、制作系统盘" class="headerlink" title="3.1、制作系统盘"></a>3.1、制作系统盘</h3><p>通过在官网下载的USB引导创建工具，制作官方系统盘即可，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/209258446-6d68256c-f8bf-4275-a102-13b0c288f0d3.png"></p><p>制作过程不在这里进行赘述了，B站大佬<a href="https://space.bilibili.com/28457/channel/seriesdetail?sid=896368">司波图</a>的Unraid系列教程中介绍的很详细了，不了解的朋友可以移步观看。</p><p>这里有几个需要注意的点：</p><ol><li><p>由于服务器在国外，直接在线下载可能会很慢，或者没有速度，也可以单独下载官网中的zip包，然后在图中第一步中选择”Local Zip”；</p></li><li><p>图中第二步”Select your USB Flash device”，注意是否是待制作的U盘，确认后将USB名称后面中括号内的一串数字记录下，如图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/209281193-0a968f78-8add-4d06-97cb-c80b44517b2a.png"></p><p>这是U盘的<strong>GUID</strong>，在后续破解中还需使用到。（如果忘记保存了，也没关系，重新打开这个制作工具就能再次看到了)</p></li><li><p>点击“<strong>Write</strong>”后会提示当前选中U盘会被格式化，如果没选错的话，OK就行；</p></li></ol><p>等待进度条满后，系统盘就制作完成了。<font color="blue">如果在制作系统盘时，选择了”Local Zip”，那么接下来还需要注意以下一点</font>:</p><blockquote><p>打开U盘目录，找到根目录下“make_bootable.bat”文件，右键点击后，选择管理员模式运行</p></blockquote><p>完成以上步骤后，暂时先不要拔下U盘，后续还需要对内部的文件进行操作。</p><h3 id="3-2、制作密钥"><a href="#3-2、制作密钥" class="headerlink" title="3.2、制作密钥"></a>3.2、制作密钥</h3><p>制作密钥过程需要在linux环境中进行（如果你的windows系统也部署了gcc，那也可以在windows下操作）。利用windows自带的“Hyper-V”虚拟机搭建一个Ubuntu非常的简单方便，不会的朋友可自行百度教程。下面我以Ubuntu为例介绍密钥的制作过程。</p><ol><li><p>首先将准备工具中第4点提到的源码下载下来，依次执行以下两条命令：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/mysll/unraid_test.git ./Unraid_test<br>cd Unraid_test<br></code></pre></td></tr></table></figure><p> <img src="https://user-images.githubusercontent.com/35327600/209284969-1ccd4d06-b0ad-4129-a746-3e7d487923ae.png"><br> 当然也可以不用以上命令，直接点击源码链接，去github网站上进行下载。（此处也有可能有网络问题，存在网络问题是，请百度关键词“github 下载失败”）</p></li><li><p>进入源码目录后，执行命令 <code>gcc -fPIC -shared unraid.c -o BTRS.key</code>，会一点C语言或者C++在linux环境编译的话，就能明白这一步在做什么，不明白也没关系，无脑执行即可。<br><font color="red">此时会在当前目录下生成一个名为“<strong>BTRS.key</strong>”的文件，你猜的没错，这就是我们所需要的密钥文件</font></p></li><li><p>将第二步中生成的“<strong>BTRS.key</strong>”拷贝到U盘的“<strong>config</strong>”目录下</p><p> <img src="https://user-images.githubusercontent.com/35327600/209305975-9f6ec553-e639-4fd3-8170-6584aa525047.png"></p></li><li><p>在config目录下找到一个名为“<strong>go</strong>”的文件，先将该文件备份一下，然后用以下内容替换原文件的内容</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">---------修改以下三项内容，只需要修改等号右边内容，左边不要变更--------- <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">GUID 将单引号内的内容替换成你自己U盘对应GUID</span><br>export UNRAID_GUID=&#x27;xxxx-xxxx-xxxx-xxxxxxxxxxxx&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">NAME 随便填</span><br>export UNRAID_NAME=unraid_test<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这是unix的一个时间戳，百度关键词“unix时间戳”，找一个转换网站，将当前时间转换为时间戳后填入，下面有示例</span><br>export UNRAID_DATE=1658129986<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-----------不要修改！！！不要修改！！！不要修改！！！------------------ <span class="hljs-comment">#</span></span><br>export UNRAID_VERSION=Pro<br>LD_PRELOAD=/boot/config/BTRS.key /usr/local/sbin/emhttp &amp;<br></code></pre></td></tr></table></figure></li></ol><p>  时间戳转换示例，<a href="https://tool.lu/timestamp/">在线转换工具</a>：</p><p>  <img src="https://user-images.githubusercontent.com/35327600/209291869-4c00d313-2e98-414c-b755-e2f48ab44e50.png"></p><p>此时可以拔下U盘，然后插到你的NAS上，愉快的使用啦~~~</p><p>当然了，还是希望有能力的朋友支持正版，毕竟这种开心版是否在后续使用中还是有所缺陷，例如强大的my_server就无法使用。更何况软件版权生态也是需要大家共同维护的。</p><h2 id="四、Backup-系统盘备份"><a href="#四、Backup-系统盘备份" class="headerlink" title="四、Backup 系统盘备份"></a>四、Backup 系统盘备份</h2><p>由于Unraid的系统文件完全被存储在U盘中，并且十分的轻量，因此备份变得非常方便。</p><p>在APP市场中下载“<strong>User Scripts</strong>”插件，通过定时执行备份脚本，实现定期备份系统盘的功能。</p><p><img src="https://user-images.githubusercontent.com/35327600/209297717-10fcb3ff-b65c-48fe-a796-a7a419912c20.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/209298058-adb48d23-c188-4000-b24a-0619df42ebb2.png"></p><p>创建完成后点击脚本前的小齿轮，选择”<strong>EDIT SCRIPT</strong>“，将下方内容贴入，然后点击”<strong>SAVE CHANGES</strong>即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>CUR_TIME=$(date &quot;+%Y%m%d%H%M%S&quot;)<br>BACKUP_FILE=&quot;unraid_flash_backup_$&#123;CUR_TIME&#125;.tar.gz&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将等号后面的路径修改为你自己的备份路径</span><br>BACKUP_PATH=&quot;/your/back/up/path/&quot;<br><br>tar -czvf $&#123;BACKUP_PATH&#125;$&#123;BACKUP_FILE&#125; /boot;<br></code></pre></td></tr></table></figure><p>保存后可以点击 “RUN SCRIPT” 测试一下备份文件是否成功创建。注意不可关闭运行后的弹窗，否则脚本会中止执行。</p><blockquote><p>这里还有更进阶的玩法，可以结合阿里云的webdav和rclone挂载，将备份包上传至网盘中，并删除过期备份包，避免占用过多网盘空间，这个有需要的话，可以后面再出一篇详细教程。</p></blockquote><h2 id="五、Rescure-系统盘恢复"><a href="#五、Rescure-系统盘恢复" class="headerlink" title="五、Rescure 系统盘恢复"></a>五、Rescure 系统盘恢复</h2><p>由于Unraid OS的完整系统都存在U盘中，因此当系统配置出现问题，导致无法进入引导，无法进入GUI界面时，并不会影响阵列！</p><p>因此系统盘的恢复，比备份更简单。只需要使用官方的USB制作工具创建一个官方的系统盘，然后将备份包中的config目录完全拷贝至当前的U盘内即可！是不是超级，非常，极其简单和方便！！！</p><p><mark>当然还有一个注意点，如果U盘更换了，config目录中的”<strong>go</strong>“文件中的GUID也需要同步修改一下。千万别忘记啦！</mark></p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oh-my-posh安装教程</title>
    <link href="/2023/02/21/oh-my-posh%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2023/02/21/oh-my-posh%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="oh-my-posh安装教程"><a href="#oh-my-posh安装教程" class="headerlink" title="oh-my-posh安装教程"></a>oh-my-posh安装教程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>github: <a href="https://github.com/JanDeDobbeleer/oh-my-posh">https://github.com/JanDeDobbeleer/oh-my-posh</a></li><li>docs:   <a href="https://ohmyposh.dev/">https://ohmyposh.dev/</a></li></ul><p>docs中有详细的安装和使用说明，下文中有不明白的可以移步官方文档自行学习使用~</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下面以新安装的x86_64的debian环境进行举例</p><p><code>Linux debian 5.10.0-19-amd64 #1 SMP Debian 5.10.149-2 (2022-10-21) x86_64 GNU/Linux</code></p><p>针对内网和非root用户进行安装，避免污染其他用户的使用环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 获取posh可执行文件，内网环境可以直接从github中下载后，拷贝到用户下指定目录</span><br><span class="hljs-comment"># 当前命令中下载的可执行文件是基于amd64架构的，根据自己的系统架构选择下载</span><br><span class="hljs-built_in">mkdir</span> -p ~/oh-my-posh<br>wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-amd64 -O ~/oh-my-posh/posh;<br><span class="hljs-built_in">wait</span>;<br><span class="hljs-built_in">chmod</span> +x ~/oh-my-posh/posh;<br><br><span class="hljs-comment"># 下载主题</span><br><span class="hljs-built_in">mkdir</span> -p ~/oh-my-posh/.poshthemes;<br>wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/oh-my-posh/.poshthemes/themes.zip;<br><span class="hljs-built_in">wait</span>;<br>unzip -q ~/oh-my-posh/.poshthemes/themes.zip -d ~/oh-my-posh/.poshthemes;<br><span class="hljs-built_in">wait</span>;<br><span class="hljs-built_in">rm</span> ~/oh-my-posh/.poshthemes/themes.zip -vf;<br><span class="hljs-built_in">chmod</span> u+rw ~/oh-my-posh/.poshthemes/*.omp.*;<br><br><span class="hljs-comment"># 向~/.profile，或者~/.bashrc，或者~/.bash_profile中写入posh初始化命令，下面命令中以~/.profile为例，并指定主题 montys.omp.json</span><br>sed -i <span class="hljs-string">&#x27;$a eval &quot;$(~/oh-my-posh/posh init bash --config ~/oh-my-posh/.poshthemes/montys.omp.json)&quot;&#x27;</span> ~/.profile;<br><br><span class="hljs-comment"># 重新启用bash</span><br><span class="hljs-built_in">source</span> ~/.profile;<br><br><span class="hljs-comment"># 若安装了zsh，则最后两行命令用下面两行替代</span><br><span class="hljs-comment"># 向~/.zshrc中写入posh初始化命令，并指定主题 montys.omp.json</span><br><span class="hljs-comment">#sed -i &#x27;$a eval &quot;$(~/oh-my-posh/posh init zsh --config ~/oh-my-posh/.poshthemes/montys.omp.json)&quot;&#x27; ~/.zshrc;</span><br><span class="hljs-comment"># 应用新的.zshrc文件</span><br><span class="hljs-comment">#exec zsh;</span><br><br></code></pre></td></tr></table></figure><h2 id="示例动画"><a href="#示例动画" class="headerlink" title="示例动画"></a>示例动画</h2><p><img src="https://user-images.githubusercontent.com/35327600/211761346-9d91a9ad-bc18-4128-8cf4-49a91ebfcb0e.gif"></p><h2 id="montys-omp-json主题微调"><a href="#montys-omp-json主题微调" class="headerlink" title="montys.omp.json主题微调"></a>montys.omp.json主题微调</h2><p>由于montys主题默认会在powerline中输出完整的路径，当路径层级较深时，powerline显示就太长了，因此参考文档进行了微调。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-comment">diff --git a/themes/montys.omp.json b/themes/montys.omp.json</span><br><span class="hljs-comment">index c7797e88..c8eeb6c4 100644</span><br><span class="hljs-comment">--- a/themes/montys.omp.json</span><br><span class="hljs-comment">+++ b/themes/montys.omp.json</span><br><span class="hljs-meta">@@ -17,10 +17,11 @@</span><br>           &quot;foreground&quot;: &quot;#ffffff&quot;,<br>           &quot;powerline_symbol&quot;: &quot;\ue0b0&quot;,<br>           &quot;properties&quot;: &#123;<br><span class="hljs-deletion">-            &quot;folder_icon&quot;: &quot;\uf115&quot;,</span><br><span class="hljs-addition">+            &quot;folder_icon&quot;: &quot;\uf07c&quot;,</span><br>             &quot;folder_separator_icon&quot;: &quot;\\&quot;,<br>             &quot;home_icon&quot;: &quot;\uf7db&quot;,<br><span class="hljs-deletion">-            &quot;style&quot;: &quot;full&quot;</span><br><span class="hljs-addition">+            &quot;style&quot;: &quot;agnoster_short&quot;,</span><br><span class="hljs-addition">+            &quot;max_depth&quot;: 3</span><br>           &#125;,<br>           &quot;style&quot;: &quot;powerline&quot;,<br>           &quot;template&quot;: &quot; &lt;#000&gt;\uf07b \uf553&lt;/&gt; &#123;&#123; .Path &#125;&#125; &quot;,<br></code></pre></td></tr></table></figure><p>效果对比：</p><p>before：</p><p><img src="https://user-images.githubusercontent.com/35327600/211757664-172072e7-7c19-49e0-b900-7c6975471931.png"></p><p>after:</p><p><img src="https://user-images.githubusercontent.com/35327600/211762075-d3a46f69-5bf8-4dfe-a15a-e39ff4ca9198.png"></p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Shell</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>Debain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows10挂载Webdav</title>
    <link href="/2023/02/21/Windows10%E6%8C%82%E8%BD%BDWebdav/"/>
    <url>/2023/02/21/Windows10%E6%8C%82%E8%BD%BDWebdav/</url>
    
    <content type="html"><![CDATA[<h1 id="windows10挂载webdav"><a href="#windows10挂载webdav" class="headerlink" title="windows10挂载webdav"></a>windows10挂载webdav</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>当前市面上大部分的网盘，可以挂载到 “<strong>Alist</strong>“ 中。Alist 又支持 webdav协议。这就意味着通过 Alist 的 webdav 服务，我们可以直接将网盘挂载到本地，类似于本地磁盘一样读写网盘中文件。</p><p>但是在本地挂载的过程中，无论是添加网络位置，还是映射网络驱动器，都会出现文件路径不对、网络错误无法访问等错误，如下所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/215680157-9de51400-15cc-4d22-9d01-5e6bf8411e8f.png"></p><p><img src="https://user-images.githubusercontent.com/35327600/215675986-ba71818f-88cb-4151-86b9-aae6ee69aa22.png"></p><p>本文将简单介绍如何在Windows环境下挂载本地webdav。</p><h2 id="二、问题原因"><a href="#二、问题原因" class="headerlink" title="二、问题原因"></a>二、问题原因</h2><p>导致简介中的问题其实非常简单。<mark>windows 默认的 WebClient 服务仅支持 https 协议</mark>，而本地搭建的 webdav 服务和链接都是基于 http 协议的，因此才造成了挂载失败的情况。</p><p>对于部分高手来说，将 webdav 服务转换为 https 协议必然是更安全，更好的选择。但是对于部分仅内网挂载访问，安全性需求较低的朋友来说，升级 https 的代价可能有些高昂，因此使 windows 自带的 WebClient 支持 http，可能是更快捷方便的选择。</p><h3 id="三、设置-WebClient，允许-http-链接挂载"><a href="#三、设置-WebClient，允许-http-链接挂载" class="headerlink" title="三、设置 WebClient，允许 http 链接挂载"></a>三、设置 WebClient，允许 http 链接挂载</h3><p>步骤1：<br>按下 “<strong>windows徽标键</strong>“ + “<strong>R</strong>“，打开运行窗口，输入<code>regedit</code>，点击确定后，打开注册表编辑器窗口。</p><p>步骤2：<br>将路径定位到以下路径：<code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WebClient\Parameters</code>。双击右侧界面中的 <code>BasicAuthLevel</code> 条目，将数值数据修改为“2”，点击确定后关闭注册表编辑器。</p><p><img src="https://user-images.githubusercontent.com/35327600/215690501-29b6636a-a17b-4fcd-a871-f3ddf031dfef.png"></p><p>步骤3：<br>按下 “<strong>windows徽标键</strong>“ + “<strong>R</strong>“，打开运行窗口，输入<code>services.msc</code>，点击确定后，打开“服务”界面。找到 “<strong>WebClient</strong>“<br>服务，右键点击打开选项菜单，选择重新启动，稍等几秒，待完成后，关闭“服务”界面。</p><p><img src="https://user-images.githubusercontent.com/35327600/215691793-fc3e4385-f6e4-47ed-bd8e-7a00d3a7cf4f.png"></p><p>完成上述三个步骤后，WebClient 服务已经允许使用 http 协议进行挂载。</p><h2 id="四、挂载测试"><a href="#四、挂载测试" class="headerlink" title="四、挂载测试"></a>四、挂载测试</h2><ol><li><p>映射网络驱动器<br> <img src="https://user-images.githubusercontent.com/35327600/215694498-777dba03-505a-4922-9485-ba99c0eb5809.png"><br> <img src="https://user-images.githubusercontent.com/35327600/215694514-24f0ddf9-f2b2-4059-8e7a-107b216565d9.png"></p></li><li><p>添加网络位置<br> <img src="https://user-images.githubusercontent.com/35327600/215695212-f220eeb9-23f0-4500-987d-dea5146898a4.png"><br> <img src="https://user-images.githubusercontent.com/35327600/215695227-595b63d6-c31e-4d06-83da-98179b01fdb1.png"></p></li></ol><p>可以看到，在修改注册表后，映射网络驱动器和添加网络位置，都能正确访问 webdav 服务了。</p>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Windows10</tag>
      
      <tag>Webdav</tag>
      
      <tag>注册表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式</title>
    <link href="/2023/02/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/02/17/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><blockquote><p>在C++11和更高版本中，Lambda表达式（通常称为Lambda）是一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。Lambda通常用于封装传递给算法或异步函数的少量代码行。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++ 中的 Lambda 表达式（https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170）](https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170)">[1]</span></a></sup></p></blockquote><p>Lambda表达式是C++11中一个较为重要的特性，其来源于函数式编程的概念，也是现代编程语言的一个特点。</p><p>Lambda表达式有以下优点：</p><ul><li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。以更直接的方式撰写程序代码，具有较高的可读性和可维护性。</li><li>简介：不需要额外写一个函数或函数对象，避免代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也具备更高的生产效率。</li><li>在需要的时间和地点实现功能闭包，使程序更灵活。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[C++11 lambda表达式精讲（http://c.biancheng.net/view/3741.html）](http://c.biancheng.net/view/3741.html)">[2]</span></a></sup></li></ul><p>下文将记录和简述Lambda表达式中的基本概念和用法。</p><h2 id="一、Lambda表达式组成"><a href="#一、Lambda表达式组成" class="headerlink" title="一、Lambda表达式组成"></a>一、Lambda表达式组成</h2><p>ISO C++ 标准展示了作为第三个参数传递给 <code>std::sort()</code> 函数的简单 lambda：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">abssort</span><span class="hljs-params">(<span class="hljs-type">float</span>* x, <span class="hljs-type">unsigned</span> n)</span> </span>&#123;<br>std::<span class="hljs-built_in">sort</span>(x, x+n, <br><span class="hljs-comment">// Lambda expression begins</span><br>[](<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b) &#123;<br><span class="hljs-built_in">return</span> (std::<span class="hljs-built_in">abs</span>(a) &lt; std::<span class="hljs-built_in">abs</span>(b));<br>&#125; <span class="hljs-comment">// end of lambda expression</span><br>);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的简单Lambda示例，可以将其按照下图进行概括：</p><p><img src="https://learn.microsoft.com/zh-cn/cpp/cpp/media/lambdaexpsyntax.png?view=msvc-170" alt="Lambda组成"></p><p>其中各个组成部分分别表示为：</p><ol><li>capture子句（C++规范中也称为Lambda引导）</li><li>参数列表（可选）。（也称为Lambda声明符）</li><li>mutable规范（可选）。</li><li>exception-specification（可选）。</li><li>trailing-return-type（可选）。</li><li>Lambda体，即函数体。</li></ol><h2 id="二、capture子句"><a href="#二、capture子句" class="headerlink" title="二、capture子句"></a>二、capture子句</h2><p>Lambda 以 capture 子句开头，它用于指示 Lambda 捕获周边范围中的哪些变量，以及捕获变量的方式（按值捕获、按引用捕获’&amp;’），当然也可以使用空的 capture 子句<code>[ ]</code>表示不捕获任何变量。</p><p>除了在 capture 子句中直接指定待捕获的外部变量，也可以使用默认捕获模式来指示如何捕获Lambda体中引用的任何外部变量：</p><ol><li><p><code>[&amp;]</code>：表示通过“<strong>引用捕获</strong>”引用所有的变量</p></li><li><p><code>[=]</code>：表示通过“<strong>值捕获</strong>”获取外部变量的值</p></li></ol><p><font color=red>当使用默认捕获模式时，仍然可以为特定变量显式地指定相反的模式</font>。例如，Lambda 体通过引用访问外部变量 <code>a</code> ，并通过值访问外部变量 <code>b</code> ，则可以参考以下 capture 子句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[&amp;a, b] <span class="hljs-comment">// 分别指定引用访问a，值访问b</span><br>[b, &amp;a] <span class="hljs-comment">// 单独指定时，不区分先后顺序</span><br>[=, &amp;a] <span class="hljs-comment">// 默认使用值捕获，但是变量a使用引用捕获</span><br>[&amp;,  b] <span class="hljs-comment">// 默认使用引用捕获，但是表量b使用值捕获</span><br><span class="hljs-comment">// 使用默认捕获时，只有 Lambda 体中提及的变量才会被捕获。</span><br></code></pre></td></tr></table></figure><p><mark>在类成员函数中使用 Lambda，如果 Lambda 需要访问类的成员函数和数据成员，则需要将this指针传递给 capture 子句。在C++17及以上版本中，可以通过在 capture 子句中指定<code>*this</code>通过值捕获<code>this</code>指针</mark>。</p><p>在使用 capture 子句时，有以下几点建议：</p><ul><li><font color=red>Lambda 能捕获当前作用域内的<code>non-static</code>类型变量，对于全局变量，局部静态变量，则可以在 Lambda 体中直接引用</font>，但是此处容易存在依赖问题，在下文章节 [“Effective Modern C++ 中的 Lambda 表达式”](#八、Effective Modern C++ 中的 Lambda 表达式) 中进行介绍。</li><li>引用捕获可用于修改外部变量，而值捕获却不能实现此操作。（<font color=red><code>mutable</code>声明允许修改Lambda中的副本，但不会修改原始项</font>）</li><li>引用捕获会反映外部变量的更新，而值捕获不会。</li><li>避免使用默认捕获模式。（同第一条，将在 [“Effective Modern C++ 中的 Lambda 表达式”](#八、Effective Modern C++ 中的 Lambda 表达式) 章节中详细描述）</li></ul><h2 id="三、通用捕获-x2F-初始化捕获（init-capture）（C-14）"><a href="#三、通用捕获-x2F-初始化捕获（init-capture）（C-14）" class="headerlink" title="三、通用捕获&#x2F;初始化捕获（init capture）（C++14）"></a>三、通用捕获&#x2F;初始化捕获（<em>init capture</em>）（C++14）</h2><p>在某些场景下，如果有一个只能被移动的对象（例如<code>std::unique_ptr</code>或<code>std::future</code>）要进入闭包中，使用C++11是无法实现的。又或者要复制的对象复制开销非常高，但移动成本却相对比较低（例如stl标准库中的大多数容器），并且开发者期望的是宁愿移动该对象到闭包而不是复制时，C++11也无法实现该目标。</p><p>在C++14标准中，增加了通用捕获，又或者叫初始化捕获，移动捕获是它可以执行的技术之一。</p><p>使用初始化捕获时，开发者可以指定：</p><ol><li>从 lambda 生成的闭包类中的数据成员名称；</li><li>初始化该成员的表达式</li></ol><p>见以下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pNums = make_unique&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(nums);<br><br><span class="hljs-keyword">auto</span> a = [ptr = <span class="hljs-built_in">move</span>(pNums)]() &#123;<br><span class="hljs-comment">// use ptr</span><br>  &#125;;<br></code></pre></td></tr></table></figure><h2 id="四、参数列表"><a href="#四、参数列表" class="headerlink" title="四、参数列表"></a>四、参数列表</h2><p>参数列表（在标准语法中称为 Lambda 声明符）是可选的。在大多数时候，它类似于参数的参数列表。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>在C++14中，可以使用<code>auto</code>关键字作为类型说明符，表示泛型参数类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>在C++14中，Lambda 也接受可变形参</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> &amp;&amp;...params) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(<span class="hljs-built_in">normalize</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(params)&gt;(params)...));<br>  &#125;;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>由于参数列表是可选的，因此在不将自变量传递到 Lambda 表达式，并且其 Lambda 声明符不包含 exception-specification、trailing-return-type 或 <strong><code>mutable</code></strong> 的情况下，可以省略空括号。</p></blockquote><h2 id="五、mutable-规范"><a href="#五、mutable-规范" class="headerlink" title="五、mutable 规范"></a>五、mutable 规范</h2><p><mark>通常，Lambda 的函数调用运算符是<code>const-by-value</code>，但是对<code>mutable</code>关键字的使用可以取消。利用<code>mutable</code>规范，Lambda 表达式的主题可以修改通过值捕获的变量。</mark></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *b = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">auto</span> f4 = [b]() <span class="hljs-keyword">mutable</span> &#123;<br>  b = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>  *b = <span class="hljs-number">10</span>;<br>  cout &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;--&quot;</span> &lt;&lt; *b &lt;&lt; endl;<br>  <span class="hljs-keyword">delete</span> b;<br>&#125;;<br><span class="hljs-built_in">f4</span>();<br></code></pre></td></tr></table></figure><h2 id="六、异常规范"><a href="#六、异常规范" class="headerlink" title="六、异常规范"></a>六、异常规范</h2><p>你可以使用 noexcept 异常规范来指示 Lambda 表达式不会引发任何异常。 与普通函数一样，如果 Lambda 表达式声明 noexcept 异常规范且 Lambda 体引发异常，Microsoft C++ 编译器将生成警告。</p><h2 id="七、返回类型"><a href="#七、返回类型" class="headerlink" title="七、返回类型"></a>七、返回类型</h2><p>编译器能够自动推导 Lambda 表达值返回值类型，缺省状态下即表示为自动推导。当然也可以手动指定 trailing-return-type。trailing-return-type 类似普通函数的return-type，但是返回类型必须更在参数列表后面，并且必须在返回类型前包含关键字 <code>-&gt;</code>。</p><p>Lambda 表达式可以生成另一个 lambda 表达式作为其返回值。</p><h2 id="八、Effective-Modern-C-中的-Lambda-表达式"><a href="#八、Effective-Modern-C-中的-Lambda-表达式" class="headerlink" title="八、Effective Modern C++ 中的 Lambda 表达式"></a>八、Effective Modern C++ 中的 Lambda 表达式</h2><p>在《Effective Modern C++》中也对 lambda 表达式给出了相关的建议，一共包含了四项条款，将在下文进行介绍和记录。</p><h3 id="条款31：避免使用默认捕获模式"><a href="#条款31：避免使用默认捕获模式" class="headerlink" title="条款31：避免使用默认捕获模式"></a>条款31：避免使用默认捕获模式</h3><p>Item 31: Avoid default capture modes</p><p>就个人理解而言，该条款主要还是针对使用默认的按引用捕获时，由于引用存在依赖生命周期的问题，因此极易导致悬空引用的问题。而默认的按值捕获，按照作者的描述，则可能诱骗开发者以为能解决悬空引用的问题（实际上并没有解决），还会让开发者误以为自己所构建的闭包是独立的（事实上也并不是独立的）。</p><p>对于默认按引用捕获导致悬空引用的问题，我们先来举一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> Fn = function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><br><span class="hljs-function">Fn <span class="hljs-title">capture_by_ref</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Fn <span class="hljs-title">capture_by_val</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> f = <span class="hljs-built_in">capture_by_ref</span>();<br>  <span class="hljs-built_in">f</span>();<br>  f = <span class="hljs-built_in">capture_by_val</span>();<br>  <span class="hljs-built_in">f</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Fn <span class="hljs-title">capture_by_val</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [=]()&#123;cout &lt;&lt; <span class="hljs-string">&quot;capture_by_val: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;;<br>&#125;<br><br><span class="hljs-function">Fn <span class="hljs-title">capture_by_ref</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [&amp;]()&#123;cout &lt;&lt; <span class="hljs-string">&quot;capture_by_ref: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在<code>Ubuntu 20.04</code>下编译运行，结果如下图所示：<br><img src="https://user-images.githubusercontent.com/35327600/215710670-8e68c21d-58ba-450f-8342-f49a40bc2589.png"><br>可以清晰的看到，按值捕获的 a 可以正常输出打印。但是在按引用捕获的情形下，a已经成为一个悬空的引用了，在 cout 时，出现了未定义的行为。每次执行输出的 a 的值都是一个随机值。</p><p>为什么会出现这个问题呢？根本原因就在于按引用捕获！</p><p>在<code>Fn capture_by_ref();</code>函数中，<font color=red>Lambda 捕获了一个临时变量的引用，但是在函数 return 之后，临时变量 a 将被系统自动释放出栈，此时 a 的生命周期已经结束</font>。而 Lambda 中却仍然保存着该临时变量的引用，“这里我们可以暂时将其理解为闭包类中保存的是原临时变量 a 的地址，在函数<code>capture_by_ref</code> return 之后，该地址被释放，里面的内容自然变成了未定义的内容”，所以每次调用时程序所打印的内容都是未知的值。</p><p>这个例子很好的说明了按引用捕获存在着较高的引用悬空的风险，默认的引用捕获则更是加大了这种风险，因此尽量还是避免使用默认的按引用捕获。</p><p><code>Fn capture_by_val();</code>采用了按值捕获的方式，正确打印了被捕获的变量 a 的值，这也确实是解决被引用捕获的变量的生命周期短于 Lambda 导致引用悬空问题的一个正确方法。但是这并不代表着按值捕获不存在问题。按值捕获同样存在着依赖生命周期的问题。</p><p>再来看一个简单的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>  *a = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// Lambda 按值捕获指针变量 a，在闭包类中保存 a 的副本</span><br>  <span class="hljs-keyword">auto</span> f = [=]() &#123; cout &lt;&lt; *a &lt;&lt; endl; &#125;;<br>  <span class="hljs-comment">// 在外部调用 delete 释放指针变量 a</span><br>  <span class="hljs-keyword">delete</span> a;<br>  <span class="hljs-comment">// 调用 Lambda，运行时会提示 heap-used-after-free</span><br>  <span class="hljs-built_in">f</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// avoid_default_capture.cc</span><br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://user-images.githubusercontent.com/35327600/215921879-efb4fc60-68db-4e35-a1a8-53c75da3bc1b.png"></p><p>结果是显而易见的，尽管我们在 Lambda 中使用了按值捕获以获得指针变量 a 的副本，但是我们无法避免外部对这个指针变量的 delete 操作。在这个例子中，Lambda 表达式执行时，指针变量 a 已经成为一个未定义的内容，直接对其解引用操作自然也就存在严重错误了。</p><p>当然这个例子放在这里可能比较极端，但是在多线程的异步编程中，变量生命周期长短不同，需要大量线程同步的情况随处可见，因此不得不小心。更何况在多线程中，还存在着大量的异步读写，这也可能会导致 Lambda 对该变量存在脏读的可能。</p><p>如果只能使用C++11标准，那么对于这种特定的问题，可以<font color=red>通过给期望捕获的变量做一个局部副本，然后捕获该副本去解决</font>，比如像下面例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>  *a = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 期望捕获指针变量 a，用以获取 a 中存储的内容</span><br>  <span class="hljs-comment">// 声明一个 _a 变量，作为指针变量 a 的局部副本</span><br>  <span class="hljs-type">int</span> _a = *a;<br>  <span class="hljs-comment">// 通过按值捕获副本，避免出现依赖生命周期的问题</span><br>  <span class="hljs-keyword">auto</span> f = [_a]() &#123; cout &lt;&lt; _a &lt;&lt; endl; &#125;;<br>  <span class="hljs-comment">// 在外部调用 delete 释放指针变量 a</span><br>  <span class="hljs-keyword">delete</span> a;<br>  <span class="hljs-comment">// 此时调用函数 f()，就不再出现之前的“heap-used-after-free”问题</span><br>  <span class="hljs-built_in">f</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// avoid_default_capture.cc</span><br></code></pre></td></tr></table></figure><p><mark>如果你被允许使用C++14或者更高的标准，那么使用“初始化捕获”可能是更好的选择。</mark></p><p>默认捕获模式，还存在一个更大的隐患，在类的“non-static”成员函数中使用默认捕获。众所周知，在类的“non-static”成员函数中，都包含了一个隐式指针 “<strong>this</strong>”。这里直接展示《Effective Modern C++》中的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> FilterContainer =                     <span class="hljs-comment">//“using”参见条款9，</span><br>    std::vector&lt;std::function&lt;<span class="hljs-built_in">bool</span>(<span class="hljs-type">int</span>)&gt;&gt;;  <span class="hljs-comment">//std::function参见条款2</span><br><br>FilterContainer filters;                    <span class="hljs-comment">//过滤函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    …                       <span class="hljs-comment">//构造函数等</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addFilter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">//向filters添加条目</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> divisor;            <span class="hljs-comment">//在Widget的过滤器使用</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::addFilter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    filters.<span class="hljs-built_in">emplace_back</span>(<br>        [=](<span class="hljs-type">int</span> value) &#123; <span class="hljs-keyword">return</span> value % divisor == <span class="hljs-number">0</span>; &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>在函数<code>void Widget::addFilter() const;</code>中，Lambda 中使用了一个变量 <code>divisor</code>。对于不熟悉 lambda 的开发者来说，可能不太能理解变量 divisor 是什么，从哪里来的。C++ 中类的“non-static”成员函数都包含一个隐式的参数——“<strong>this</strong>指针”，而在 lambda 的捕获子句中使用了默认按值捕获的模式，这也就意味着 lambda 捕获了这个类的“<strong>this</strong>”指针，因此可以在 lambda 体中直接访问该类的数据成员和成员函数。<font color=red>由于捕获只能应用与 lambda 被创建时所在作用域内的 “non-static” 局部变量（包括形参）</font>,因此直接显式地指定捕获 divisor 变量，或者删除默认捕获模式，都将导致该代码编译失败。</p><p>这也就是前面提到的，默认按值捕获，会诱骗开发者错误地认为当前闭包是独立的。对于这个缺点，《Effective Modern C++》中还给出了一个例子，让我们来简单看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addDivisorFilter</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> calc1 = <span class="hljs-built_in">computeSomeValue1</span>();    <span class="hljs-comment">//现在是static</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> calc2 = <span class="hljs-built_in">computeSomeValue2</span>();    <span class="hljs-comment">//现在是static</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> divisor =                       <span class="hljs-comment">//现在是static</span><br>    <span class="hljs-built_in">computeDivisor</span>(calc1, calc2);<br><br>    filters.<span class="hljs-built_in">emplace_back</span>(<br>        [=](<span class="hljs-type">int</span> value)                          <span class="hljs-comment">//什么也没捕获到！</span><br>        &#123; <span class="hljs-keyword">return</span> value % divisor == <span class="hljs-number">0</span>; &#125;        <span class="hljs-comment">//引用上面的static</span><br>    );<br><br>    ++divisor;                                  <span class="hljs-comment">//调整divisor</span><br>&#125;<br></code></pre></td></tr></table></figure><p>还记得上面提到的一个 Lambda 表达值中 capture 子句的一个限制吗？<font color=red>捕获只能应用与 lambda 被创建时所在作用域内的 “non-static” 局部变量（包括形参）</font>。那么在这个例子中，如果开发者对这个限制不了解，那么可能会错误地理解此处 Lambda 体中对 divisor 变量的使用是基于按值捕获的，也就会错误地认为在 Lambda 体中，divisor 变量始终为初始化的值。</p><p><mark>正确的解释应该是这样。divisor 被声明为 static 类型，因此在 Lambda 体中不需要捕获该变量，即可直接引用。这也就意味着这个被添加的闭包依赖了外部的 divisor，所有的闭包会随着外部 divisor 的变化而变化。所以，这个闭包根本不是独立的！</mark></p><p>我们再回顾一下上面 Widget 的例子，通过默认捕获模式捕获 this 指针，然后在 lambda 中访问类的数据成员，就目前来看没有任何问题。但是其中隐含了一个依赖生命周期的问题。还是《Effective Modern C++》中的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomeWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> pw =                               <span class="hljs-comment">//创建Widget；std::make_unique</span><br>        std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;();         <span class="hljs-comment">//见条款21</span><br><br>    pw-&gt;<span class="hljs-built_in">addFilter</span>();                        <span class="hljs-comment">//添加使用Widget::divisor的过滤器</span><br><br>    …<br>&#125;                                           <span class="hljs-comment">//销毁Widget；filters现在持有悬空指针！</span><br></code></pre></td></tr></table></figure><p>在调用 <code>doSomeWork()</code> 时，通过 <code>std::make_unique</code> 构建了一个 Widget 的对象，并且该对象向全局的 filters 中添加了一个过滤器。但是该过滤器中依赖了 Widget 对象的 this 指针，因为在默认捕获模式下访问了对象的数据成员 divisor。但是在函数 <code>doSomeWork()</code> 结束时，基于智能指针 <code>std::unique_ptr</code> 的特性，Widget 对象将自动析构，这意味着 this 指针也将被销毁。但是我们在全局的 filters 中仍然保存一个依赖于 this 指针的过滤器，尽管这个指针已经悬空！</p><p>简单总结一下《Effective Modern C++》中条款31中对 Lambda 捕获变量过程中存在的限制和隐患：</p><ol><li>捕获只能应用与 lambda 被创建时所在作用域内的 “non-static” 局部变量（包括形参）。</li><li>静态存储生命周期的对象，这些对象定义在全局空间或者命名空间，或者在类、函数、文件中被声明为 <code>static</code> ，这些变量无法被 lambda捕获，但可以直接使用</li><li>无论是按值捕获，还是按引用捕获，都存在依赖生命周期的问题。其中按引用捕获可能会导致悬空引用，而按值捕获则对悬空指针很敏感（尤其是 this 指针），并且容易误导开发者产生 lambda 是独立的想法。</li></ol><p>基于上面的几点，《Effective Modern C++》建议尽可能避免使用默认捕获模式，显式地指定期望被捕获的变量可能是个更好的选择。</p><h3 id="条款32：使用初始化捕获来移动对象到闭包中"><a href="#条款32：使用初始化捕获来移动对象到闭包中" class="headerlink" title="条款32：使用初始化捕获来移动对象到闭包中"></a>条款32：使用初始化捕获来移动对象到闭包中</h3><p>Item 32: Use init capture to move objects into closures</p><p>根据作者的表述，C++14标准中增加“初始化捕获”的初衷，是为了解决C++11中无法移动捕获的缺陷，但是移动捕获只是该捕获机制中的一中执行技术。</p><p>为什么初始化捕获可以执行移动捕获？本质上是因为下面两点特性：</p><ol><li>可以指定从 lambda 生成的闭包类中的数据成员的名称；</li><li>可以指定初始化该成员的表达式；</li></ol><p>因此可以通过移动语句的表达式完成对成员的初始化，从而实现移动捕获。下面简单介绍一下在C++14标准下通过初始化捕获将特定内容移动到闭包的方法，以及C++11实现近似移动捕获的方法。</p><p>其实在C++14中，这显得非常简单，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;                          <span class="hljs-comment">//一些有用的类型</span><br><span class="hljs-keyword">public</span>:<br>    …<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidated</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isProcessed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isArchived</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    …<br>&#125;;<br><br><span class="hljs-keyword">auto</span> pw = std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;();   <span class="hljs-comment">//创建Widget；使用std::make_unique</span><br>                                        <span class="hljs-comment">//的有关信息参见条款21</span><br><br>…                                       <span class="hljs-comment">//设置*pw</span><br><br><span class="hljs-keyword">auto</span> func1 = [pw = std::<span class="hljs-built_in">move</span>(pw)]        <span class="hljs-comment">//使用std::move(pw)初始化闭包数据成员</span><br>            &#123; <span class="hljs-keyword">return</span> pw-&gt;<span class="hljs-built_in">isValidated</span>()<br>                     &amp;&amp; pw-&gt;<span class="hljs-built_in">isArchived</span>(); &#125;;<br><br></code></pre></td></tr></table></figure><p>在 capture 子句中，“&#x3D;” 的左侧是指定的数据成员，右侧则是初始化表达式。这里就是通过初始化捕获的方式，将一个 <code>std::unique_ptr</code> 移动到了闭包类中。关于“&#x3D;”左右两侧的作用域，我想应该不必多说，左侧既然是闭包类的数据成员，那么其作用域必然仅仅在闭包类之内，而右侧则是一个外部变量，那么其作用域必然和当前的 lambda 享有同样的作用域。</p><p>倘若上述例子中，不需要要设置 *pw 那么可以再度简化 lambda 的捕获语句，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> func1 = [pw = std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;()]<br>            &#123; <span class="hljs-keyword">return</span> pw-&gt;<span class="hljs-built_in">isValidated</span>()<br>                     &amp;&amp; pw-&gt;<span class="hljs-built_in">isArchived</span>(); &#125;;<br></code></pre></td></tr></table></figure><p>因此，在C++14标准下，通过初始化捕获模式完成移动捕获是一件非常简单和便捷的事。但是这并不代表在C++11标准下，移动捕获是不可实现的。</p><p>对于在C++11下实现移动捕获，《Effective Modern C++》中给出了两种方式来模拟初始化捕获。</p><p>第一种，手写“闭包类”。<font color=red>Lambda 表达式只是生成一个类和创建该类型对象的一种简单方式</font>，因此通过手写实现这个类，同样可以模拟实现初始化捕获。直接看例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IsValAndArch</span> &#123;                            <span class="hljs-comment">//“is validated and archived”</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> DataType = std::unique_ptr&lt;Widget&gt;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">IsValAndArch</span><span class="hljs-params">(DataType&amp;&amp; ptr)</span>       <span class="hljs-comment">//条款25解释了std::move的使用</span></span><br><span class="hljs-function">    : pw(std::move(ptr)) &#123;</span>&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> pw-&gt;<span class="hljs-built_in">isValidated</span>() &amp;&amp; pw-&gt;<span class="hljs-built_in">isArchived</span>(); &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    DataType pw;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> func2 = <span class="hljs-built_in">IsValAndArch</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Widget&gt;()); <span class="hljs-comment">// func 的真实类型是什么？ IsValAndArch</span><br></code></pre></td></tr></table></figure><p>通过将构造函数的参数设置为右值引用类型，通过 <code>std::move</code> 完成对数据成员 pw 的初始化。并通过重载括号运算符 <code>()</code> ，使对象可以通过 <code>()</code> 直接获取 Widget 对象 pw 的状态。虽然此处 func2 的使用方式和上文中的 func1 看起来一致，都形如 <code>func()</code>，但是两个 func 在本质上存在着差异，func1 实际为一个闭包对象，可以通过 <code>std::function</code> 进行包装，而 fun2 本质上只是普通类 IsValAndArch 的一个实例对象而已！</p><p>第二种模拟初始化捕获的方式，则是使用 <code>std::bind</code>：</p><ol><li>将要捕获的对象移动到由 <code>std::bind</code> 产生的函数对象中；</li><li>将“被捕获的”对象的引用赋予给 lambda 表达式。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">double</span>&gt; data;               <span class="hljs-comment">//要移动进闭包的对象</span><br><br>…                                       <span class="hljs-comment">//填充data</span><br><br><span class="hljs-keyword">auto</span> func = [data = std::<span class="hljs-built_in">move</span>(data)]    <span class="hljs-comment">//C++14初始化捕获</span><br>            &#123; <span class="hljs-comment">/*使用data*/</span> &#125;;<br><br><span class="hljs-keyword">auto</span> func_cpp11 =<br>    std::<span class="hljs-built_in">bind</span>(                              <span class="hljs-comment">//C++11模拟初始化捕获</span><br>        [](<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data) <span class="hljs-comment">//译者注：本行高亮</span><br>        &#123; <span class="hljs-comment">/*使用data*/</span> &#125;,<br>        std::<span class="hljs-built_in">move</span>(data)                     <span class="hljs-comment">//译者注：本行高亮</span><br>    );<br><br></code></pre></td></tr></table></figure>当然上面两个func不能写到同一处，因为在初始化捕获时，data已经将其内容移动到 func 这个闭包对象的数据成员 data 中了，在 func_cpp11 中再次进行 move 自然是无效移动了。</li></ol><p><font color=red>在默认情况下，从 lambda 生成的闭包类中的 operator() 成员函数为 const 的，这能将闭包中的所有数据成员渲染为 const 的效果</font>。<mark>而 std::bind 对象内部的移动构造的 data 副本不是 const的</mark>，因此为了避免 lambda 内部对该副本产生修改，此处形参声明为 reference-to-const 是必要的。</p><p>下面是《Effective Modern C++》中对此节内容的总结，一起看一下：</p><ul><li>无法移动构造一个对象到C++11闭包，但是可以将对象移动构造进C++11的bind对象。</li><li>在C++11中模拟移动捕获包括将对象移动构造进bind对象，然后通过传引用将移动构造的对象传递给lambda。</li><li>由于bind对象的生命周期与闭包对象的生命周期相同，因此可以将bind对象中的对象视为闭包中的对象。</li></ul><h3 id="条款33：对auto-amp-amp-形参使用decltype用以std-forward（完美转发）它们"><a href="#条款33：对auto-amp-amp-形参使用decltype用以std-forward（完美转发）它们" class="headerlink" title="条款33：对auto&amp;&amp;形参使用decltype用以std::forward（完美转发）它们"></a>条款33：对auto&amp;&amp;形参使用decltype用以std::forward（完美转发）它们</h3><p>Item 33: Use decltype on auto&amp;&amp; parameters to std::forward them</p><blockquote><p>由于完美转发掌握的有限，后续在进行补充</p></blockquote><h3 id="条款34：考虑lambda而非std-bind"><a href="#条款34：考虑lambda而非std-bind" class="headerlink" title="条款34：考虑lambda而非std::bind"></a>条款34：考虑lambda而非std::bind</h3><p>Item 34: Prefer lambdas to std::bind</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">C++ 中的 Lambda 表达式（https://learn.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170）</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://c.biancheng.net/view/3741.html">C++11 lambda表达式精讲（http://c.biancheng.net/view/3741.html）</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>程序员进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>lambda</tag>
      
      <tag>Linux编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unraid下虚拟DSM7.1，并开启相册人脸识别</title>
    <link href="/2023/02/17/Unraid%E4%B8%8B%E8%99%9A%E6%8B%9FDSM7-1%EF%BC%8C%E5%B9%B6%E5%BC%80%E5%90%AF%E7%9B%B8%E5%86%8C%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <url>/2023/02/17/Unraid%E4%B8%8B%E8%99%9A%E6%8B%9FDSM7-1%EF%BC%8C%E5%B9%B6%E5%BC%80%E5%90%AF%E7%9B%B8%E5%86%8C%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Unraid下虚拟DSM7-1，并开启相册人脸识别"><a href="#Unraid下虚拟DSM7-1，并开启相册人脸识别" class="headerlink" title="Unraid下虚拟DSM7.1，并开启相册人脸识别"></a>Unraid下虚拟DSM7.1，并开启相册人脸识别</h1><p><strong><font color="red">风险提示！！！请勿直接应用于生产环境或者单一数据存储环境，当前仅为测试版本！！！数据无价，请务必做好数据备份！！！</font></strong></p><p><strong><font color="red">风险提示！！！请勿直接应用于生产环境或者单一数据存储环境，当前仅为测试版本！！！数据无价，请务必做好数据备份！！！</font></strong></p><p><strong><font color="red">风险提示！！！请勿直接应用于生产环境或者单一数据存储环境，当前仅为测试版本！！！数据无价，请务必做好数据备份！！！</font></strong></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>由于主机换新，之前的旧设备闲置也是闲置，于是参考 <a href="https://space.bilibili.com/28457/">Unraid 教父——司波图</a>一系列教程搭建了一台 Unraid 系统的 NAS。之前四盘位的 J3455 蜗牛星际也快满了，并且性能远远低于换代下来的 i5 8500，正好将内容迁移到 Unraid 上。但是群晖的相册套件说实话简单上手好用，还自带人脸识别，所以还是打算在 Unraid 上虚拟一个黑群晖，专门用于相册的备份和维护。废话不多说，下面开始干货。</p><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><table><thead><tr><th align="left"></th><th align="right"></th></tr></thead><tbody><tr><td align="left">sys</td><td align="right">Unraid 6.10.3</td></tr><tr><td align="left">cpu</td><td align="right">Intel® Core™ i5-8500 CPU @ 3.00GHz</td></tr><tr><td align="left">主板</td><td align="right">Gigabyte Technology Co., Ltd. B360M AORUS Gaming 3-CF</td></tr><tr><td align="left">内存</td><td align="right">DDR4 -  24G 普条</td></tr><tr><td align="left">硬盘</td><td align="right">希捷 ST18000NM013J_ZR56YQB9 - 18 TB<br />西数 SN570 -1TB</td></tr></tbody></table><p>基本配置如上，其中西数的 SN570 作为 cache 使用，无校验盘。“亡命之徒”本徒了。</p><p><strong><font color="red">注意：如果需要添加校验盘，则校验盘容量必须大于等于阵列中单硬盘最大容量，以上配置就需要一个 18T 的硬盘作为校验盘。没有校验盘时，重要资料务必多地备份！</font></strong></p><h2 id="三、准备事项"><a href="#三、准备事项" class="headerlink" title="三、准备事项"></a>三、准备事项</h2><p><strong>以下内容都是基于 DSM918+ 7.1.0 展开，其余设备型号或者版本因精力有限未做尝试！</strong></p><ol><li>准备一个 tinycore-redpill 的基础镜像（tinycore-redpill-uefi.v0.8.0.0.img）：<a href="https://github.com/pocopico/tinycore-redpill">https://github.com/pocopico/tinycore-redpill</a></li><li>准备 DSM918+ 7.1.0patch 文件：<a href="https://cndl.synology.cn/download/DSM/release/7.1/42661-1/DSM_DS918%2B_42661.pat">https://cndl.synology.cn/download/DSM/release/7.1/42661-1/DSM_DS918%2B_42661.pat</a></li><li>主板 bios 打开核显（安装过程中发现，核显被设置为自动，当有独显时，核显默认不开，会导致 Unraid 无法获取核显信息，<strong>Intel GVT-g</strong> 插件无法使用）</li><li>ssh 工具，如 xshell，putty，MobaXterm 等</li></ol><h2 id="四、创建虚拟-DSM-流程"><a href="#四、创建虚拟-DSM-流程" class="headerlink" title="四、创建虚拟 DSM 流程"></a>四、创建虚拟 DSM 流程</h2><p><mark><font color="red">再次提醒！！！务必做好数据备份，在无需担心数据损失的前提下进行以下操作！！！</font></mark></p><p><mark><font color="red">再次提醒！！！务必做好数据备份，在无需担心数据损失的前提下进行以下操作！！！</font></mark></p><p><mark><font color="red">再次提醒！！！务必做好数据备份，在无需担心数据损失的前提下进行以下操作！！！</font></mark></p><h3 id="1、创建虚拟机"><a href="#1、创建虚拟机" class="headerlink" title="1、创建虚拟机"></a>1、创建虚拟机</h3><p>创建虚拟机的基本步骤请参考——<a href="https://www.bilibili.com/video/BV1R7411s7gP?spm_id_from=333.999.0.0">unRaid 下黑群晖，Freenas，OMV 的安装方法——司波图 UNRAID 陪玩教程 05</a>。</p><p>最新的创建参数和大佬的有些差别：</p><ol><li>Machine：Q35-6.2</li><li>BIOS：OVMF（tinycore 选择 UEFI 镜像）</li><li>USB Controller：3.0(qemu XHCI)</li><li>Primary vDisk 选择我们事先拷贝到 isos 目录下的镜像文件（tinycore-redpill-uefi.v0.8.0.0.img），并选择 USB 模式</li><li>添加第二块 vDisk，此处设置为 sata 模式，其余按需设置即可</li><li>网卡设置为 e1000</li><li>取消勾选“Start VM after creation”</li></ol><p>此时已基本完成虚拟机相关设置，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/180962087-4ce99534-f44e-4cf7-bb9e-26dc5148f248.png"></p><p>创建后，重新编辑虚拟机，打开 xml 模式，修改以下红框内划线处 <code>controller = &quot;0&quot;</code> 为 <code>controller = &quot;1&quot;</code>。</p><p><img src="https://user-images.githubusercontent.com/35327600/180955218-2dc76d15-879c-4f12-b029-1f90cf0ca5b8.png"></p><p>本人在尝试了无数次卡重新安装 pat 的死循环后，最终在 xp 论坛上找到了解决方案。就是这个 sata disk 的 controller 索引错误导致无法找到 sata 磁盘控制信息，从而卡在安装 pat 文件错误的死循环中。原贴链接：<a href="https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607">https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607</a></p><p>整体安装 DSM 的流程也可参考原贴。</p><h3 id="2、创建完整引导镜像"><a href="#2、创建完整引导镜像" class="headerlink" title="2、创建完整引导镜像"></a>2、创建完整引导镜像</h3><ol><li><p>开启虚拟机，并开启 VNC，看到如下界面：</p><p><img src="https://user-images.githubusercontent.com/35327600/180959772-e0ea5062-238d-4e65-a9f0-db37e77e379e.png"></p><p>按照图片中描述操作，获取当前虚拟机 ip 地址</p></li><li><p>通过 ssh 工具进行连接虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh tc@192.168.2.191<br>&lt;输入密码：P@ssw0rd&gt;<br><br>Connecting to 192.168.2.191:22...<br>Connection established.<br>To escape to local shell, press &#x27;Ctrl+Alt+]&#x27;.<br><br>WARNING! The remote SSH server rejected X11 forwarding request.<br>   ( &#x27;&gt;&#x27;)<br>  /) TC (\   Core is distributed with ABSOLUTELY NO WARRANTY.<br> (/-_--_-\)           www.tinycorelinux.net<br><br>tc@box:~$ <br></code></pre></td></tr></table></figure></li><li><p>依次无脑执行以下命令，命令执行过程中会有部分内容需要手动确定，有 yY 输 y，无 yY 直接回车</p><ul><li><code>./rploader.sh update now</code></li><li><code>./rploader.sh fullupgrade now</code></li><li><code>./rploader.sh serialgen DS918+</code></li><li><code>./rploader.sh satamap now</code></li><li><code>./rploader.sh identifyusb now</code></li><li><code>./rploader.sh ext apollolake-7.1.0-42661 add https://raw.githubusercontent.com/pocopico/rp-ext/master/e1000/rpext-index.json</code></li><li><code>./rploader.sh build apollolake-7.1.0-42661</code></li></ul><p>执行最后一个命令时，可能会有红色日志提示，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[!] Extension is already added (index exists at /home/tc/redpill-load/custom/extensions/pocopico.e1000/pocopico.e1000.json). For more info use &quot;ext-manager.sh info pocopico.e1000&quot;<br>*** Process will exit ***<br></code></pre></td></tr></table></figure><p>该提示目前使用下来无影响，出现如下打印，表示镜像构建成功：</p><p><img src="https://user-images.githubusercontent.com/35327600/180965299-4c8231d4-a541-4275-b167-0ba521330ab8.png"></p></li><li><p>关闭虚拟机，打开 xml 编辑，查看之前修改的 <code>controller = &quot;1&quot;</code> 是否又变回默认值 <code>&quot;0&quot;</code>。如果发生改变，请再一次手动更改为 <code>&quot;1&quot;</code>，否则将无法正确安装 pat 文件。</p></li></ol><h3 id="3、创建-DSM7-1"><a href="#3、创建-DSM7-1" class="headerlink" title="3、创建 DSM7.1"></a>3、创建 DSM7.1</h3><p>启动虚拟机，并在 VNC 中手动选择 USB 引导。（起始界面还有一个 SATA 引导，未进行测试，喜欢折腾可以试试）</p><p>后续就和常规安装群晖一样，使用浏览器访问 <a href="https://finds.synology.com/%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%96%B0%E5%AE%89%E8%A3%85%E7%9A%84">https://finds.synology.com/，获取新安装的</a> DSM 信息，上传 pat 文件进行安装。</p><p><img src="https://user-images.githubusercontent.com/35327600/180968642-5e580051-e9a7-4e82-be03-267eadf2e1b0.png"></p><p>恭喜，DSM 7.1 至此已完成完整的安装！接下来的基本操作就不在赘述了，按照指引正常处理就行。</p><h2 id="五、开启相册人脸识别"><a href="#五、开启相册人脸识别" class="headerlink" title="五、开启相册人脸识别"></a>五、开启相册人脸识别</h2><p>按照上述流程创建的群晖是无法开启相册套件中的人脸识别功能，因为核显没有直通给群晖，导致群晖无法调用核显进行人脸识别。我们需要借助“<strong>Intel GVT-g</strong>”插件虚拟化核显，并配置给我们的群晖虚拟机。</p><ol><li><p>配置好群晖后，关闭虚拟机</p></li><li><p>在 Unraid APP 市场中安装插件 <strong>Intel GVT-g</strong></p></li><li><p>在 PLUGINS 界面中打开 <strong>Intel GVT-g</strong> 配置</p></li><li><p>根据当前虚拟显存的模式，分配给群晖虚拟机，确定后点击 “ASSIGN VM”</p><p><img src="https://user-images.githubusercontent.com/35327600/180971454-d802c4c7-6050-452f-b954-d1bc4e8a3375.png"></p></li><li><p>回到虚拟机的 xml 配置进行修改，安装时的 <code>controller = &quot;1&quot;</code> 还是需要注意的地方。其余部分按下图进行修改：</p><p><img src="https://user-images.githubusercontent.com/35327600/180977569-0c9566b4-8ab8-4232-89d8-a39959387c5a.png"></p><p>找到 xml 中新增的 &lt;hostdev&gt;，将其中的 <code>bus = &#39;0x01&#39; slot=&#39;0x00&#39;</code> 修改为 <code>bus = &#39;0x00&#39; slot=&#39;0x02&#39;</code>，这是因为虚拟化后核显的地址默认为 <code>0000:00:02.0</code></p><p>由于我们将虚拟化核显的总线（bus）和设备号（slot）修改了，和 xml 中部分原有配置产生冲突，因此需要将其余 <code>bus = &#39;0x00&#39; slot=&#39;0x02&#39;</code> 所在的行删除，如下图所示：</p><p><img src="https://user-images.githubusercontent.com/35327600/180977611-5185c30b-d8d6-43d6-94c8-b6dfc9714bfd.png"></p></li><li><p>修改完成后，重启群晖虚拟机，在 <code>控制面板-&gt;终端机和SNMP</code> 中打开 ssh 功能。使用 ssh 工具进行连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">输入：ls /dev/dri<br>显示：card0  renderD128<br></code></pre></td></tr></table></figure></li></ol><p>如果能正常显示上述内容，如果不是设备特殊，此时应该已经能进行人脸识别，我们测试一下</p><h2 id="六、人脸识别功能测试"><a href="#六、人脸识别功能测试" class="headerlink" title="六、人脸识别功能测试"></a>六、人脸识别功能测试</h2><p>在套件中心搜索关键词“photo”，下载安装完成后打开，点击右上角用户图标，在设置中“启用个人空间人物相册”</p><p><img src="https://user-images.githubusercontent.com/35327600/180982129-913020e6-c84d-4f68-9292-c982bc34b2c2.png"></p><p>找几张图上传，等一段时间后，查看一下人物相册，是否根据人脸识别自动创建了对应的相册，如果正确创建了，那么恭喜！</p><p><img src="https://user-images.githubusercontent.com/35327600/181008438-89e5df3b-ec6e-4bad-ab56-56d63161810a.png"></p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul><li>pocopico 大佬的 github：<a href="https://github.com/pocopico/tinycore-redpill">https://github.com/pocopico/tinycore-redpill</a></li><li>xpenology 论坛：<a href="https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607">https://xpenology.com/forum/topic/63333-tutorial-install-dsm-71-on-unraid-6103/#comment-287607</a></li><li>Jinlife 大佬博客：<a href="https://blog.jinlife.com/index.php/archives/49/">https://blog.jinlife.com/index.php/archives/49/</a></li><li>张大妈：<a href="https://post.smzdm.com/p/a5dl2808/">https://post.smzdm.com/p/a5dl2808/</a></li><li>司波图 B 站教程视频：<a href="https://space.bilibili.com/28457/channel/seriesdetail?sid=896368">https://space.bilibili.com/28457/channel/seriesdetail?sid=896368</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>unRAID</tag>
      
      <tag>DSM7.1</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
